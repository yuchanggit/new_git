// Generated at Tue Dec 20 22:57:05 2016. Do not modify it

/*
GCC-XML version 0.9.0
Configuration settings:
  GCCXML_CONFIG="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20140124-0/share/gccxml-0.9/gccxml_config"
  GCCXML_COMPILER="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/c++"
  GCCXML_CXXFLAGS=""
  GCCXML_EXECUTABLE="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20140124-0/bin/gccxml_cc1plus"
  GCCXML_CPP="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20140124-0/bin/gccxml_cc1plus"
  GCCXML_FLAGS="-D__DBL_MIN_EXP__='(-1021)' -D__UINT_LEAST16_MAX__='65535' -D__ATOMIC_ACQUIRE='2' -D__FLT_MIN__='1.17549435082228750797e-38F' -D__UINT_LEAST8_TYPE__='unsigned char' -D__INTMAX_C(c)='c ## L' -D__CHAR_BIT__='8' -D__UINT8_MAX__='255' -D__WINT_MAX__='4294967295U' -D__ORDER_LITTLE_ENDIAN__='1234' -D__SIZE_MAX__='18446744073709551615UL' -D__WCHAR_MAX__='2147483647' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4='1' -D__DBL_DENORM_MIN__='double(4.94065645841246544177e-324L)' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8='1' -D__GCC_ATOMIC_CHAR_LOCK_FREE='2' -D__FLT_EVAL_METHOD__='0' -D__unix__='1' -D__GCC_ATOMIC_CHAR32_T_LOCK_FREE='2' -D__x86_64='1' -D__UINT_FAST64_MAX__='18446744073709551615UL' -D__SIG_ATOMIC_TYPE__='int' -D__DBL_MIN_10_EXP__='(-307)' -D__FINITE_MATH_ONLY__='0' -D__GNUC_PATCHLEVEL__='1' -D__UINT_FAST8_MAX__='255' -D__DEC64_MAX_EXP__='385' -D__INT8_C(c)='c' -D__UINT_LEAST64_MAX__='18446744073709551615UL' -D__SHRT_MAX__='32767' -D__LDBL_MAX__='1.18973149535723176502e+4932L' -D__UINT_LEAST8_MAX__='255' -D__GCC_ATOMIC_BOOL_LOCK_FREE='2' -D__UINTMAX_TYPE__='long unsigned int' -D__linux='1' -D__DEC32_EPSILON__='1E-6DF' -D__unix='1' -D__UINT32_MAX__='4294967295U' -D__LDBL_MAX_EXP__='16384' -D__WINT_MIN__='0U' -D__linux__='1' -D__SCHAR_MAX__='127' -D__WCHAR_MIN__='(-__WCHAR_MAX__ - 1)' -D__INT64_C(c)='c ## L' -D__DBL_DIG__='15' -D__GCC_ATOMIC_POINTER_LOCK_FREE='2' -D__SIZEOF_INT__='4' -D__SIZEOF_POINTER__='8' -D__GCC_ATOMIC_CHAR16_T_LOCK_FREE='2' -D__USER_LABEL_PREFIX__='' -D__STDC_HOSTED__='1' -D__LDBL_HAS_INFINITY__='1' -D__FLT_EPSILON__='1.19209289550781250000e-7F' -D__GXX_WEAK__='1' -D__LDBL_MIN__='3.36210314311209350626e-4932L' -D__DEC32_MAX__='9.999999E96DF' -D__INT32_MAX__='2147483647' -D__SIZEOF_LONG__='8' -D__UINT16_C(c)='c' -D__DECIMAL_DIG__='21' -D__gnu_linux__='1' -D__LDBL_HAS_QUIET_NAN__='1' -D__GNUC__='4' -D__GXX_RTTI='1' -D__MMX__='1' -D__FLT_HAS_DENORM__='1' -D__SIZEOF_LONG_DOUBLE__='16' -D__BIGGEST_ALIGNMENT__='16' -D__DBL_MAX__='double(1.79769313486231570815e+308L)' -D__INT_FAST32_MAX__='9223372036854775807L' -D__DBL_HAS_INFINITY__='1' -D__INT64_MAX__='9223372036854775807L' -D__DEC32_MIN_EXP__='(-94)' -D__INT_FAST16_TYPE__='long int' -D__LDBL_HAS_DENORM__='1' -D__cplusplus='199711L' -D__DEC128_MAX__='9.999999999999999999999999999999999E6144DL' -D__INT_LEAST32_MAX__='2147483647' -D__DEC32_MIN__='1E-95DF' -D__DEPRECATED='1' -D__DBL_MAX_EXP__='1024' -D__DEC128_EPSILON__='1E-33DL' -D__SSE2_MATH__='1' -D__ATOMIC_HLE_RELEASE='131072' -D__PTRDIFF_MAX__='9223372036854775807L' -D__amd64='1' -D__ATOMIC_HLE_ACQUIRE='65536' -D__GNUG__='4' -D__LONG_LONG_MAX__='9223372036854775807LL' -D__SIZEOF_SIZE_T__='8' -D__SIZEOF_WINT_T__='4' -D__GCC_HAVE_DWARF2_CFI_ASM='1' -D__GXX_ABI_VERSION='999999' -D__FLT_MIN_EXP__='(-125)' -D__INT_FAST64_TYPE__='long int' -D__DBL_MIN__='double(2.22507385850720138309e-308L)' -D__LP64__='1' -D__DECIMAL_BID_FORMAT__='1' -D__DEC128_MIN__='1E-6143DL' -D__REGISTER_PREFIX__='' -D__UINT16_MAX__='65535' -D__DBL_HAS_DENORM__='1' -D__UINT8_TYPE__='unsigned char' -D__NO_INLINE__='1' -D__FLT_MANT_DIG__='24' -D__VERSION__='"4.8.1"' -D__UINT64_C(c)='c ## UL' -D__GCC_ATOMIC_INT_LOCK_FREE='2' -D__FLOAT_WORD_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__INT32_C(c)='c' -D__DEC64_EPSILON__='1E-15DD' -D__ORDER_PDP_ENDIAN__='3412' -D__DEC128_MIN_EXP__='(-6142)' -D__INT_FAST32_TYPE__='long int' -D__UINT_LEAST16_TYPE__='short unsigned int' -Dunix='1' -D__INT16_MAX__='32767' -D__SIZE_TYPE__='long unsigned int' -D__UINT64_MAX__='18446744073709551615UL' -D__INT8_TYPE__='signed char' -D__ELF__='1' -D__FLT_RADIX__='2' -D__INT_LEAST16_TYPE__='short int' -D__LDBL_EPSILON__='1.08420217248550443401e-19L' -D__UINTMAX_C(c)='c ## UL' -D__k8='1' -D__SIG_ATOMIC_MAX__='2147483647' -D__GCC_ATOMIC_WCHAR_T_LOCK_FREE='2' -D__SIZEOF_PTRDIFF_T__='8' -D__x86_64__='1' -D__DEC32_SUBNORMAL_MIN__='0.000001E-95DF' -D__INT_FAST16_MAX__='9223372036854775807L' -D__UINT_FAST32_MAX__='18446744073709551615UL' -D__UINT_LEAST64_TYPE__='long unsigned int' -D__FLT_HAS_QUIET_NAN__='1' -D__FLT_MAX_10_EXP__='38' -D__LONG_MAX__='9223372036854775807L' -D__DEC128_SUBNORMAL_MIN__='0.000000000000000000000000000000001E-6143DL' -D__FLT_HAS_INFINITY__='1' -D__UINT_FAST16_TYPE__='long unsigned int' -D__DEC64_MAX__='9.999999999999999E384DD' -D__CHAR16_TYPE__='short unsigned int' -D__PRAGMA_REDEFINE_EXTNAME='1' -D__INT_LEAST16_MAX__='32767' -D__DEC64_MANT_DIG__='16' -D__UINT_LEAST32_MAX__='4294967295U' -D__GCC_ATOMIC_LONG_LOCK_FREE='2' -D__INT_LEAST64_TYPE__='long int' -D__INT16_TYPE__='short int' -D__INT_LEAST8_TYPE__='signed char' -D__DEC32_MAX_EXP__='97' -D__INT_FAST8_MAX__='127' -D__INTPTR_MAX__='9223372036854775807L' -Dlinux='1' -D__SSE2__='1' -D__EXCEPTIONS='1' -D__LDBL_MANT_DIG__='64' -D__DBL_HAS_QUIET_NAN__='1' -D__SIG_ATOMIC_MIN__='(-__SIG_ATOMIC_MAX__ - 1)' -D__code_model_small__='1' -D__k8__='1' -D__INTPTR_TYPE__='long int' -D__UINT16_TYPE__='short unsigned int' -D__WCHAR_TYPE__='int' -D__SIZEOF_FLOAT__='4' -D__UINTPTR_MAX__='18446744073709551615UL' -D__DEC64_MIN_EXP__='(-382)' -D__INT_FAST64_MAX__='9223372036854775807L' -D__GCC_ATOMIC_TEST_AND_SET_TRUEVAL='1' -D__FLT_DIG__='6' -D__UINT_FAST64_TYPE__='long unsigned int' -D__INT_MAX__='2147483647' -D__amd64__='1' -D__INT64_TYPE__='long int' -D__FLT_MAX_EXP__='128' -D__ORDER_BIG_ENDIAN__='4321' -D__DBL_MANT_DIG__='53' -D__INT_LEAST64_MAX__='9223372036854775807L' -D__DEC64_MIN__='1E-383DD' -D__WINT_TYPE__='unsigned int' -D__UINT_LEAST32_TYPE__='unsigned int' -D__SIZEOF_SHORT__='2' -D__SSE__='1' -D__LDBL_MIN_EXP__='(-16381)' -D__INT_LEAST8_MAX__='127' -D__SIZEOF_INT128__='16' -D__LDBL_MAX_10_EXP__='4932' -D__ATOMIC_RELAXED='0' -D__DBL_EPSILON__='double(2.22044604925031308085e-16L)' -D_LP64='1' -D__UINT8_C(c)='c' -D__INT_LEAST32_TYPE__='int' -D__SIZEOF_WCHAR_T__='4' -D__UINT64_TYPE__='long unsigned int' -D__INT_FAST8_TYPE__='signed char' -D__DBL_DECIMAL_DIG__='17' -D__FXSR__='1' -D__DEC_EVAL_METHOD__='2' -D__UINT32_C(c)='c ## U' -D__INTMAX_MAX__='9223372036854775807L' -D__BYTE_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__FLT_DENORM_MIN__='1.40129846432481707092e-45F' -D__INT8_MAX__='127' -D__UINT_FAST32_TYPE__='long unsigned int' -D__CHAR32_TYPE__='unsigned int' -D__FLT_MAX__='3.40282346638528859812e+38F' -D__INT32_TYPE__='int' -D__SIZEOF_DOUBLE__='8' -D__INTMAX_TYPE__='long int' -D__DEC128_MAX_EXP__='6145' -D__ATOMIC_CONSUME='1' -D__GNUC_MINOR__='8' -D__UINTMAX_MAX__='18446744073709551615UL' -D__DEC32_MANT_DIG__='7' -D__DBL_MAX_10_EXP__='308' -D__LDBL_DENORM_MIN__='3.64519953188247460253e-4951L' -D__INT16_C(c)='c' -D__STDC__='1' -D__PTRDIFF_TYPE__='long int' -D__ATOMIC_SEQ_CST='5' -D__UINT32_TYPE__='unsigned int' -D__UINTPTR_TYPE__='long unsigned int' -D__DEC64_SUBNORMAL_MIN__='0.000000000000001E-383DD' -D__DEC128_MANT_DIG__='34' -D__LDBL_MIN_10_EXP__='(-4931)' -D__SSE_MATH__='1' -D__SIZEOF_LONG_LONG__='8' -D__GCC_ATOMIC_LLONG_LOCK_FREE='2' -D__LDBL_DIG__='18' -D__FLT_DECIMAL_DIG__='9' -D__UINT_FAST16_MAX__='18446744073709551615UL' -D__GNUC_GNU_INLINE__='1' -D__FLT_MIN_10_EXP__='(-37)' -D__GCC_ATOMIC_SHORT_LOCK_FREE='2' -D__UINT_FAST8_TYPE__='unsigned char' -D_GNU_SOURCE='1' -D__ATOMIC_ACQ_REL='4' -D__ATOMIC_RELEASE='3' -iwrapper"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20140124-0/share/gccxml-0.9/GCC/4.8" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/../../../../include/c++/4.8.1" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/../../../../include/c++/4.8.1/x86_64-redhat-linux-gnu" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/../../../../include/c++/4.8.1/backward" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/include" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/include-fixed" -isystem"/usr/local/include" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/../../include" -isystem"/usr/include" -include "gccxml_builtins.h""
  GCCXML_USER_FLAGS=""
  GCCXML_ROOT="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20140124-0/share/gccxml-0.9"

Compiler info:
c++ (GCC) 4.8.1
Copyright (C) 2013 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

*/

#ifdef _WIN32
#pragma warning ( disable : 4786 )
#pragma warning ( disable : 4345 )
#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)) && !defined(__INTEL_COMPILER) 
# pragma GCC diagnostic ignored "-Warray-bounds"
#endif
#include "src/DataFormats/JetReco/src/classes_4.h"
#ifdef CONST
# undef CONST
#endif
#include "Reflex/Builder/ReflexBuilder.h"
#include <typeinfo>

namespace {
  ::Reflex::NamespaceBuilder nsb0( Reflex::Literal("std") );
  ::Reflex::NamespaceBuilder nsb1( Reflex::Literal("edm") );
  ::Reflex::NamespaceBuilder nsb2( Reflex::Literal("reco") );
  ::Reflex::NamespaceBuilder nsb3( Reflex::Literal("edm::reftobase") );
  ::Reflex::Type type_68 = ::Reflex::TypeBuilder(Reflex::Literal("int"));
  ::Reflex::Type type_62 = ::Reflex::TypeBuilder(Reflex::Literal("long"));
  ::Reflex::Type type_694 = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_void = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_1566 = ::Reflex::TypeBuilder(Reflex::Literal("bool"));
  ::Reflex::Type type_894 = ::Reflex::TypeBuilder(Reflex::Literal("float"));
  ::Reflex::Type type_237 = ::Reflex::TypeBuilder(Reflex::Literal("short"));
  ::Reflex::Type type_101 = ::Reflex::TypeBuilder(Reflex::Literal("double"));
  ::Reflex::Type type_7843 = ::Reflex::TypeBuilder(Reflex::Literal("reco::Jet"));
  ::Reflex::Type type_366 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned int"));
  ::Reflex::Type type_7841 = ::Reflex::TypeBuilder(Reflex::Literal("reco::JetID"));
  ::Reflex::Type type_7794 = ::Reflex::TypeBuilder(Reflex::Literal("reco::PFJet"));
  ::Reflex::Type type_358 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned long"));
  ::Reflex::Type type_4935 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefCore"));
  ::Reflex::Type type_7893 = ::Reflex::TypeBuilder(Reflex::Literal("reco::GenJet"));
  ::Reflex::Type type_499 = ::Reflex::TypeBuilder(Reflex::Literal("std::type_info"));
  ::Reflex::Type type_7818 = ::Reflex::TypeBuilder(Reflex::Literal("reco::CaloJet"));
  ::Reflex::Type type_4933 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ProductID"));
  ::Reflex::Type type_7854 = ::Reflex::TypeBuilder(Reflex::Literal("reco::TrackJet"));
  ::Reflex::Type type_7994 = ::Reflex::TypeBuilder(Reflex::Literal("reco::BasicJet"));
  ::Reflex::Type type_7973 = ::Reflex::TypeBuilder(Reflex::Literal("reco::PFCluster"));
  ::Reflex::Type type_6144 = ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate"));
  ::Reflex::Type type_7991 = ::Reflex::TypeBuilder(Reflex::Literal("reco::JetTagInfo"));
  ::Reflex::Type type_7846 = ::Reflex::TypeBuilder(Reflex::Literal("reco::CastorJetID"));
  ::Reflex::Type type_8005 = ::Reflex::TypeBuilder(Reflex::Literal("reco::BaseTagInfo"));
  ::Reflex::Type type_4894 = ::Reflex::TypeBuilder(Reflex::Literal("edm::PtrVectorBase"));
  ::Reflex::Type type_2991 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<float>"));
  ::Reflex::Type type_8007 = ::Reflex::TypeBuilder(Reflex::Literal("reco::PFClusterJet"));
  ::Reflex::Type type_5079 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ValueMap<int>"));
  ::Reflex::Type type_4998 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ptr<reco::Jet>"));
  ::Reflex::Type type_2989 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<double>"));
  ::Reflex::Type type_7938 = ::Reflex::TypeBuilder(Reflex::Literal("reco::FFTJet<float>"));
  ::Reflex::Type type_5017 = ::Reflex::TypeBuilder(Reflex::Literal("edm::EDProductGetter"));
  ::Reflex::Type type_7939 = ::Reflex::TypeBuilder(Reflex::Literal("reco::FFTJet<double>"));
  ::Reflex::Type type_4989 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ptr<reco::JetID>"));
  ::Reflex::Type type_4995 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ptr<reco::PFJet>"));
  ::Reflex::Type type_4624 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefCoreWithIndex"));
  ::Reflex::Type type_7813 = ::Reflex::TypeBuilder(Reflex::Literal("reco::CATopJetTagInfo"));
  ::Reflex::Type type_14203 = ::Reflex::TypeBuilder(Reflex::Literal("reco::PFJet::Specific"));
  ::Reflex::Type type_4993 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ptr<reco::GenJet>"));
  ::Reflex::Type type_14269 = ::Reflex::TypeBuilder(Reflex::Literal("reco::JPTJet::Specific"));
  ::Reflex::Type type_4997 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ptr<reco::CaloJet>"));
  ::Reflex::Type type_2563 = ::Reflex::TypeBuilder(Reflex::Literal("std::basic_string<char>"));
  ::Reflex::Type type_7826 = ::Reflex::TypeBuilder(Reflex::Literal("reco::CATopJetProperties"));
  ::Reflex::Type type_7787 = ::Reflex::TypeBuilder(Reflex::Literal("reco::TrackExtrapolation"));
  ::Reflex::Type type_14335 = ::Reflex::TypeBuilder(Reflex::Literal("reco::CaloJet::Specific"));
  ::Reflex::Type type_3000 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<reco::JetID>"));
  ::Reflex::Type type_2970 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<const void*>"));
  ::Reflex::Type type_4992 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ptr<reco::TrackJet>"));
  ::Reflex::Type type_4994 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ptr<reco::BasicJet>"));
  ::Reflex::Type type_4978 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefToBase<reco::Jet>"));
  ::Reflex::Type type_7810 = ::Reflex::TypeBuilder(Reflex::Literal("reco::PattRecoPeak<float>"));
  ::Reflex::Type type_4990 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ptr<reco::PFCluster>"));
  ::Reflex::Type type_4645 = ::Reflex::TypeBuilder(Reflex::Literal("edm::PtrVector<reco::Jet>"));
  ::Reflex::Type type_2972 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned int>"));
  ::Reflex::Type type_7809 = ::Reflex::TypeBuilder(Reflex::Literal("reco::PattRecoPeak<double>"));
  ::Reflex::Type type_2971 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned long>"));
  ::Reflex::Type type_5081 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ValueMap<reco::JetID>"));
  ::Reflex::Type type_3307 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<reco::JetID>"));
  ::Reflex::Type type_4988 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ptr<reco::CastorJetID>"));
  ::Reflex::Type type_4637 = ::Reflex::TypeBuilder(Reflex::Literal("edm::PtrVector<reco::JetID>"));
  ::Reflex::Type type_4642 = ::Reflex::TypeBuilder(Reflex::Literal("edm::PtrVector<reco::PFJet>"));
  ::Reflex::Type type_7921 = ::Reflex::TypeBuilder(Reflex::Literal("reco::FFTJetProducerSummary"));
  ::Reflex::Type type_4991 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ptr<reco::PFClusterJet>"));
  ::Reflex::Type type_4640 = ::Reflex::TypeBuilder(Reflex::Literal("edm::PtrVector<reco::GenJet>"));
  ::Reflex::Type type_4807 = ::Reflex::TypeBuilder(Reflex::Literal("edm::PtrVectorItr<reco::Jet>"));
  ::Reflex::Type type_7811 = ::Reflex::TypeBuilder(Reflex::Literal("reco::FFTAnyJet<reco::GenJet>"));
  ::Reflex::Type type_4644 = ::Reflex::TypeBuilder(Reflex::Literal("edm::PtrVector<reco::CaloJet>"));
  ::Reflex::Type type_7851 = ::Reflex::TypeBuilder(Reflex::Literal("reco::FFTAnyJet<reco::CaloJet>"));
  ::Reflex::Type type_2999 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<reco::CastorJetID>"));
  ::Reflex::Type type_4799 = ::Reflex::TypeBuilder(Reflex::Literal("edm::PtrVectorItr<reco::JetID>"));
  ::Reflex::Type type_4639 = ::Reflex::TypeBuilder(Reflex::Literal("edm::PtrVector<reco::TrackJet>"));
  ::Reflex::Type type_4641 = ::Reflex::TypeBuilder(Reflex::Literal("edm::PtrVector<reco::BasicJet>"));
  ::Reflex::Type type_4804 = ::Reflex::TypeBuilder(Reflex::Literal("edm::PtrVectorItr<reco::PFJet>"));
  ::Reflex::Type type_12435 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::RefHolderBase"));
  ::Reflex::Type type_4802 = ::Reflex::TypeBuilder(Reflex::Literal("edm::PtrVectorItr<reco::GenJet>"));
  ::Reflex::Type type_4806 = ::Reflex::TypeBuilder(Reflex::Literal("edm::PtrVectorItr<reco::CaloJet>"));
  ::Reflex::Type type_4039 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVectorBase<unsigned int>"));
  ::Reflex::Type type_5080 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ValueMap<reco::CastorJetID>"));
  ::Reflex::Type type_3306 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<reco::CastorJetID>"));
  ::Reflex::Type type_4636 = ::Reflex::TypeBuilder(Reflex::Literal("edm::PtrVector<reco::CastorJetID>"));
  ::Reflex::Type type_4801 = ::Reflex::TypeBuilder(Reflex::Literal("edm::PtrVectorItr<reco::TrackJet>"));
  ::Reflex::Type type_4803 = ::Reflex::TypeBuilder(Reflex::Literal("edm::PtrVectorItr<reco::BasicJet>"));
  ::Reflex::Type type_2973 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<reco::CATopJetTagInfo>"));
  ::Reflex::Type type_2994 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<reco::PFJet::Specific>"));
  ::Reflex::Type type_4638 = ::Reflex::TypeBuilder(Reflex::Literal("edm::PtrVector<reco::PFClusterJet>"));
  ::Reflex::Type type_2995 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<reco::JPTJet::Specific>"));
  ::Reflex::Type type_4936 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::RefVectorHolderBase"));
  ::Reflex::Type type_2996 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<reco::CaloJet::Specific>"));
  ::Reflex::Type type_4798 = ::Reflex::TypeBuilder(Reflex::Literal("edm::PtrVectorItr<reco::CastorJetID>"));
  ::Reflex::Type type_2993 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<reco::TrackExtrapolation>"));
  ::Reflex::Type type_3301 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<reco::PFJet::Specific>"));
  ::Reflex::Type type_4800 = ::Reflex::TypeBuilder(Reflex::Literal("edm::PtrVectorItr<reco::PFClusterJet>"));
  ::Reflex::Type type_3272 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<reco::CATopJetTagInfo>"));
  ::Reflex::Type type_3302 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<reco::JPTJet::Specific>"));
  ::Reflex::Type type_5063 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Handle<std::vector<reco::JetID> >"));
  ::Reflex::Type type_23847 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::BaseHolder<reco::Jet>"));
  ::Reflex::Type type_4757 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<reco::TrackExtrapolation>"));
  ::Reflex::Type type_3303 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<reco::CaloJet::Specific>"));
  ::Reflex::Type type_2997 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<edm::Ptr<reco::PFCluster> >"));
  ::Reflex::Type type_3006 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<edm::Ptr<reco::Candidate> >"));
  ::Reflex::Type type_2794 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<reco::TrackExtrapolation>"));
  ::Reflex::Type type_4960 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefProd<std::vector<reco::JetID> >"));
  ::Reflex::Type type_4957 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefProd<std::vector<reco::PFJet> >"));
  ::Reflex::Type type_4765 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<reco::JetID> >"));
  ::Reflex::Type type_3300 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<reco::TrackExtrapolation>"));
  ::Reflex::Type type_2802 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<reco::JetID> >"));
  ::Reflex::Type type_4987 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ptr<reco::FFTAnyJet<reco::GenJet> >"));
  ::Reflex::Type type_4958 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefProd<std::vector<reco::GenJet> >"));
  ::Reflex::Type type_4986 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ptr<reco::FFTAnyJet<reco::CaloJet> >"));
  ::Reflex::Type type_4750 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<reco::FFTJetProducerSummary>"));
  ::Reflex::Type type_4763 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<edm::ValueMap<reco::JetID> >"));
  ::Reflex::Type type_3304 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<edm::Ptr<reco::PFCluster> >"));
  ::Reflex::Type type_2787 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<reco::FFTJetProducerSummary>"));
  ::Reflex::Type type_2800 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::ValueMap<reco::JetID> >"));
  ::Reflex::Type type_4852 = ::Reflex::TypeBuilder(Reflex::Literal("edm::TestHandle<std::vector<reco::JetID> >"));
  ::Reflex::Type type_2988 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<reco::FFTAnyJet<reco::GenJet> >"));
  ::Reflex::Type type_4656 = ::Reflex::TypeBuilder(Reflex::Literal("edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >"));
  ::Reflex::Type type_25908 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ValueMap<reco::JetID>::const_iterator"));
  ::Reflex::Type type_5014 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Association<std::vector<reco::PFJet> >"));
  ::Reflex::Type type_2983 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<reco::FFTAnyJet<reco::CaloJet> >"));
  ::Reflex::Type type_4655 = ::Reflex::TypeBuilder(Reflex::Literal("edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >"));
  ::Reflex::Type type_5062 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Handle<std::vector<reco::CastorJetID> >"));
  ::Reflex::Type type_4916 = ::Reflex::TypeBuilder(Reflex::Literal("edm::OrphanHandle<std::vector<reco::JetID> >"));
  ::Reflex::Type type_5015 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Association<std::vector<reco::GenJet> >"));
  ::Reflex::Type type_2773 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::reftobase::RefHolderBase>"));
  ::Reflex::Type type_23848 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::BaseHolder<reco::Candidate>"));
  ::Reflex::Type type_4959 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefProd<std::vector<reco::CastorJetID> >"));
  ::Reflex::Type type_4762 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<reco::CastorJetID> >"));
  ::Reflex::Type type_7892 = ::Reflex::TypeBuilder(Reflex::Literal("reco::PattRecoNode<reco::PattRecoPeak<float> >"));
  ::Reflex::Type type_2799 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<reco::CastorJetID> >"));
  ::Reflex::Type type_3295 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<reco::FFTAnyJet<reco::GenJet> >"));
  ::Reflex::Type type_4635 = ::Reflex::TypeBuilder(Reflex::Literal("edm::PtrVector<reco::FFTAnyJet<reco::GenJet> >"));
  ::Reflex::Type type_23846 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::BaseHolder<reco::BaseTagInfo>"));
  ::Reflex::Type type_7891 = ::Reflex::TypeBuilder(Reflex::Literal("reco::PattRecoNode<reco::PattRecoPeak<double> >"));
  ::Reflex::Type type_4878 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<reco::TrackExtrapolation>"));
  ::Reflex::Type type_3286 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<reco::FFTAnyJet<reco::CaloJet> >"));
  ::Reflex::Type type_4634 = ::Reflex::TypeBuilder(Reflex::Literal("edm::PtrVector<reco::FFTAnyJet<reco::CaloJet> >"));
  ::Reflex::Type type_4760 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<edm::ValueMap<reco::CastorJetID> >"));
  ::Reflex::Type type_2797 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::ValueMap<reco::CastorJetID> >"));
  ::Reflex::Type type_4886 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<reco::JetID> >"));
  ::Reflex::Type type_4851 = ::Reflex::TypeBuilder(Reflex::Literal("edm::TestHandle<std::vector<reco::CastorJetID> >"));
  ::Reflex::Type type_5055 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Handle<std::vector<reco::CATopJetTagInfo> >"));
  ::Reflex::Type type_4952 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefProd<std::vector<reco::CATopJetTagInfo> >"));
  ::Reflex::Type type_25874 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ValueMap<reco::CastorJetID>::const_iterator"));
  ::Reflex::Type type_24319 = ::Reflex::TypeBuilder(Reflex::Literal("edm::helper::Filler<edm::ValueMap<reco::JetID> >"));
  ::Reflex::Type type_4797 = ::Reflex::TypeBuilder(Reflex::Literal("edm::PtrVectorItr<reco::FFTAnyJet<reco::GenJet> >"));
  ::Reflex::Type type_4739 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<reco::CATopJetTagInfo> >"));
  ::Reflex::Type type_4871 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<reco::FFTJetProducerSummary>"));
  ::Reflex::Type type_4884 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<edm::ValueMap<reco::JetID> >"));
  ::Reflex::Type type_4915 = ::Reflex::TypeBuilder(Reflex::Literal("edm::OrphanHandle<std::vector<reco::CastorJetID> >"));
  ::Reflex::Type type_4796 = ::Reflex::TypeBuilder(Reflex::Literal("edm::PtrVectorItr<reco::FFTAnyJet<reco::CaloJet> >"));
  ::Reflex::Type type_2774 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<reco::CATopJetTagInfo> >"));
  ::Reflex::Type type_2771 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::reftobase::RefVectorHolderBase>"));
  ::Reflex::Type type_5059 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Handle<std::vector<reco::TrackExtrapolation> >"));
  ::Reflex::Type type_7833 = ::Reflex::TypeBuilder(Reflex::Literal("reco::PattRecoTree<float,reco::PattRecoPeak<float> >"));
  ::Reflex::Type type_4956 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefProd<std::vector<reco::TrackExtrapolation> >"));
  ::Reflex::Type type_2974 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::pair<edm::ProductID,unsigned int> >"));
  ::Reflex::Type type_4844 = ::Reflex::TypeBuilder(Reflex::Literal("edm::TestHandle<std::vector<reco::CATopJetTagInfo> >"));
  ::Reflex::Type type_4756 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<reco::TrackExtrapolation> >"));
  ::Reflex::Type type_2793 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<reco::TrackExtrapolation> >"));
  ::Reflex::Type type_4439 = ::Reflex::TypeBuilder(Reflex::Literal("boost::shared_ptr<edm::reftobase::RefVectorHolderBase>"));
  ::Reflex::Type type_7832 = ::Reflex::TypeBuilder(Reflex::Literal("reco::PattRecoTree<double,reco::PattRecoPeak<double> >"));
  ::Reflex::Type type_4883 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<reco::CastorJetID> >"));
  ::Reflex::Type type_4908 = ::Reflex::TypeBuilder(Reflex::Literal("edm::OrphanHandle<std::vector<reco::CATopJetTagInfo> >"));
  ::Reflex::Type type_8477 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<reco::JetID> >"));
  ::Reflex::Type type_4848 = ::Reflex::TypeBuilder(Reflex::Literal("edm::TestHandle<std::vector<reco::TrackExtrapolation> >"));
  ::Reflex::Type type_24318 = ::Reflex::TypeBuilder(Reflex::Literal("edm::helper::Filler<edm::ValueMap<reco::CastorJetID> >"));
  ::Reflex::Type type_4881 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<edm::ValueMap<reco::CastorJetID> >"));
  ::Reflex::Type type_2986 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >"));
  ::Reflex::Type type_6765 = ::Reflex::TypeBuilder(Reflex::Literal("ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >"));
  ::Reflex::Type type_4912 = ::Reflex::TypeBuilder(Reflex::Literal("edm::OrphanHandle<std::vector<reco::TrackExtrapolation> >"));
  ::Reflex::Type type_5058 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Handle<std::vector<reco::FFTAnyJet<reco::GenJet> > >"));
  ::Reflex::Type type_2981 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >"));
  ::Reflex::Type type_4955 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefProd<std::vector<reco::FFTAnyJet<reco::GenJet> > >"));
  ::Reflex::Type type_5056 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Handle<std::vector<reco::FFTAnyJet<reco::CaloJet> > >"));
  ::Reflex::Type type_4860 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<reco::CATopJetTagInfo> >"));
  ::Reflex::Type type_4749 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<reco::FFTAnyJet<reco::GenJet> > >"));
  ::Reflex::Type type_4758 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<edm::Association<std::vector<reco::PFJet> > >"));
  ::Reflex::Type type_4953 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefProd<std::vector<reco::FFTAnyJet<reco::CaloJet> > >"));
  ::Reflex::Type type_2497 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<reco::JetID,std::allocator<reco::JetID> >"));
  ::Reflex::Type type_2786 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<reco::FFTAnyJet<reco::GenJet> > >"));
  ::Reflex::Type type_2795 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::Association<std::vector<reco::PFJet> > >"));
  ::Reflex::Type type_2776 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::reftobase::BaseVectorHolder<reco::Jet> >"));
  ::Reflex::Type type_4744 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<reco::FFTAnyJet<reco::CaloJet> > >"));
  ::Reflex::Type type_4759 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<edm::Association<std::vector<reco::GenJet> > >"));
  ::Reflex::Type type_2992 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >"));
  ::Reflex::Type type_3293 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >"));
  ::Reflex::Type type_2781 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<reco::FFTAnyJet<reco::CaloJet> > >"));
  ::Reflex::Type type_2796 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::Association<std::vector<reco::GenJet> > >"));
  ::Reflex::Type type_2924 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<edm::RefToBase<reco::Jet>,reco::CATopJetProperties>"));
  ::Reflex::Type type_2990 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >"));
  ::Reflex::Type type_8476 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<reco::CastorJetID> >"));
  ::Reflex::Type type_4877 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<reco::TrackExtrapolation> >"));
  ::Reflex::Type type_3284 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >"));
  ::Reflex::Type type_4847 = ::Reflex::TypeBuilder(Reflex::Literal("edm::TestHandle<std::vector<reco::FFTAnyJet<reco::GenJet> > >"));
  ::Reflex::Type type_4845 = ::Reflex::TypeBuilder(Reflex::Literal("edm::TestHandle<std::vector<reco::FFTAnyJet<reco::CaloJet> > >"));
  ::Reflex::Type type_5013 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > >"));
  ::Reflex::Type type_3299 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<reco::PattRecoNode<reco::PattRecoPeak<float> > >"));
  ::Reflex::Type type_4911 = ::Reflex::TypeBuilder(Reflex::Literal("edm::OrphanHandle<std::vector<reco::FFTAnyJet<reco::GenJet> > >"));
  ::Reflex::Type type_5012 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > >"));
  ::Reflex::Type type_3297 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<reco::PattRecoNode<reco::PattRecoPeak<double> > >"));
  ::Reflex::Type type_4909 = ::Reflex::TypeBuilder(Reflex::Literal("edm::OrphanHandle<std::vector<reco::FFTAnyJet<reco::CaloJet> > >"));
  ::Reflex::Type type_8471 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<reco::PFJet::Specific> >"));
  ::Reflex::Type type_8478 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<reco::CATopJetTagInfo> >"));
  ::Reflex::Type type_7876 = ::Reflex::TypeBuilder(Reflex::Literal("reco::JetTrackMatch<std::vector<reco::FFTAnyJet<reco::GenJet> > >"));
  ::Reflex::Type type_2777 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::reftobase::BaseVectorHolder<reco::Candidate> >"));
  ::Reflex::Type type_8472 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<reco::JPTJet::Specific> >"));
  ::Reflex::Type type_7875 = ::Reflex::TypeBuilder(Reflex::Literal("reco::JetTrackMatch<std::vector<reco::FFTAnyJet<reco::CaloJet> > >"));
  ::Reflex::Type type_8473 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<reco::CaloJet::Specific> >"));
  ::Reflex::Type type_4870 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<reco::FFTAnyJet<reco::GenJet> > >"));
  ::Reflex::Type type_4879 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<edm::Association<std::vector<reco::PFJet> > >"));
  ::Reflex::Type type_2772 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::reftobase::BaseVectorHolder<reco::BaseTagInfo> >"));
  ::Reflex::Type type_4752 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<reco::PattRecoTree<float,reco::PattRecoPeak<float> > >"));
  ::Reflex::Type type_4753 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<edm::RefProd<std::vector<reco::TrackExtrapolation> > >"));
  ::Reflex::Type type_8470 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<reco::TrackExtrapolation> >"));
  ::Reflex::Type type_8321 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<reco::JetID*,std::vector<reco::JetID> >"));
  ::Reflex::Type type_2789 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<reco::PattRecoTree<float,reco::PattRecoPeak<float> > >"));
  ::Reflex::Type type_2790 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::RefProd<std::vector<reco::TrackExtrapolation> > >"));
  ::Reflex::Type type_4865 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<reco::FFTAnyJet<reco::CaloJet> > >"));
  ::Reflex::Type type_4880 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<edm::Association<std::vector<reco::GenJet> > >"));
  ::Reflex::Type type_4751 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<reco::PattRecoTree<double,reco::PattRecoPeak<double> > >"));
  ::Reflex::Type type_8474 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<edm::Ptr<reco::PFCluster> > >"));
  ::Reflex::Type type_2788 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<reco::PattRecoTree<double,reco::PattRecoPeak<double> > >"));
  ::Reflex::Type type_2496 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<reco::CastorJetID,std::allocator<reco::CastorJetID> >"));
  ::Reflex::Type type_20865 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID>"));
  ::Reflex::Type type_4746 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > >"));
  ::Reflex::Type type_2783 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > >"));
  ::Reflex::Type type_4741 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > >"));
  ::Reflex::Type type_8322 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const reco::JetID*,std::vector<reco::JetID> >"));
  ::Reflex::Type type_8483 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<reco::FFTAnyJet<reco::GenJet> > >"));
  ::Reflex::Type type_2778 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > >"));
  ::Reflex::Type type_8484 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<reco::FFTAnyJet<reco::CaloJet> > >"));
  ::Reflex::Type type_4873 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<reco::PattRecoTree<float,reco::PattRecoPeak<float> > >"));
  ::Reflex::Type type_4874 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<edm::RefProd<std::vector<reco::TrackExtrapolation> > >"));
  ::Reflex::Type type_4745 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > > >"));
  ::Reflex::Type type_4872 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<reco::PattRecoTree<double,reco::PattRecoPeak<double> > >"));
  ::Reflex::Type type_22260 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefToBaseVector<reco::JetID> >"));
  ::Reflex::Type type_2782 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > > >"));
  ::Reflex::Type type_4740 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > > >"));
  ::Reflex::Type type_2491 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<reco::PFJet::Specific,std::allocator<reco::PFJet::Specific> >"));
  ::Reflex::Type type_2498 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<reco::CATopJetTagInfo,std::allocator<reco::CATopJetTagInfo> >"));
  ::Reflex::Type type_2775 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > > >"));
  ::Reflex::Type type_8319 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<reco::CastorJetID*,std::vector<reco::CastorJetID> >"));
  ::Reflex::Type type_2492 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<reco::JPTJet::Specific,std::allocator<reco::JPTJet::Specific> >"));
  ::Reflex::Type type_4867 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > >"));
  ::Reflex::Type type_4862 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > >"));
  ::Reflex::Type type_2493 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<reco::CaloJet::Specific,std::allocator<reco::CaloJet::Specific> >"));
  ::Reflex::Type type_20853 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID>"));
  ::Reflex::Type type_22258 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefToBaseVector<reco::CastorJetID> >"));
  ::Reflex::Type type_2490 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<reco::TrackExtrapolation,std::allocator<reco::TrackExtrapolation> >"));
  ::Reflex::Type type_8320 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const reco::CastorJetID*,std::vector<reco::CastorJetID> >"));
  ::Reflex::Type type_4866 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > > >"));
  ::Reflex::Type type_4861 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > > >"));
  ::Reflex::Type type_8308 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<reco::PFJet::Specific*,std::vector<reco::PFJet::Specific> >"));
  ::Reflex::Type type_2494 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<edm::Ptr<reco::PFCluster>,std::allocator<edm::Ptr<reco::PFCluster> > >"));
  ::Reflex::Type type_8466 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > >"));
  ::Reflex::Type type_8323 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<reco::CATopJetTagInfo*,std::vector<reco::CATopJetTagInfo> >"));
  ::Reflex::Type type_22250 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefToBaseVector<reco::CATopJetTagInfo> >"));
  ::Reflex::Type type_8464 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > >"));
  ::Reflex::Type type_8310 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<reco::JPTJet::Specific*,std::vector<reco::JPTJet::Specific> >"));
  ::Reflex::Type type_8469 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<reco::PattRecoNode<reco::PattRecoPeak<float> > > >"));
  ::Reflex::Type type_22256 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefToBaseVector<reco::TrackExtrapolation> >"));
  ::Reflex::Type type_20805 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo>"));
  ::Reflex::Type type_8468 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<reco::PattRecoNode<reco::PattRecoPeak<double> > > >"));
  ::Reflex::Type type_8312 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<reco::CaloJet::Specific*,std::vector<reco::CaloJet::Specific> >"));
  ::Reflex::Type type_3534 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<reco::JetID*,std::vector<reco::JetID> > >"));
  ::Reflex::Type type_8306 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<reco::TrackExtrapolation*,std::vector<reco::TrackExtrapolation> >"));
  ::Reflex::Type type_8309 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const reco::PFJet::Specific*,std::vector<reco::PFJet::Specific> >"));
  ::Reflex::Type type_8324 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const reco::CATopJetTagInfo*,std::vector<reco::CATopJetTagInfo> >"));
  ::Reflex::Type type_8311 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const reco::JPTJet::Specific*,std::vector<reco::JPTJet::Specific> >"));
  ::Reflex::Type type_2503 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<reco::FFTAnyJet<reco::GenJet>,std::allocator<reco::FFTAnyJet<reco::GenJet> > >"));
  ::Reflex::Type type_8314 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<edm::Ptr<reco::PFCluster>*,std::vector<edm::Ptr<reco::PFCluster> > >"));
  ::Reflex::Type type_20841 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation>"));
  ::Reflex::Type type_22254 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefToBaseVector<reco::FFTAnyJet<reco::GenJet> > >"));
  ::Reflex::Type type_8313 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const reco::CaloJet::Specific*,std::vector<reco::CaloJet::Specific> >"));
  ::Reflex::Type type_3533 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const reco::JetID*,std::vector<reco::JetID> > >"));
  ::Reflex::Type type_2504 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<reco::FFTAnyJet<reco::CaloJet>,std::allocator<reco::FFTAnyJet<reco::CaloJet> > >"));
  ::Reflex::Type type_22252 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefToBaseVector<reco::FFTAnyJet<reco::CaloJet> > >"));
  ::Reflex::Type type_6775 = ::Reflex::TypeBuilder(Reflex::Literal("ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>"));
  ::Reflex::Type type_8307 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const reco::TrackExtrapolation*,std::vector<reco::TrackExtrapolation> >"));
  ::Reflex::Type type_8315 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const edm::Ptr<reco::PFCluster>*,std::vector<edm::Ptr<reco::PFCluster> > >"));
  ::Reflex::Type type_6781 = ::Reflex::TypeBuilder(Reflex::Literal("ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>"));
  ::Reflex::Type type_3532 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<reco::CastorJetID*,std::vector<reco::CastorJetID> > >"));
  ::Reflex::Type type_8333 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<reco::FFTAnyJet<reco::GenJet>*,std::vector<reco::FFTAnyJet<reco::GenJet> > >"));
  ::Reflex::Type type_8335 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<reco::FFTAnyJet<reco::CaloJet>*,std::vector<reco::FFTAnyJet<reco::CaloJet> > >"));
  ::Reflex::Type type_20829 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> >"));
  ::Reflex::Type type_3531 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const reco::CastorJetID*,std::vector<reco::CastorJetID> > >"));
  ::Reflex::Type type_20817 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> >"));
  ::Reflex::Type type_8334 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const reco::FFTAnyJet<reco::GenJet>*,std::vector<reco::FFTAnyJet<reco::GenJet> > >"));
  ::Reflex::Type type_3522 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<reco::PFJet::Specific*,std::vector<reco::PFJet::Specific> > >"));
  ::Reflex::Type type_3536 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<reco::CATopJetTagInfo*,std::vector<reco::CATopJetTagInfo> > >"));
  ::Reflex::Type type_8336 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const reco::FFTAnyJet<reco::CaloJet>*,std::vector<reco::FFTAnyJet<reco::CaloJet> > >"));
  ::Reflex::Type type_3008 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >"));
  ::Reflex::Type type_3524 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<reco::JPTJet::Specific*,std::vector<reco::JPTJet::Specific> > >"));
  ::Reflex::Type type_3526 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<reco::CaloJet::Specific*,std::vector<reco::CaloJet::Specific> > >"));
  ::Reflex::Type type_5020 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> >"));
  ::Reflex::Type type_3007 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >"));
  ::Reflex::Type type_3520 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<reco::TrackExtrapolation*,std::vector<reco::TrackExtrapolation> > >"));
  ::Reflex::Type type_3521 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const reco::PFJet::Specific*,std::vector<reco::PFJet::Specific> > >"));
  ::Reflex::Type type_5026 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >"));
  ::Reflex::Type type_3535 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const reco::CATopJetTagInfo*,std::vector<reco::CATopJetTagInfo> > >"));
  ::Reflex::Type type_5023 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<std::vector<reco::PFJet>,reco::PFJet,edm::refhelper::FindUsingAdvance<std::vector<reco::PFJet>,reco::PFJet> >"));
  ::Reflex::Type type_4771 = ::Reflex::TypeBuilder(Reflex::Literal("edm::AssociationMap<edm::OneToMany<std::vector<reco::FFTAnyJet<reco::GenJet> >,std::vector<reco::Track>,unsigned int> >"));
  ::Reflex::Type type_3523 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const reco::JPTJet::Specific*,std::vector<reco::JPTJet::Specific> > >"));
  ::Reflex::Type type_4770 = ::Reflex::TypeBuilder(Reflex::Literal("edm::AssociationMap<edm::OneToMany<std::vector<reco::FFTAnyJet<reco::CaloJet> >,std::vector<reco::Track>,unsigned int> >"));
  ::Reflex::Type type_3528 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<edm::Ptr<reco::PFCluster>*,std::vector<edm::Ptr<reco::PFCluster> > > >"));
  ::Reflex::Type type_3525 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const reco::CaloJet::Specific*,std::vector<reco::CaloJet::Specific> > >"));
  ::Reflex::Type type_5024 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<std::vector<reco::GenJet>,reco::GenJet,edm::refhelper::FindUsingAdvance<std::vector<reco::GenJet>,reco::GenJet> >"));
  ::Reflex::Type type_3519 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const reco::TrackExtrapolation*,std::vector<reco::TrackExtrapolation> > >"));
  ::Reflex::Type type_4691 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >"));
  ::Reflex::Type type_2486 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >,std::allocator<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > >"));
  ::Reflex::Type type_2484 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >,std::allocator<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > >"));
  ::Reflex::Type type_3527 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const edm::Ptr<reco::PFCluster>*,std::vector<edm::Ptr<reco::PFCluster> > > >"));
  ::Reflex::Type type_3546 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<reco::FFTAnyJet<reco::GenJet>*,std::vector<reco::FFTAnyJet<reco::GenJet> > > >"));
  ::Reflex::Type type_2489 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<reco::PattRecoNode<reco::PattRecoPeak<float> >,std::allocator<reco::PattRecoNode<reco::PattRecoPeak<float> > > >"));
  ::Reflex::Type type_3548 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<reco::FFTAnyJet<reco::CaloJet>*,std::vector<reco::FFTAnyJet<reco::CaloJet> > > >"));
  ::Reflex::Type type_2488 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<reco::PattRecoNode<reco::PattRecoPeak<double> >,std::allocator<reco::PattRecoNode<reco::PattRecoPeak<double> > > >"));
  ::Reflex::Type type_4617 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVectorIterator<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >"));
  ::Reflex::Type type_2975 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<edm::Ref<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> > >"));
  ::Reflex::Type type_8298 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >*,std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > >"));
  ::Reflex::Type type_8294 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >*,std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > >"));
  ::Reflex::Type type_3545 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const reco::FFTAnyJet<reco::GenJet>*,std::vector<reco::FFTAnyJet<reco::GenJet> > > >"));
  ::Reflex::Type type_3547 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const reco::FFTAnyJet<reco::CaloJet>*,std::vector<reco::FFTAnyJet<reco::CaloJet> > > >"));
  ::Reflex::Type type_8304 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<reco::PattRecoNode<reco::PattRecoPeak<float> >*,std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > > >"));
  ::Reflex::Type type_8299 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >*,std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > >"));
  ::Reflex::Type type_8302 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<reco::PattRecoNode<reco::PattRecoPeak<double> >*,std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > > >"));
  ::Reflex::Type type_8295 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >*,std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > >"));
  ::Reflex::Type type_5025 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >"));
  ::Reflex::Type type_8305 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const reco::PattRecoNode<reco::PattRecoPeak<float> >*,std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > > >"));
  ::Reflex::Type type_8303 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const reco::PattRecoNode<reco::PattRecoPeak<double> >*,std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > > >"));
  ::Reflex::Type type_4686 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >"));
  ::Reflex::Type type_4616 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVectorIterator<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >"));
  ::Reflex::Type type_3512 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >*,std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > > >"));
  ::Reflex::Type type_5018 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >"));
  ::Reflex::Type type_3504 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >*,std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > > >"));
  ::Reflex::Type type_3518 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<reco::PattRecoNode<reco::PattRecoPeak<float> >*,std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > > > >"));
  ::Reflex::Type type_3511 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >*,std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > > >"));
  ::Reflex::Type type_4665 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >"));
  ::Reflex::Type type_3516 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<reco::PattRecoNode<reco::PattRecoPeak<double> >*,std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > > > >"));
  ::Reflex::Type type_3503 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >*,std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > > >"));
  ::Reflex::Type type_3517 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const reco::PattRecoNode<reco::PattRecoPeak<float> >*,std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > > > >"));
  ::Reflex::Type type_22261 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> > >"));
  ::Reflex::Type type_5022 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >"));
  ::Reflex::Type type_3515 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const reco::PattRecoNode<reco::PattRecoPeak<double> >*,std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > > > >"));
  ::Reflex::Type type_4612 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVectorIterator<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >"));
  ::Reflex::Type type_4681 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >"));
  ::Reflex::Type type_4615 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVectorIterator<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >"));
  ::Reflex::Type type_4755 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >"));
  ::Reflex::Type type_2792 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >"));
  ::Reflex::Type type_23851 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >"));
  ::Reflex::Type type_4754 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >"));
  ::Reflex::Type type_2791 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >"));
  ::Reflex::Type type_5021 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >"));
  ::Reflex::Type type_22259 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> > >"));
  ::Reflex::Type type_4876 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >"));
  ::Reflex::Type type_4775 = ::Reflex::TypeBuilder(Reflex::Literal("edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >"));
  ::Reflex::Type type_5019 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >"));
  ::Reflex::Type type_4676 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >"));
  ::Reflex::Type type_4774 = ::Reflex::TypeBuilder(Reflex::Literal("edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >"));
  ::Reflex::Type type_4875 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >"));
  ::Reflex::Type type_23860 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >"));
  ::Reflex::Type type_4671 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >"));
  ::Reflex::Type type_4614 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVectorIterator<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >"));
  ::Reflex::Type type_2984 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >"));
  ::Reflex::Type type_22251 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >"));
  ::Reflex::Type type_2987 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >"));
  ::Reflex::Type type_4613 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVectorIterator<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >"));
  ::Reflex::Type type_2977 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >"));
  ::Reflex::Type type_3294 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >"));
  ::Reflex::Type type_2982 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >"));
  ::Reflex::Type type_4748 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >"));
  ::Reflex::Type type_2785 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >"));
  ::Reflex::Type type_3285 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >"));
  ::Reflex::Type type_4743 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >"));
  ::Reflex::Type type_2780 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >"));
  ::Reflex::Type type_22257 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >"));
  ::Reflex::Type type_23853 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >"));
  ::Reflex::Type type_4869 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >"));
  ::Reflex::Type type_4747 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >"));
  ::Reflex::Type type_2784 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >"));
  ::Reflex::Type type_23852 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >"));
  ::Reflex::Type type_4864 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >"));
  ::Reflex::Type type_23863 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >"));
  ::Reflex::Type type_4742 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >"));
  ::Reflex::Type type_2779 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >"));
  ::Reflex::Type type_23861 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >"));
  ::Reflex::Type type_4868 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >"));
  ::Reflex::Type type_23864 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >"));
  ::Reflex::Type type_4863 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >"));
  ::Reflex::Type type_23862 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >"));
  ::Reflex::Type type_8467 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >"));
  ::Reflex::Type type_22255 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >"));
  ::Reflex::Type type_8465 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >"));
  ::Reflex::Type type_22253 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >"));
  ::Reflex::Type type_2487 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >,std::allocator<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >"));
  ::Reflex::Type type_2485 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >,std::allocator<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >"));
  ::Reflex::Type type_8300 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*,std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >"));
  ::Reflex::Type type_8301 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*,std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >"));
  ::Reflex::Type type_8296 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*,std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >"));
  ::Reflex::Type type_8297 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*,std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >"));
  ::Reflex::Type type_3514 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*,std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > > >"));
  ::Reflex::Type type_3513 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*,std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > > >"));
  ::Reflex::Type type_3506 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*,std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > > >"));
  ::Reflex::Type type_3505 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*,std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > > >"));
  ::Reflex::Type type_7789 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::FFTGenJetFwdRef"), type_4775);
  ::Reflex::Type type_7796 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::FFTGenJetRefVector"), type_4676);
  ::Reflex::Type type_7797 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::FFTCaloJetFwdRef"), type_4774);
  ::Reflex::Type type_7799 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::CATopJetTagInfoRefVector"), type_4665);
  ::Reflex::Type type_7812 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::FFTGenJet"), type_7811);
  ::Reflex::Type type_7823 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::FFTCaloJetFwdPtrVector"), type_2981);
  ::Reflex::Type type_7837 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::FFTCaloJetCollection"), type_2983);
  ::Reflex::Type type_7838 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::FFTGenJetFwdPtrVector"), type_2986);
  ::Reflex::Type type_7840 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::FFTGenJetRef"), type_5021);
  ::Reflex::Type type_7844 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::FFTCaloJetFwdRefVector"), type_2982);
  ::Reflex::Type type_7849 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::FFTGenJetCollection"), type_2988);
  ::Reflex::Type type_7864 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::FFTGenJetRefProd"), type_4955);
  ::Reflex::Type type_7870 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::CATopJetTagInfoRefProd"), type_4952);
  ::Reflex::Type type_7877 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::FFTCaloJetRefProd"), type_4953);
  ::Reflex::Type type_7895 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::FFTCaloJet"), type_7851);
  ::Reflex::Type type_7896 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::FFTCaloJetFwdPtr"), type_4655);
  ::Reflex::Type type_7903 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::FFTCaloJetRefVector"), type_4671);
  ::Reflex::Type type_7930 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::FFTGenJetFwdRefVector"), type_2987);
  ::Reflex::Type type_7931 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::CATopJetTagInfoRef"), type_5018);
  ::Reflex::Type type_7936 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::CATopJetTagInfoCollection"), type_2973);
  ::Reflex::Type type_7988 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::FFTGenJetFwdPtr"), type_4656);
  ::Reflex::Type type_8008 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::FFTCaloJetRef"), type_5019);
  ::Reflex::Type type_35925 = ::Reflex::ReferenceBuilder(type_2924);
  ::Reflex::Type type_2924c = ::Reflex::ConstBuilder(type_2924);
  ::Reflex::Type type_35926 = ::Reflex::ReferenceBuilder(type_2924c);
  ::Reflex::Type type_4978c = ::Reflex::ConstBuilder(type_4978);
  ::Reflex::Type type_35927 = ::Reflex::ReferenceBuilder(type_4978c);
  ::Reflex::Type type_7826c = ::Reflex::ConstBuilder(type_7826);
  ::Reflex::Type type_35928 = ::Reflex::ReferenceBuilder(type_7826c);
  ::Reflex::Type type_40751 = ::Reflex::ArrayBuilder(type_101, 3);
  ::Reflex::Type type_40752 = ::Reflex::ReferenceBuilder(type_7809);
  ::Reflex::Type type_7809c = ::Reflex::ConstBuilder(type_7809);
  ::Reflex::Type type_40753 = ::Reflex::ReferenceBuilder(type_7809c);
  ::Reflex::Type type_101c = ::Reflex::ConstBuilder(type_101);
  ::Reflex::Type type_3829 = ::Reflex::PointerBuilder(type_101c);
  ::Reflex::Type type_3827 = ::Reflex::PointerBuilder(type_101);
  ::Reflex::Type type_13951 = ::Reflex::ReferenceBuilder(type_7891);
  ::Reflex::Type type_7891c = ::Reflex::ConstBuilder(type_7891);
  ::Reflex::Type type_13953 = ::Reflex::ReferenceBuilder(type_7891c);
  ::Reflex::Type type_366c = ::Reflex::ConstBuilder(type_366);
  ::Reflex::Type type_9419 = ::Reflex::PointerBuilder(type_7891);
  ::Reflex::Type type_13949 = ::Reflex::PointerBuilder(type_7891c);
  ::Reflex::Type type_3254 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::size_t"), type_358);
  ::Reflex::Type type_3138 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::ptrdiff_t"), type_62);
  ::Reflex::Type type_3297c = ::Reflex::ConstBuilder(type_3297);
  ::Reflex::Type type_34584 = ::Reflex::ReferenceBuilder(type_3297c);
  ::Reflex::Type type_2990c = ::Reflex::ConstBuilder(type_2990);
  ::Reflex::Type type_35973 = ::Reflex::ReferenceBuilder(type_2990c);
  ::Reflex::Type type_35974 = ::Reflex::ReferenceBuilder(type_2990);
  ::Reflex::Type type_40754 = ::Reflex::ArrayBuilder(type_894, 3);
  ::Reflex::Type type_40755 = ::Reflex::ReferenceBuilder(type_7810);
  ::Reflex::Type type_7810c = ::Reflex::ConstBuilder(type_7810);
  ::Reflex::Type type_40756 = ::Reflex::ReferenceBuilder(type_7810c);
  ::Reflex::Type type_14081 = ::Reflex::ReferenceBuilder(type_7892);
  ::Reflex::Type type_7892c = ::Reflex::ConstBuilder(type_7892);
  ::Reflex::Type type_14083 = ::Reflex::ReferenceBuilder(type_7892c);
  ::Reflex::Type type_9438 = ::Reflex::PointerBuilder(type_7892);
  ::Reflex::Type type_14079 = ::Reflex::PointerBuilder(type_7892c);
  ::Reflex::Type type_3299c = ::Reflex::ConstBuilder(type_3299);
  ::Reflex::Type type_34597 = ::Reflex::ReferenceBuilder(type_3299c);
  ::Reflex::Type type_2992c = ::Reflex::ConstBuilder(type_2992);
  ::Reflex::Type type_35979 = ::Reflex::ReferenceBuilder(type_2992c);
  ::Reflex::Type type_35980 = ::Reflex::ReferenceBuilder(type_2992);
  ::Reflex::Type type_7857 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::TrackRef"), type_5020);
  ::Reflex::Type type_14146 = ::Reflex::ReferenceBuilder(type_7787);
  ::Reflex::Type type_7787c = ::Reflex::ConstBuilder(type_7787);
  ::Reflex::Type type_14148 = ::Reflex::ReferenceBuilder(type_7787c);
  ::Reflex::Type type_7857c = ::Reflex::ConstBuilder(type_7857);
  ::Reflex::Type type_40740 = ::Reflex::ReferenceBuilder(type_7857c);
  ::Reflex::Type type_3008c = ::Reflex::ConstBuilder(type_3008);
  ::Reflex::Type type_36090 = ::Reflex::ReferenceBuilder(type_3008c);
  ::Reflex::Type type_3007c = ::Reflex::ConstBuilder(type_3007);
  ::Reflex::Type type_36088 = ::Reflex::ReferenceBuilder(type_3007c);
  ::Reflex::Type type_9457 = ::Reflex::PointerBuilder(type_7787);
  ::Reflex::Type type_14144 = ::Reflex::PointerBuilder(type_7787c);
  ::Reflex::Type type_3300c = ::Reflex::ConstBuilder(type_3300);
  ::Reflex::Type type_34610 = ::Reflex::ReferenceBuilder(type_3300c);
  ::Reflex::Type type_2993c = ::Reflex::ConstBuilder(type_2993);
  ::Reflex::Type type_20846 = ::Reflex::ReferenceBuilder(type_2993c);
  ::Reflex::Type type_35982 = ::Reflex::ReferenceBuilder(type_2993);
  ::Reflex::Type type_9476 = ::Reflex::PointerBuilder(type_14203);
  ::Reflex::Type type_14203c = ::Reflex::ConstBuilder(type_14203);
  ::Reflex::Type type_14210 = ::Reflex::PointerBuilder(type_14203c);
  ::Reflex::Type type_14212 = ::Reflex::ReferenceBuilder(type_14203);
  ::Reflex::Type type_14214 = ::Reflex::ReferenceBuilder(type_14203c);
  ::Reflex::Type type_3301c = ::Reflex::ConstBuilder(type_3301);
  ::Reflex::Type type_34623 = ::Reflex::ReferenceBuilder(type_3301c);
  ::Reflex::Type type_2994c = ::Reflex::ConstBuilder(type_2994);
  ::Reflex::Type type_36007 = ::Reflex::ReferenceBuilder(type_2994c);
  ::Reflex::Type type_36008 = ::Reflex::ReferenceBuilder(type_2994);
  ::Reflex::Type type_9495 = ::Reflex::PointerBuilder(type_14269);
  ::Reflex::Type type_14269c = ::Reflex::ConstBuilder(type_14269);
  ::Reflex::Type type_14276 = ::Reflex::PointerBuilder(type_14269c);
  ::Reflex::Type type_14278 = ::Reflex::ReferenceBuilder(type_14269);
  ::Reflex::Type type_14280 = ::Reflex::ReferenceBuilder(type_14269c);
  ::Reflex::Type type_3302c = ::Reflex::ConstBuilder(type_3302);
  ::Reflex::Type type_34636 = ::Reflex::ReferenceBuilder(type_3302c);
  ::Reflex::Type type_2995c = ::Reflex::ConstBuilder(type_2995);
  ::Reflex::Type type_36040 = ::Reflex::ReferenceBuilder(type_2995c);
  ::Reflex::Type type_36041 = ::Reflex::ReferenceBuilder(type_2995);
  ::Reflex::Type type_9514 = ::Reflex::PointerBuilder(type_14335);
  ::Reflex::Type type_14335c = ::Reflex::ConstBuilder(type_14335);
  ::Reflex::Type type_14342 = ::Reflex::PointerBuilder(type_14335c);
  ::Reflex::Type type_14344 = ::Reflex::ReferenceBuilder(type_14335);
  ::Reflex::Type type_14346 = ::Reflex::ReferenceBuilder(type_14335c);
  ::Reflex::Type type_3303c = ::Reflex::ConstBuilder(type_3303);
  ::Reflex::Type type_34649 = ::Reflex::ReferenceBuilder(type_3303c);
  ::Reflex::Type type_2996c = ::Reflex::ConstBuilder(type_2996);
  ::Reflex::Type type_36059 = ::Reflex::ReferenceBuilder(type_2996c);
  ::Reflex::Type type_36060 = ::Reflex::ReferenceBuilder(type_2996);
  ::Reflex::Type type_14409 = ::Reflex::ReferenceBuilder(type_4990);
  ::Reflex::Type type_4990c = ::Reflex::ConstBuilder(type_4990);
  ::Reflex::Type type_14411 = ::Reflex::ReferenceBuilder(type_4990c);
  ::Reflex::Type type_4933c = ::Reflex::ConstBuilder(type_4933);
  ::Reflex::Type type_20599 = ::Reflex::ReferenceBuilder(type_4933c);
  ::Reflex::Type type_5017c = ::Reflex::ConstBuilder(type_5017);
  ::Reflex::Type type_20675 = ::Reflex::PointerBuilder(type_5017c);
  ::Reflex::Type type_7973c = ::Reflex::ConstBuilder(type_7973);
  ::Reflex::Type type_15959 = ::Reflex::PointerBuilder(type_7973c);
  ::Reflex::Type type_15963 = ::Reflex::ReferenceBuilder(type_7973c);
  ::Reflex::Type type_4935c = ::Reflex::ConstBuilder(type_4935);
  ::Reflex::Type type_23940 = ::Reflex::ReferenceBuilder(type_4935c);
  ::Reflex::Type type_694c = ::Reflex::ConstBuilder(type_694);
  ::Reflex::Type type_4071 = ::Reflex::PointerBuilder(type_694c);
  ::Reflex::Type type_9533 = ::Reflex::PointerBuilder(type_4990);
  ::Reflex::Type type_14407 = ::Reflex::PointerBuilder(type_4990c);
  ::Reflex::Type type_3304c = ::Reflex::ConstBuilder(type_3304);
  ::Reflex::Type type_34662 = ::Reflex::ReferenceBuilder(type_3304c);
  ::Reflex::Type type_2997c = ::Reflex::ConstBuilder(type_2997);
  ::Reflex::Type type_36062 = ::Reflex::ReferenceBuilder(type_2997c);
  ::Reflex::Type type_36063 = ::Reflex::ReferenceBuilder(type_2997);
  ::Reflex::Type type_14540 = ::Reflex::ReferenceBuilder(type_7846);
  ::Reflex::Type type_7846c = ::Reflex::ConstBuilder(type_7846);
  ::Reflex::Type type_14542 = ::Reflex::ReferenceBuilder(type_7846c);
  ::Reflex::Type type_9571 = ::Reflex::PointerBuilder(type_7846);
  ::Reflex::Type type_14538 = ::Reflex::PointerBuilder(type_7846c);
  ::Reflex::Type type_3306c = ::Reflex::ConstBuilder(type_3306);
  ::Reflex::Type type_34688 = ::Reflex::ReferenceBuilder(type_3306c);
  ::Reflex::Type type_2999c = ::Reflex::ConstBuilder(type_2999);
  ::Reflex::Type type_20858 = ::Reflex::ReferenceBuilder(type_2999c);
  ::Reflex::Type type_36069 = ::Reflex::ReferenceBuilder(type_2999);
  ::Reflex::Type type_14605 = ::Reflex::ReferenceBuilder(type_7841);
  ::Reflex::Type type_7841c = ::Reflex::ConstBuilder(type_7841);
  ::Reflex::Type type_14607 = ::Reflex::ReferenceBuilder(type_7841c);
  ::Reflex::Type type_9590 = ::Reflex::PointerBuilder(type_7841);
  ::Reflex::Type type_14603 = ::Reflex::PointerBuilder(type_7841c);
  ::Reflex::Type type_3307c = ::Reflex::ConstBuilder(type_3307);
  ::Reflex::Type type_34701 = ::Reflex::ReferenceBuilder(type_3307c);
  ::Reflex::Type type_3000c = ::Reflex::ConstBuilder(type_3000);
  ::Reflex::Type type_20870 = ::Reflex::ReferenceBuilder(type_3000c);
  ::Reflex::Type type_36071 = ::Reflex::ReferenceBuilder(type_3000);
  ::Reflex::Type type_4636c = ::Reflex::ConstBuilder(type_4636);
  ::Reflex::Type type_39234 = ::Reflex::ReferenceBuilder(type_4636c);
  ::Reflex::Type type_358c = ::Reflex::ConstBuilder(type_358);
  ::Reflex::Type type_4988c = ::Reflex::ConstBuilder(type_4988);
  ::Reflex::Type type_39235 = ::Reflex::ReferenceBuilder(type_4988c);
  ::Reflex::Type type_39236 = ::Reflex::ReferenceBuilder(type_4636);
  ::Reflex::Type type_20679 = ::Reflex::ReferenceBuilder(type_2970);
  ::Reflex::Type type_4637c = ::Reflex::ConstBuilder(type_4637);
  ::Reflex::Type type_39237 = ::Reflex::ReferenceBuilder(type_4637c);
  ::Reflex::Type type_4989c = ::Reflex::ConstBuilder(type_4989);
  ::Reflex::Type type_39238 = ::Reflex::ReferenceBuilder(type_4989c);
  ::Reflex::Type type_39239 = ::Reflex::ReferenceBuilder(type_4637);
  ::Reflex::Type type_4638c = ::Reflex::ConstBuilder(type_4638);
  ::Reflex::Type type_39240 = ::Reflex::ReferenceBuilder(type_4638c);
  ::Reflex::Type type_4991c = ::Reflex::ConstBuilder(type_4991);
  ::Reflex::Type type_39241 = ::Reflex::ReferenceBuilder(type_4991c);
  ::Reflex::Type type_39242 = ::Reflex::ReferenceBuilder(type_4638);
  ::Reflex::Type type_4639c = ::Reflex::ConstBuilder(type_4639);
  ::Reflex::Type type_39243 = ::Reflex::ReferenceBuilder(type_4639c);
  ::Reflex::Type type_4992c = ::Reflex::ConstBuilder(type_4992);
  ::Reflex::Type type_39244 = ::Reflex::ReferenceBuilder(type_4992c);
  ::Reflex::Type type_39245 = ::Reflex::ReferenceBuilder(type_4639);
  ::Reflex::Type type_4640c = ::Reflex::ConstBuilder(type_4640);
  ::Reflex::Type type_39246 = ::Reflex::ReferenceBuilder(type_4640c);
  ::Reflex::Type type_4993c = ::Reflex::ConstBuilder(type_4993);
  ::Reflex::Type type_39247 = ::Reflex::ReferenceBuilder(type_4993c);
  ::Reflex::Type type_39248 = ::Reflex::ReferenceBuilder(type_4640);
  ::Reflex::Type type_4641c = ::Reflex::ConstBuilder(type_4641);
  ::Reflex::Type type_39249 = ::Reflex::ReferenceBuilder(type_4641c);
  ::Reflex::Type type_4994c = ::Reflex::ConstBuilder(type_4994);
  ::Reflex::Type type_39250 = ::Reflex::ReferenceBuilder(type_4994c);
  ::Reflex::Type type_39251 = ::Reflex::ReferenceBuilder(type_4641);
  ::Reflex::Type type_4642c = ::Reflex::ConstBuilder(type_4642);
  ::Reflex::Type type_39252 = ::Reflex::ReferenceBuilder(type_4642c);
  ::Reflex::Type type_4995c = ::Reflex::ConstBuilder(type_4995);
  ::Reflex::Type type_39253 = ::Reflex::ReferenceBuilder(type_4995c);
  ::Reflex::Type type_39254 = ::Reflex::ReferenceBuilder(type_4642);
  ::Reflex::Type type_4644c = ::Reflex::ConstBuilder(type_4644);
  ::Reflex::Type type_39258 = ::Reflex::ReferenceBuilder(type_4644c);
  ::Reflex::Type type_4997c = ::Reflex::ConstBuilder(type_4997);
  ::Reflex::Type type_39259 = ::Reflex::ReferenceBuilder(type_4997c);
  ::Reflex::Type type_39260 = ::Reflex::ReferenceBuilder(type_4644);
  ::Reflex::Type type_4645c = ::Reflex::ConstBuilder(type_4645);
  ::Reflex::Type type_39261 = ::Reflex::ReferenceBuilder(type_4645c);
  ::Reflex::Type type_4998c = ::Reflex::ConstBuilder(type_4998);
  ::Reflex::Type type_39262 = ::Reflex::ReferenceBuilder(type_4998c);
  ::Reflex::Type type_39263 = ::Reflex::ReferenceBuilder(type_4645);
  ::Reflex::Type type_5022c = ::Reflex::ConstBuilder(type_5022);
  ::Reflex::Type type_4681c = ::Reflex::ConstBuilder(type_4681);
  ::Reflex::Type type_39289 = ::Reflex::ReferenceBuilder(type_4681c);
  ::Reflex::Type type_39290 = ::Reflex::ReferenceBuilder(type_5022c);
  ::Reflex::Type type_4039c = ::Reflex::ConstBuilder(type_4039);
  ::Reflex::Type type_20674 = ::Reflex::ReferenceBuilder(type_4039c);
  ::Reflex::Type type_39291 = ::Reflex::PointerBuilder(type_2993c);
  ::Reflex::Type type_4615c = ::Reflex::ConstBuilder(type_4615);
  ::Reflex::Type type_39292 = ::Reflex::ReferenceBuilder(type_4615c);
  ::Reflex::Type type_39293 = ::Reflex::ReferenceBuilder(type_4681);
  ::Reflex::Type type_4937 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::helper_vector"), type_4936);
  ::Reflex::Type type_20680 = ::Reflex::ReferenceBuilder(type_4937);
  ::Reflex::Type type_5025c = ::Reflex::ConstBuilder(type_5025);
  ::Reflex::Type type_4686c = ::Reflex::ConstBuilder(type_4686);
  ::Reflex::Type type_39295 = ::Reflex::ReferenceBuilder(type_4686c);
  ::Reflex::Type type_39296 = ::Reflex::ReferenceBuilder(type_5025c);
  ::Reflex::Type type_39297 = ::Reflex::PointerBuilder(type_2999c);
  ::Reflex::Type type_4616c = ::Reflex::ConstBuilder(type_4616);
  ::Reflex::Type type_39298 = ::Reflex::ReferenceBuilder(type_4616c);
  ::Reflex::Type type_39299 = ::Reflex::ReferenceBuilder(type_4686);
  ::Reflex::Type type_5026c = ::Reflex::ConstBuilder(type_5026);
  ::Reflex::Type type_4691c = ::Reflex::ConstBuilder(type_4691);
  ::Reflex::Type type_39301 = ::Reflex::ReferenceBuilder(type_4691c);
  ::Reflex::Type type_39302 = ::Reflex::ReferenceBuilder(type_5026c);
  ::Reflex::Type type_39303 = ::Reflex::PointerBuilder(type_3000c);
  ::Reflex::Type type_4617c = ::Reflex::ConstBuilder(type_4617);
  ::Reflex::Type type_39304 = ::Reflex::ReferenceBuilder(type_4617c);
  ::Reflex::Type type_39305 = ::Reflex::ReferenceBuilder(type_4691);
  ::Reflex::Type type_6766 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("math::XYZTLorentzVectorD"), type_6765);
  ::Reflex::Type type_6815 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("math::XYZTLorentzVector"), type_6766);
  ::Reflex::Type type_40916 = ::Reflex::ReferenceBuilder(type_7921);
  ::Reflex::Type type_7921c = ::Reflex::ConstBuilder(type_7921);
  ::Reflex::Type type_40917 = ::Reflex::ReferenceBuilder(type_7921c);
  ::Reflex::Type type_2989c = ::Reflex::ConstBuilder(type_2989);
  ::Reflex::Type type_35970 = ::Reflex::ReferenceBuilder(type_2989c);
  ::Reflex::Type type_2972c = ::Reflex::ConstBuilder(type_2972);
  ::Reflex::Type type_35943 = ::Reflex::ReferenceBuilder(type_2972c);
  ::Reflex::Type type_6815c = ::Reflex::ConstBuilder(type_6815);
  ::Reflex::Type type_26316 = ::Reflex::ReferenceBuilder(type_6815c);
  ::Reflex::Type type_3006c = ::Reflex::ConstBuilder(type_3006);
  ::Reflex::Type type_36086 = ::Reflex::ReferenceBuilder(type_3006c);
  ::Reflex::Type type_2991c = ::Reflex::ConstBuilder(type_2991);
  ::Reflex::Type type_35976 = ::Reflex::ReferenceBuilder(type_2991c);
  ::Reflex::Type type_39382 = ::Reflex::PointerBuilder(type_7921c);
  ::Reflex::Type type_499c = ::Reflex::ConstBuilder(type_499);
  ::Reflex::Type type_20732 = ::Reflex::ReferenceBuilder(type_499c);
  ::Reflex::Type type_39383 = ::Reflex::PointerBuilder(type_7921);
  ::Reflex::Type type_4871c = ::Reflex::ConstBuilder(type_4871);
  ::Reflex::Type type_39384 = ::Reflex::PointerBuilder(type_4871c);
  ::Reflex::Type type_38738 = ::Reflex::ReferenceBuilder(type_4439);
  ::Reflex::Type type_11036 = ::Reflex::ReferenceBuilder(type_4071);
  ::Reflex::Type type_2971c = ::Reflex::ConstBuilder(type_2971);
  ::Reflex::Type type_26144 = ::Reflex::ReferenceBuilder(type_2971c);
  ::Reflex::Type type_40763 = ::Reflex::ReferenceBuilder(type_7832);
  ::Reflex::Type type_7832c = ::Reflex::ConstBuilder(type_7832);
  ::Reflex::Type type_40764 = ::Reflex::ReferenceBuilder(type_7832c);
  ::Reflex::Type type_1566c = ::Reflex::ConstBuilder(type_1566);
  ::Reflex::Type type_39387 = ::Reflex::PointerBuilder(type_7832c);
  ::Reflex::Type type_39388 = ::Reflex::PointerBuilder(type_7832);
  ::Reflex::Type type_4872c = ::Reflex::ConstBuilder(type_4872);
  ::Reflex::Type type_39389 = ::Reflex::PointerBuilder(type_4872c);
  ::Reflex::Type type_40765 = ::Reflex::ReferenceBuilder(type_7833);
  ::Reflex::Type type_7833c = ::Reflex::ConstBuilder(type_7833);
  ::Reflex::Type type_40766 = ::Reflex::ReferenceBuilder(type_7833c);
  ::Reflex::Type type_39392 = ::Reflex::PointerBuilder(type_7833c);
  ::Reflex::Type type_39393 = ::Reflex::PointerBuilder(type_7833);
  ::Reflex::Type type_4873c = ::Reflex::ConstBuilder(type_4873);
  ::Reflex::Type type_39394 = ::Reflex::PointerBuilder(type_4873c);
  ::Reflex::Type type_39845 = ::Reflex::ReferenceBuilder(type_4956);
  ::Reflex::Type type_4956c = ::Reflex::ConstBuilder(type_4956);
  ::Reflex::Type type_39846 = ::Reflex::ReferenceBuilder(type_4956c);
  ::Reflex::Type type_5059c = ::Reflex::ConstBuilder(type_5059);
  ::Reflex::Type type_39847 = ::Reflex::ReferenceBuilder(type_5059c);
  ::Reflex::Type type_4912c = ::Reflex::ConstBuilder(type_4912);
  ::Reflex::Type type_39848 = ::Reflex::ReferenceBuilder(type_4912c);
  ::Reflex::Type type_4848c = ::Reflex::ConstBuilder(type_4848);
  ::Reflex::Type type_39849 = ::Reflex::ReferenceBuilder(type_4848c);
  ::Reflex::Type type_39397 = ::Reflex::PointerBuilder(type_4956c);
  ::Reflex::Type type_39398 = ::Reflex::PointerBuilder(type_4956);
  ::Reflex::Type type_4874c = ::Reflex::ConstBuilder(type_4874);
  ::Reflex::Type type_39399 = ::Reflex::PointerBuilder(type_4874c);
  ::Reflex::Type type_39402 = ::Reflex::PointerBuilder(type_4681c);
  ::Reflex::Type type_39403 = ::Reflex::PointerBuilder(type_4681);
  ::Reflex::Type type_4875c = ::Reflex::ConstBuilder(type_4875);
  ::Reflex::Type type_39404 = ::Reflex::PointerBuilder(type_4875c);
  ::Reflex::Type type_39930 = ::Reflex::ReferenceBuilder(type_5022);
  ::Reflex::Type type_10985 = ::Reflex::ReferenceBuilder(type_366c);
  ::Reflex::Type type_39407 = ::Reflex::PointerBuilder(type_5022c);
  ::Reflex::Type type_39408 = ::Reflex::PointerBuilder(type_5022);
  ::Reflex::Type type_4876c = ::Reflex::ConstBuilder(type_4876);
  ::Reflex::Type type_39409 = ::Reflex::PointerBuilder(type_4876c);
  ::Reflex::Type type_39412 = ::Reflex::PointerBuilder(type_2993);
  ::Reflex::Type type_4877c = ::Reflex::ConstBuilder(type_4877);
  ::Reflex::Type type_39413 = ::Reflex::PointerBuilder(type_4877c);
  ::Reflex::Type type_4878c = ::Reflex::ConstBuilder(type_4878);
  ::Reflex::Type type_39416 = ::Reflex::PointerBuilder(type_4878c);
  ::Reflex::Type type_5080c = ::Reflex::ConstBuilder(type_5080);
  ::Reflex::Type type_40018 = ::Reflex::ReferenceBuilder(type_5080c);
  ::Reflex::Type type_40019 = ::Reflex::ReferenceBuilder(type_5080);
  ::Reflex::Type type_2121 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("size_t"), type_358);
  ::Reflex::Type type_2974c = ::Reflex::ConstBuilder(type_2974);
  ::Reflex::Type type_35947 = ::Reflex::ReferenceBuilder(type_2974c);
  ::Reflex::Type type_39429 = ::Reflex::PointerBuilder(type_5080c);
  ::Reflex::Type type_39430 = ::Reflex::PointerBuilder(type_5080);
  ::Reflex::Type type_4881c = ::Reflex::ConstBuilder(type_4881);
  ::Reflex::Type type_39431 = ::Reflex::PointerBuilder(type_4881c);
  ::Reflex::Type type_39439 = ::Reflex::PointerBuilder(type_2999);
  ::Reflex::Type type_4883c = ::Reflex::ConstBuilder(type_4883);
  ::Reflex::Type type_39440 = ::Reflex::PointerBuilder(type_4883c);
  ::Reflex::Type type_5081c = ::Reflex::ConstBuilder(type_5081);
  ::Reflex::Type type_40020 = ::Reflex::ReferenceBuilder(type_5081c);
  ::Reflex::Type type_40021 = ::Reflex::ReferenceBuilder(type_5081);
  ::Reflex::Type type_39443 = ::Reflex::PointerBuilder(type_5081c);
  ::Reflex::Type type_39444 = ::Reflex::PointerBuilder(type_5081);
  ::Reflex::Type type_4884c = ::Reflex::ConstBuilder(type_4884);
  ::Reflex::Type type_39445 = ::Reflex::PointerBuilder(type_4884c);
  ::Reflex::Type type_39453 = ::Reflex::PointerBuilder(type_3000);
  ::Reflex::Type type_4886c = ::Reflex::ConstBuilder(type_4886);
  ::Reflex::Type type_39454 = ::Reflex::PointerBuilder(type_4886c);
  ::Reflex::Type type_39862 = ::Reflex::ReferenceBuilder(type_4959);
  ::Reflex::Type type_4959c = ::Reflex::ConstBuilder(type_4959);
  ::Reflex::Type type_39863 = ::Reflex::ReferenceBuilder(type_4959c);
  ::Reflex::Type type_5062c = ::Reflex::ConstBuilder(type_5062);
  ::Reflex::Type type_39864 = ::Reflex::ReferenceBuilder(type_5062c);
  ::Reflex::Type type_4915c = ::Reflex::ConstBuilder(type_4915);
  ::Reflex::Type type_39865 = ::Reflex::ReferenceBuilder(type_4915c);
  ::Reflex::Type type_4851c = ::Reflex::ConstBuilder(type_4851);
  ::Reflex::Type type_39866 = ::Reflex::ReferenceBuilder(type_4851c);
  ::Reflex::Type type_39867 = ::Reflex::ReferenceBuilder(type_4960);
  ::Reflex::Type type_4960c = ::Reflex::ConstBuilder(type_4960);
  ::Reflex::Type type_39868 = ::Reflex::ReferenceBuilder(type_4960c);
  ::Reflex::Type type_5063c = ::Reflex::ConstBuilder(type_5063);
  ::Reflex::Type type_39869 = ::Reflex::ReferenceBuilder(type_5063c);
  ::Reflex::Type type_4916c = ::Reflex::ConstBuilder(type_4916);
  ::Reflex::Type type_39870 = ::Reflex::ReferenceBuilder(type_4916c);
  ::Reflex::Type type_4852c = ::Reflex::ConstBuilder(type_4852);
  ::Reflex::Type type_39871 = ::Reflex::ReferenceBuilder(type_4852c);
  ::Reflex::Type type_39900 = ::Reflex::ReferenceBuilder(type_4988);
  ::Reflex::Type type_39901 = ::Reflex::ReferenceBuilder(type_4989);
  ::Reflex::Type type_39902 = ::Reflex::ReferenceBuilder(type_4991);
  ::Reflex::Type type_8007c = ::Reflex::ConstBuilder(type_8007);
  ::Reflex::Type type_15503 = ::Reflex::PointerBuilder(type_8007c);
  ::Reflex::Type type_15507 = ::Reflex::ReferenceBuilder(type_8007c);
  ::Reflex::Type type_39903 = ::Reflex::ReferenceBuilder(type_4992);
  ::Reflex::Type type_7854c = ::Reflex::ConstBuilder(type_7854);
  ::Reflex::Type type_16024 = ::Reflex::PointerBuilder(type_7854c);
  ::Reflex::Type type_16028 = ::Reflex::ReferenceBuilder(type_7854c);
  ::Reflex::Type type_39904 = ::Reflex::ReferenceBuilder(type_4993);
  ::Reflex::Type type_7893c = ::Reflex::ConstBuilder(type_7893);
  ::Reflex::Type type_16346 = ::Reflex::PointerBuilder(type_7893c);
  ::Reflex::Type type_16350 = ::Reflex::ReferenceBuilder(type_7893c);
  ::Reflex::Type type_39905 = ::Reflex::ReferenceBuilder(type_4994);
  ::Reflex::Type type_7994c = ::Reflex::ConstBuilder(type_7994);
  ::Reflex::Type type_16732 = ::Reflex::PointerBuilder(type_7994c);
  ::Reflex::Type type_16736 = ::Reflex::ReferenceBuilder(type_7994c);
  ::Reflex::Type type_39906 = ::Reflex::ReferenceBuilder(type_4995);
  ::Reflex::Type type_7794c = ::Reflex::ConstBuilder(type_7794);
  ::Reflex::Type type_16216 = ::Reflex::PointerBuilder(type_7794c);
  ::Reflex::Type type_16220 = ::Reflex::ReferenceBuilder(type_7794c);
  ::Reflex::Type type_39908 = ::Reflex::ReferenceBuilder(type_4997);
  ::Reflex::Type type_7818c = ::Reflex::ConstBuilder(type_7818);
  ::Reflex::Type type_16604 = ::Reflex::PointerBuilder(type_7818c);
  ::Reflex::Type type_16608 = ::Reflex::ReferenceBuilder(type_7818c);
  ::Reflex::Type type_39909 = ::Reflex::ReferenceBuilder(type_4998);
  ::Reflex::Type type_7843c = ::Reflex::ConstBuilder(type_7843);
  ::Reflex::Type type_14466 = ::Reflex::PointerBuilder(type_7843c);
  ::Reflex::Type type_24098 = ::Reflex::ReferenceBuilder(type_7843c);
  ::Reflex::Type type_39931 = ::Reflex::ReferenceBuilder(type_5025);
  ::Reflex::Type type_39932 = ::Reflex::ReferenceBuilder(type_5026);
  ::Reflex::Type type_13241 = ::Reflex::ReferenceBuilder(type_7813);
  ::Reflex::Type type_7813c = ::Reflex::ConstBuilder(type_7813);
  ::Reflex::Type type_13243 = ::Reflex::ReferenceBuilder(type_7813c);
  ::Reflex::Type type_9609 = ::Reflex::PointerBuilder(type_7813);
  ::Reflex::Type type_40762 = ::Reflex::ReferenceBuilder(type_7826);
  ::Reflex::Type type_40923 = ::Reflex::ReferenceBuilder(type_7938);
  ::Reflex::Type type_7938c = ::Reflex::ConstBuilder(type_7938);
  ::Reflex::Type type_40757 = ::Reflex::ReferenceBuilder(type_7938c);
  ::Reflex::Type type_6765c = ::Reflex::ConstBuilder(type_6765);
  ::Reflex::Type type_40177 = ::Reflex::ReferenceBuilder(type_6765c);
  ::Reflex::Type type_68c = ::Reflex::ConstBuilder(type_68);
  ::Reflex::Type type_40924 = ::Reflex::ReferenceBuilder(type_7939);
  ::Reflex::Type type_7939c = ::Reflex::ConstBuilder(type_7939);
  ::Reflex::Type type_40925 = ::Reflex::ReferenceBuilder(type_7939c);
  ::Reflex::Type type_13824 = ::Reflex::ReferenceBuilder(type_7811);
  ::Reflex::Type type_7811c = ::Reflex::ConstBuilder(type_7811);
  ::Reflex::Type type_13826 = ::Reflex::ReferenceBuilder(type_7811c);
  ::Reflex::Type type_9704 = ::Reflex::PointerBuilder(type_7811);
  ::Reflex::Type type_13759 = ::Reflex::ReferenceBuilder(type_4775);
  ::Reflex::Type type_4775c = ::Reflex::ConstBuilder(type_4775);
  ::Reflex::Type type_13761 = ::Reflex::ReferenceBuilder(type_4775c);
  ::Reflex::Type type_5021c = ::Reflex::ConstBuilder(type_5021);
  ::Reflex::Type type_38861 = ::Reflex::ReferenceBuilder(type_5021c);
  ::Reflex::Type type_13822 = ::Reflex::PointerBuilder(type_7811c);
  ::Reflex::Type type_2988c = ::Reflex::ConstBuilder(type_2988);
  ::Reflex::Type type_39285 = ::Reflex::PointerBuilder(type_2988c);
  ::Reflex::Type type_4676c = ::Reflex::ConstBuilder(type_4676);
  ::Reflex::Type type_39284 = ::Reflex::ReferenceBuilder(type_4676c);
  ::Reflex::Type type_4614c = ::Reflex::ConstBuilder(type_4614);
  ::Reflex::Type type_39286 = ::Reflex::ReferenceBuilder(type_4614c);
  ::Reflex::Type type_39287 = ::Reflex::ReferenceBuilder(type_4676);
  ::Reflex::Type type_13629 = ::Reflex::ReferenceBuilder(type_7851);
  ::Reflex::Type type_7851c = ::Reflex::ConstBuilder(type_7851);
  ::Reflex::Type type_13631 = ::Reflex::ReferenceBuilder(type_7851c);
  ::Reflex::Type type_9723 = ::Reflex::PointerBuilder(type_7851);
  ::Reflex::Type type_13564 = ::Reflex::ReferenceBuilder(type_4774);
  ::Reflex::Type type_4774c = ::Reflex::ConstBuilder(type_4774);
  ::Reflex::Type type_13566 = ::Reflex::ReferenceBuilder(type_4774c);
  ::Reflex::Type type_5019c = ::Reflex::ConstBuilder(type_5019);
  ::Reflex::Type type_38847 = ::Reflex::ReferenceBuilder(type_5019c);
  ::Reflex::Type type_13627 = ::Reflex::PointerBuilder(type_7851c);
  ::Reflex::Type type_2983c = ::Reflex::ConstBuilder(type_2983);
  ::Reflex::Type type_39280 = ::Reflex::PointerBuilder(type_2983c);
  ::Reflex::Type type_5018c = ::Reflex::ConstBuilder(type_5018);
  ::Reflex::Type type_4665c = ::Reflex::ConstBuilder(type_4665);
  ::Reflex::Type type_39271 = ::Reflex::ReferenceBuilder(type_4665c);
  ::Reflex::Type type_39272 = ::Reflex::ReferenceBuilder(type_5018c);
  ::Reflex::Type type_2973c = ::Reflex::ConstBuilder(type_2973);
  ::Reflex::Type type_39273 = ::Reflex::PointerBuilder(type_2973c);
  ::Reflex::Type type_4612c = ::Reflex::ConstBuilder(type_4612);
  ::Reflex::Type type_39274 = ::Reflex::ReferenceBuilder(type_4612c);
  ::Reflex::Type type_39275 = ::Reflex::ReferenceBuilder(type_4665);
  ::Reflex::Type type_13499 = ::Reflex::ReferenceBuilder(type_4655);
  ::Reflex::Type type_4655c = ::Reflex::ConstBuilder(type_4655);
  ::Reflex::Type type_13501 = ::Reflex::ReferenceBuilder(type_4655c);
  ::Reflex::Type type_4986c = ::Reflex::ConstBuilder(type_4986);
  ::Reflex::Type type_39229 = ::Reflex::ReferenceBuilder(type_4986c);
  ::Reflex::Type type_9343 = ::Reflex::PointerBuilder(type_4655);
  ::Reflex::Type type_13497 = ::Reflex::PointerBuilder(type_4655c);
  ::Reflex::Type type_3284c = ::Reflex::ConstBuilder(type_3284);
  ::Reflex::Type type_34532 = ::Reflex::ReferenceBuilder(type_3284c);
  ::Reflex::Type type_2981c = ::Reflex::ConstBuilder(type_2981);
  ::Reflex::Type type_35955 = ::Reflex::ReferenceBuilder(type_2981c);
  ::Reflex::Type type_35956 = ::Reflex::ReferenceBuilder(type_2981);
  ::Reflex::Type type_3286c = ::Reflex::ConstBuilder(type_3286);
  ::Reflex::Type type_34792 = ::Reflex::ReferenceBuilder(type_3286c);
  ::Reflex::Type type_20822 = ::Reflex::ReferenceBuilder(type_2983c);
  ::Reflex::Type type_35961 = ::Reflex::ReferenceBuilder(type_2983);
  ::Reflex::Type type_13694 = ::Reflex::ReferenceBuilder(type_4656);
  ::Reflex::Type type_4656c = ::Reflex::ConstBuilder(type_4656);
  ::Reflex::Type type_13696 = ::Reflex::ReferenceBuilder(type_4656c);
  ::Reflex::Type type_4987c = ::Reflex::ConstBuilder(type_4987);
  ::Reflex::Type type_39232 = ::Reflex::ReferenceBuilder(type_4987c);
  ::Reflex::Type type_9381 = ::Reflex::PointerBuilder(type_4656);
  ::Reflex::Type type_13692 = ::Reflex::PointerBuilder(type_4656c);
  ::Reflex::Type type_3293c = ::Reflex::ConstBuilder(type_3293);
  ::Reflex::Type type_34558 = ::Reflex::ReferenceBuilder(type_3293c);
  ::Reflex::Type type_2986c = ::Reflex::ConstBuilder(type_2986);
  ::Reflex::Type type_35963 = ::Reflex::ReferenceBuilder(type_2986c);
  ::Reflex::Type type_35964 = ::Reflex::ReferenceBuilder(type_2986);
  ::Reflex::Type type_39929 = ::Reflex::ReferenceBuilder(type_5021);
  ::Reflex::Type type_5058c = ::Reflex::ConstBuilder(type_5058);
  ::Reflex::Type type_39842 = ::Reflex::ReferenceBuilder(type_5058c);
  ::Reflex::Type type_4911c = ::Reflex::ConstBuilder(type_4911);
  ::Reflex::Type type_39843 = ::Reflex::ReferenceBuilder(type_4911c);
  ::Reflex::Type type_4847c = ::Reflex::ConstBuilder(type_4847);
  ::Reflex::Type type_39844 = ::Reflex::ReferenceBuilder(type_4847c);
  ::Reflex::Type type_4955c = ::Reflex::ConstBuilder(type_4955);
  ::Reflex::Type type_39841 = ::Reflex::ReferenceBuilder(type_4955c);
  ::Reflex::Type type_9362 = ::Reflex::PointerBuilder(type_4774);
  ::Reflex::Type type_13562 = ::Reflex::PointerBuilder(type_4774c);
  ::Reflex::Type type_3285c = ::Reflex::ConstBuilder(type_3285);
  ::Reflex::Type type_34545 = ::Reflex::ReferenceBuilder(type_3285c);
  ::Reflex::Type type_2982c = ::Reflex::ConstBuilder(type_2982);
  ::Reflex::Type type_35958 = ::Reflex::ReferenceBuilder(type_2982c);
  ::Reflex::Type type_35959 = ::Reflex::ReferenceBuilder(type_2982);
  ::Reflex::Type type_3295c = ::Reflex::ConstBuilder(type_3295);
  ::Reflex::Type type_34779 = ::Reflex::ReferenceBuilder(type_3295c);
  ::Reflex::Type type_20834 = ::Reflex::ReferenceBuilder(type_2988c);
  ::Reflex::Type type_35969 = ::Reflex::ReferenceBuilder(type_2988);
  ::Reflex::Type type_39840 = ::Reflex::ReferenceBuilder(type_4955);
  ::Reflex::Type type_13239 = ::Reflex::PointerBuilder(type_7813c);
  ::Reflex::Type type_3272c = ::Reflex::ConstBuilder(type_3272);
  ::Reflex::Type type_34714 = ::Reflex::ReferenceBuilder(type_3272c);
  ::Reflex::Type type_20810 = ::Reflex::ReferenceBuilder(type_2973c);
  ::Reflex::Type type_35946 = ::Reflex::ReferenceBuilder(type_2973);
  ::Reflex::Type type_39825 = ::Reflex::ReferenceBuilder(type_4952);
  ::Reflex::Type type_4952c = ::Reflex::ConstBuilder(type_4952);
  ::Reflex::Type type_39826 = ::Reflex::ReferenceBuilder(type_4952c);
  ::Reflex::Type type_5055c = ::Reflex::ConstBuilder(type_5055);
  ::Reflex::Type type_39827 = ::Reflex::ReferenceBuilder(type_5055c);
  ::Reflex::Type type_4908c = ::Reflex::ConstBuilder(type_4908);
  ::Reflex::Type type_39828 = ::Reflex::ReferenceBuilder(type_4908c);
  ::Reflex::Type type_4844c = ::Reflex::ConstBuilder(type_4844);
  ::Reflex::Type type_39829 = ::Reflex::ReferenceBuilder(type_4844c);
  ::Reflex::Type type_39830 = ::Reflex::ReferenceBuilder(type_4953);
  ::Reflex::Type type_4953c = ::Reflex::ConstBuilder(type_4953);
  ::Reflex::Type type_39831 = ::Reflex::ReferenceBuilder(type_4953c);
  ::Reflex::Type type_5056c = ::Reflex::ConstBuilder(type_5056);
  ::Reflex::Type type_39832 = ::Reflex::ReferenceBuilder(type_5056c);
  ::Reflex::Type type_4909c = ::Reflex::ConstBuilder(type_4909);
  ::Reflex::Type type_39833 = ::Reflex::ReferenceBuilder(type_4909c);
  ::Reflex::Type type_4845c = ::Reflex::ConstBuilder(type_4845);
  ::Reflex::Type type_39834 = ::Reflex::ReferenceBuilder(type_4845c);
  ::Reflex::Type type_4671c = ::Reflex::ConstBuilder(type_4671);
  ::Reflex::Type type_39279 = ::Reflex::ReferenceBuilder(type_4671c);
  ::Reflex::Type type_4613c = ::Reflex::ConstBuilder(type_4613);
  ::Reflex::Type type_39281 = ::Reflex::ReferenceBuilder(type_4613c);
  ::Reflex::Type type_39282 = ::Reflex::ReferenceBuilder(type_4671);
  ::Reflex::Type type_9400 = ::Reflex::PointerBuilder(type_4775);
  ::Reflex::Type type_13757 = ::Reflex::PointerBuilder(type_4775c);
  ::Reflex::Type type_3294c = ::Reflex::ConstBuilder(type_3294);
  ::Reflex::Type type_34571 = ::Reflex::ReferenceBuilder(type_3294c);
  ::Reflex::Type type_2987c = ::Reflex::ConstBuilder(type_2987);
  ::Reflex::Type type_35966 = ::Reflex::ReferenceBuilder(type_2987c);
  ::Reflex::Type type_35967 = ::Reflex::ReferenceBuilder(type_2987);
  ::Reflex::Type type_39927 = ::Reflex::ReferenceBuilder(type_5018);
  ::Reflex::Type type_39928 = ::Reflex::ReferenceBuilder(type_5019);
  ::Reflex::Type type_4634c = ::Reflex::ConstBuilder(type_4634);
  ::Reflex::Type type_39228 = ::Reflex::ReferenceBuilder(type_4634c);
  ::Reflex::Type type_39230 = ::Reflex::ReferenceBuilder(type_4634);
  ::Reflex::Type type_4635c = ::Reflex::ConstBuilder(type_4635);
  ::Reflex::Type type_39231 = ::Reflex::ReferenceBuilder(type_4635c);
  ::Reflex::Type type_39233 = ::Reflex::ReferenceBuilder(type_4635);
  ::Reflex::Type type_39330 = ::Reflex::PointerBuilder(type_2973);
  ::Reflex::Type type_4860c = ::Reflex::ConstBuilder(type_4860);
  ::Reflex::Type type_39331 = ::Reflex::PointerBuilder(type_4860c);
  ::Reflex::Type type_5012c = ::Reflex::ConstBuilder(type_5012);
  ::Reflex::Type type_39918 = ::Reflex::ReferenceBuilder(type_5012c);
  ::Reflex::Type type_39919 = ::Reflex::ReferenceBuilder(type_5012);
  ::Reflex::Type type_39334 = ::Reflex::PointerBuilder(type_5012c);
  ::Reflex::Type type_39335 = ::Reflex::PointerBuilder(type_5012);
  ::Reflex::Type type_4861c = ::Reflex::ConstBuilder(type_4861);
  ::Reflex::Type type_39336 = ::Reflex::PointerBuilder(type_4861c);
  ::Reflex::Type type_39339 = ::Reflex::PointerBuilder(type_2981c);
  ::Reflex::Type type_39340 = ::Reflex::PointerBuilder(type_2981);
  ::Reflex::Type type_4862c = ::Reflex::ConstBuilder(type_4862);
  ::Reflex::Type type_39341 = ::Reflex::PointerBuilder(type_4862c);
  ::Reflex::Type type_39344 = ::Reflex::PointerBuilder(type_2982c);
  ::Reflex::Type type_39345 = ::Reflex::PointerBuilder(type_2982);
  ::Reflex::Type type_4863c = ::Reflex::ConstBuilder(type_4863);
  ::Reflex::Type type_39346 = ::Reflex::PointerBuilder(type_4863c);
  ::Reflex::Type type_39349 = ::Reflex::PointerBuilder(type_4671c);
  ::Reflex::Type type_39350 = ::Reflex::PointerBuilder(type_4671);
  ::Reflex::Type type_4864c = ::Reflex::ConstBuilder(type_4864);
  ::Reflex::Type type_39351 = ::Reflex::PointerBuilder(type_4864c);
  ::Reflex::Type type_39354 = ::Reflex::PointerBuilder(type_2983);
  ::Reflex::Type type_4865c = ::Reflex::ConstBuilder(type_4865);
  ::Reflex::Type type_39355 = ::Reflex::PointerBuilder(type_4865c);
  ::Reflex::Type type_5013c = ::Reflex::ConstBuilder(type_5013);
  ::Reflex::Type type_39920 = ::Reflex::ReferenceBuilder(type_5013c);
  ::Reflex::Type type_39921 = ::Reflex::ReferenceBuilder(type_5013);
  ::Reflex::Type type_39358 = ::Reflex::PointerBuilder(type_5013c);
  ::Reflex::Type type_39359 = ::Reflex::PointerBuilder(type_5013);
  ::Reflex::Type type_4866c = ::Reflex::ConstBuilder(type_4866);
  ::Reflex::Type type_39360 = ::Reflex::PointerBuilder(type_4866c);
  ::Reflex::Type type_39363 = ::Reflex::PointerBuilder(type_2986c);
  ::Reflex::Type type_39364 = ::Reflex::PointerBuilder(type_2986);
  ::Reflex::Type type_4867c = ::Reflex::ConstBuilder(type_4867);
  ::Reflex::Type type_39365 = ::Reflex::PointerBuilder(type_4867c);
  ::Reflex::Type type_39368 = ::Reflex::PointerBuilder(type_2987c);
  ::Reflex::Type type_39369 = ::Reflex::PointerBuilder(type_2987);
  ::Reflex::Type type_4868c = ::Reflex::ConstBuilder(type_4868);
  ::Reflex::Type type_39370 = ::Reflex::PointerBuilder(type_4868c);
  ::Reflex::Type type_39373 = ::Reflex::PointerBuilder(type_4676c);
  ::Reflex::Type type_39374 = ::Reflex::PointerBuilder(type_4676);
  ::Reflex::Type type_4869c = ::Reflex::ConstBuilder(type_4869);
  ::Reflex::Type type_39375 = ::Reflex::PointerBuilder(type_4869c);
  ::Reflex::Type type_39378 = ::Reflex::PointerBuilder(type_2988);
  ::Reflex::Type type_4870c = ::Reflex::ConstBuilder(type_4870);
  ::Reflex::Type type_39379 = ::Reflex::PointerBuilder(type_4870c);
  ::Reflex::Type type_5014c = ::Reflex::ConstBuilder(type_5014);
  ::Reflex::Type type_39922 = ::Reflex::ReferenceBuilder(type_5014c);
  ::Reflex::Type type_39923 = ::Reflex::ReferenceBuilder(type_5014);
  ::Reflex::Type type_4957c = ::Reflex::ConstBuilder(type_4957);
  ::Reflex::Type type_39851 = ::Reflex::ReferenceBuilder(type_4957c);
  ::Reflex::Type type_39419 = ::Reflex::PointerBuilder(type_5014c);
  ::Reflex::Type type_39420 = ::Reflex::PointerBuilder(type_5014);
  ::Reflex::Type type_4879c = ::Reflex::ConstBuilder(type_4879);
  ::Reflex::Type type_39421 = ::Reflex::PointerBuilder(type_4879c);
  ::Reflex::Type type_5015c = ::Reflex::ConstBuilder(type_5015);
  ::Reflex::Type type_39924 = ::Reflex::ReferenceBuilder(type_5015c);
  ::Reflex::Type type_39925 = ::Reflex::ReferenceBuilder(type_5015);
  ::Reflex::Type type_4958c = ::Reflex::ConstBuilder(type_4958);
  ::Reflex::Type type_39857 = ::Reflex::ReferenceBuilder(type_4958c);
  ::Reflex::Type type_39424 = ::Reflex::PointerBuilder(type_5015c);
  ::Reflex::Type type_39425 = ::Reflex::PointerBuilder(type_5015);
  ::Reflex::Type type_4880c = ::Reflex::ConstBuilder(type_4880);
  ::Reflex::Type type_39426 = ::Reflex::PointerBuilder(type_4880c);
  ::Reflex::Type type_39898 = ::Reflex::ReferenceBuilder(type_4986);
  ::Reflex::Type type_39899 = ::Reflex::ReferenceBuilder(type_4987);
  ::Reflex::Type type_40886 = ::Reflex::ReferenceBuilder(type_7875);
  ::Reflex::Type type_7875c = ::Reflex::ConstBuilder(type_7875);
  ::Reflex::Type type_40887 = ::Reflex::ReferenceBuilder(type_7875c);
  ::Reflex::Type type_5020c = ::Reflex::ConstBuilder(type_5020);
  ::Reflex::Type type_13371 = ::Reflex::ReferenceBuilder(type_5020c);
  ::Reflex::Type type_40888 = ::Reflex::ReferenceBuilder(type_7876);
  ::Reflex::Type type_7876c = ::Reflex::ConstBuilder(type_7876);
  ::Reflex::Type type_40889 = ::Reflex::ReferenceBuilder(type_7876c);
  ::Reflex::Type type_44560 = ::Reflex::ReferenceBuilder(type_23851);
  ::Reflex::Type type_23851c = ::Reflex::ConstBuilder(type_23851);
  ::Reflex::Type type_44561 = ::Reflex::ReferenceBuilder(type_23851c);
  ::Reflex::Type type_21903 = ::Reflex::PointerBuilder(type_12435);
  ::Reflex::Type type_12435c = ::Reflex::ConstBuilder(type_12435);
  ::Reflex::Type type_42120 = ::Reflex::ReferenceBuilder(type_12435c);
  ::Reflex::Type type_21905 = ::Reflex::ReferenceBuilder(type_12435);
  ::Reflex::Type type_11079 = ::Reflex::ReferenceBuilder(type_2563);
  ::Reflex::Type type_44562 = ::Reflex::ReferenceBuilder(type_23852);
  ::Reflex::Type type_23852c = ::Reflex::ConstBuilder(type_23852);
  ::Reflex::Type type_44563 = ::Reflex::ReferenceBuilder(type_23852c);
  ::Reflex::Type type_44564 = ::Reflex::ReferenceBuilder(type_23853);
  ::Reflex::Type type_23853c = ::Reflex::ConstBuilder(type_23853);
  ::Reflex::Type type_44565 = ::Reflex::ReferenceBuilder(type_23853c);
  ::Reflex::Type type_23860c = ::Reflex::ConstBuilder(type_23860);
  ::Reflex::Type type_44573 = ::Reflex::ReferenceBuilder(type_23860c);
  ::Reflex::Type type_44574 = ::Reflex::ReferenceBuilder(type_23860);
  ::Reflex::Type type_44553 = ::Reflex::PointerBuilder(type_23846);
  ::Reflex::Type type_8005c = ::Reflex::ConstBuilder(type_8005);
  ::Reflex::Type type_14733 = ::Reflex::PointerBuilder(type_8005c);
  ::Reflex::Type type_23846c = ::Reflex::ConstBuilder(type_23846);
  ::Reflex::Type type_44555 = ::Reflex::ReferenceBuilder(type_23846c);
  ::Reflex::Type type_23861c = ::Reflex::ConstBuilder(type_23861);
  ::Reflex::Type type_44575 = ::Reflex::ReferenceBuilder(type_23861c);
  ::Reflex::Type type_44576 = ::Reflex::ReferenceBuilder(type_23861);
  ::Reflex::Type type_39872 = ::Reflex::PointerBuilder(type_23847);
  ::Reflex::Type type_23847c = ::Reflex::ConstBuilder(type_23847);
  ::Reflex::Type type_44557 = ::Reflex::ReferenceBuilder(type_23847c);
  ::Reflex::Type type_23862c = ::Reflex::ConstBuilder(type_23862);
  ::Reflex::Type type_44577 = ::Reflex::ReferenceBuilder(type_23862c);
  ::Reflex::Type type_44578 = ::Reflex::ReferenceBuilder(type_23862);
  ::Reflex::Type type_39874 = ::Reflex::PointerBuilder(type_23848);
  ::Reflex::Type type_6144c = ::Reflex::ConstBuilder(type_6144);
  ::Reflex::Type type_39879 = ::Reflex::PointerBuilder(type_6144c);
  ::Reflex::Type type_23848c = ::Reflex::ConstBuilder(type_23848);
  ::Reflex::Type type_44559 = ::Reflex::ReferenceBuilder(type_23848c);
  ::Reflex::Type type_23863c = ::Reflex::ConstBuilder(type_23863);
  ::Reflex::Type type_44579 = ::Reflex::ReferenceBuilder(type_23863c);
  ::Reflex::Type type_44580 = ::Reflex::ReferenceBuilder(type_23863);
  ::Reflex::Type type_23864c = ::Reflex::ConstBuilder(type_23864);
  ::Reflex::Type type_44581 = ::Reflex::ReferenceBuilder(type_23864c);
  ::Reflex::Type type_44582 = ::Reflex::ReferenceBuilder(type_23864);
  ::Reflex::Type type_4634f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::PtrVector<reco::FFTCaloJet>"), type_4634);
  ::Reflex::Type type_4635f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::PtrVector<reco::FFTGenJet>"), type_4635);
  ::Reflex::Type type_4739f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<reco::CATopJetTagInfoCollection>"), type_4739);
  ::Reflex::Type type_4740f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<edm::Association<reco::FFTCaloJetCollection> >"), type_4740);
  ::Reflex::Type type_4741f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<reco::FFTCaloJetFwdPtrVector>"), type_4741);
  ::Reflex::Type type_4742f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<reco::FFTCaloJetFwdRefVector>"), type_4742);
  ::Reflex::Type type_4743f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<reco::FFTCaloJetRefVector>"), type_4743);
  ::Reflex::Type type_4744f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<reco::FFTCaloJetCollection>"), type_4744);
  ::Reflex::Type type_4745f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<edm::Association<reco::FFTGenJetCollection> >"), type_4745);
  ::Reflex::Type type_4746f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<reco::FFTGenJetFwdPtrVector>"), type_4746);
  ::Reflex::Type type_4747f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<reco::FFTGenJetFwdRefVector>"), type_4747);
  ::Reflex::Type type_4748f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<reco::FFTGenJetRefVector>"), type_4748);
  ::Reflex::Type type_4749f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<reco::FFTGenJetCollection>"), type_4749);
  ::Reflex::Type type_4758f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<edm::Association<reco::PFJetCollection> >"), type_4758);
  ::Reflex::Type type_4759f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<edm::Association<reco::GenJetCollection> >"), type_4759);
  ::Reflex::Type type_4986f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Ptr<reco::FFTCaloJet>"), type_4986);
  ::Reflex::Type type_4987f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Ptr<reco::FFTGenJet>"), type_4987);
  ::Reflex::Type type_5012f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Association<reco::FFTCaloJetCollection>"), type_5012);
  ::Reflex::Type type_5013f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Association<reco::FFTGenJetCollection>"), type_5013);
  ::Reflex::Type type_5014f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Association<reco::PFJetCollection>"), type_5014);
  ::Reflex::Type type_5015f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Association<reco::GenJetCollection>"), type_5015);
  ::Reflex::Type type_7875f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::JetTrackMatch<reco::FFTCaloJetCollection>"), type_7875);
  ::Reflex::Type type_7876f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::JetTrackMatch<reco::FFTGenJetCollection>"), type_7876);
  ::Reflex::Type type_23851f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::reftobase::RefHolder<reco::CATopJetTagInfoRef>"), type_23851);
  ::Reflex::Type type_23852f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::reftobase::RefHolder<reco::FFTCaloJetRef>"), type_23852);
  ::Reflex::Type type_23853f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::reftobase::RefHolder<reco::FFTGenJetRef>"), type_23853);
  ::Reflex::Type type_23860f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::reftobase::Holder<reco::BaseTagInfo, reco::CATopJetTagInfoRef>"), type_23860);
  ::Reflex::Type type_23861f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::reftobase::Holder<reco::Jet, reco::FFTCaloJetRef>"), type_23861);
  ::Reflex::Type type_23862f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::reftobase::Holder<reco::Candidate, reco::FFTCaloJetRef>"), type_23862);
  ::Reflex::Type type_23863f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::reftobase::Holder<reco::Jet, reco::FFTGenJetRef>"), type_23863);
  ::Reflex::Type type_23864f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::reftobase::Holder<reco::Candidate, reco::FFTGenJetRef>"), type_23864);
} // unnamed namespace

#ifndef __CINT__

// Shadow classes to obtain the data member offsets 
namespace __shadow__ {
#ifdef __std__pair_edm__RefToBase_reco__Jet__reco__CATopJetProperties_
#undef __std__pair_edm__RefToBase_reco__Jet__reco__CATopJetProperties_
#endif
struct __std__pair_edm__RefToBase_reco__Jet__reco__CATopJetProperties_ {
  public:
  __std__pair_edm__RefToBase_reco__Jet__reco__CATopJetProperties_();
  ::edm::RefToBase<reco::Jet> first;
  ::reco::CATopJetProperties second;
};
#ifdef __reco__PattRecoPeak_double_
#undef __reco__PattRecoPeak_double_
#endif
class __reco__PattRecoPeak_double_ {
  public:
  __reco__PattRecoPeak_double_();
  double eta_;
  double phi_;
  double magnitude_;
  double speed_;
  double magSpeed_;
  double lifetime_;
  double scale_;
  double nearestD_;
  double clusterRadius_;
  double clusterSeparation_;
  double hessian_[3];
  double splitTime_;
  double mergeTime_;
};
#ifdef __reco__PattRecoNode_reco__PattRecoPeak_double_s_
#undef __reco__PattRecoNode_reco__PattRecoPeak_double_s_
#endif
class __reco__PattRecoNode_reco__PattRecoPeak_double_s_ {
  public:
  __reco__PattRecoNode_reco__PattRecoPeak_double_s_();
  ::reco::PattRecoPeak<double> jet_;
  unsigned int originalLevel_;
  unsigned int nodeMask_;
  unsigned int parent_;
};
#ifdef __std__vector_reco__PattRecoNode_reco__PattRecoPeak_double_s_s_
#undef __std__vector_reco__PattRecoNode_reco__PattRecoPeak_double_s_s_
#endif
class __std__vector_reco__PattRecoNode_reco__PattRecoPeak_double_s_s_ : protected ::std::_Vector_base<reco::PattRecoNode<reco::PattRecoPeak<double> >,std::allocator<reco::PattRecoNode<reco::PattRecoPeak<double> > > > {
  public:
  __std__vector_reco__PattRecoNode_reco__PattRecoPeak_double_s_s_();
};
#ifdef __reco__PattRecoPeak_float_
#undef __reco__PattRecoPeak_float_
#endif
class __reco__PattRecoPeak_float_ {
  public:
  __reco__PattRecoPeak_float_();
  float eta_;
  float phi_;
  float magnitude_;
  float speed_;
  float magSpeed_;
  float lifetime_;
  float scale_;
  float nearestD_;
  float clusterRadius_;
  float clusterSeparation_;
  float hessian_[3];
  float splitTime_;
  float mergeTime_;
};
#ifdef __reco__PattRecoNode_reco__PattRecoPeak_float_s_
#undef __reco__PattRecoNode_reco__PattRecoPeak_float_s_
#endif
class __reco__PattRecoNode_reco__PattRecoPeak_float_s_ {
  public:
  __reco__PattRecoNode_reco__PattRecoPeak_float_s_();
  ::reco::PattRecoPeak<float> jet_;
  unsigned int originalLevel_;
  unsigned int nodeMask_;
  unsigned int parent_;
};
#ifdef __std__vector_reco__PattRecoNode_reco__PattRecoPeak_float_s_s_
#undef __std__vector_reco__PattRecoNode_reco__PattRecoPeak_float_s_s_
#endif
class __std__vector_reco__PattRecoNode_reco__PattRecoPeak_float_s_s_ : protected ::std::_Vector_base<reco::PattRecoNode<reco::PattRecoPeak<float> >,std::allocator<reco::PattRecoNode<reco::PattRecoPeak<float> > > > {
  public:
  __std__vector_reco__PattRecoNode_reco__PattRecoPeak_float_s_s_();
};
#ifdef __reco__TrackExtrapolation
#undef __reco__TrackExtrapolation
#endif
class __reco__TrackExtrapolation {
  public:
  __reco__TrackExtrapolation();
  ::reco::TrackRef track_;
  ::std::vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > pos_;
  ::std::vector<ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > mom_;
};
#ifdef __std__vector_reco__TrackExtrapolation_
#undef __std__vector_reco__TrackExtrapolation_
#endif
class __std__vector_reco__TrackExtrapolation_ : protected ::std::_Vector_base<reco::TrackExtrapolation,std::allocator<reco::TrackExtrapolation> > {
  public:
  __std__vector_reco__TrackExtrapolation_();
};
#ifdef __std__vector_reco__PFJet__Specific_
#undef __std__vector_reco__PFJet__Specific_
#endif
class __std__vector_reco__PFJet__Specific_ : protected ::std::_Vector_base<reco::PFJet::Specific,std::allocator<reco::PFJet::Specific> > {
  public:
  __std__vector_reco__PFJet__Specific_();
};
#ifdef __std__vector_reco__JPTJet__Specific_
#undef __std__vector_reco__JPTJet__Specific_
#endif
class __std__vector_reco__JPTJet__Specific_ : protected ::std::_Vector_base<reco::JPTJet::Specific,std::allocator<reco::JPTJet::Specific> > {
  public:
  __std__vector_reco__JPTJet__Specific_();
};
#ifdef __std__vector_reco__CaloJet__Specific_
#undef __std__vector_reco__CaloJet__Specific_
#endif
class __std__vector_reco__CaloJet__Specific_ : protected ::std::_Vector_base<reco::CaloJet::Specific,std::allocator<reco::CaloJet::Specific> > {
  public:
  __std__vector_reco__CaloJet__Specific_();
};
#ifdef __edm__Ptr_reco__PFCluster_
#undef __edm__Ptr_reco__PFCluster_
#endif
class __edm__Ptr_reco__PFCluster_ {
  public:
  __edm__Ptr_reco__PFCluster_();
  ::edm::RefCore core_;
  unsigned long key_;
};
#ifdef __std__vector_edm__Ptr_reco__PFCluster_s_
#undef __std__vector_edm__Ptr_reco__PFCluster_s_
#endif
class __std__vector_edm__Ptr_reco__PFCluster_s_ : protected ::std::_Vector_base<edm::Ptr<reco::PFCluster>,std::allocator<edm::Ptr<reco::PFCluster> > > {
  public:
  __std__vector_edm__Ptr_reco__PFCluster_s_();
};
#ifdef __reco__CastorJetID
#undef __reco__CastorJetID
#endif
struct __reco__CastorJetID {
  public:
  __reco__CastorJetID();
  double emEnergy;
  double hadEnergy;
  double fem;
  double width;
  double depth;
  double fhot;
  double sigmaz;
  int nTowers;
};
#ifdef __std__vector_reco__CastorJetID_
#undef __std__vector_reco__CastorJetID_
#endif
class __std__vector_reco__CastorJetID_ : protected ::std::_Vector_base<reco::CastorJetID,std::allocator<reco::CastorJetID> > {
  public:
  __std__vector_reco__CastorJetID_();
};
#ifdef __reco__JetID
#undef __reco__JetID
#endif
struct __reco__JetID {
  public:
  __reco__JetID();
  float fHPD;
  float fRBX;
  short n90Hits;
  float fSubDetector1;
  float fSubDetector2;
  float fSubDetector3;
  float fSubDetector4;
  float restrictedEMF;
  short nHCALTowers;
  short nECALTowers;
  float approximatefHPD;
  float approximatefRBX;
  short hitsInN90;
  short numberOfHits2RPC;
  short numberOfHits3RPC;
  short numberOfHitsRPC;
  float fEB;
  float fEE;
  float fHB;
  float fHE;
  float fHO;
  float fLong;
  float fShort;
  float fLS;
  float fHFOOT;
};
#ifdef __std__vector_reco__JetID_
#undef __std__vector_reco__JetID_
#endif
class __std__vector_reco__JetID_ : protected ::std::_Vector_base<reco::JetID,std::allocator<reco::JetID> > {
  public:
  __std__vector_reco__JetID_();
};
#ifdef __edm__PtrVector_reco__CastorJetID_
#undef __edm__PtrVector_reco__CastorJetID_
#endif
class __edm__PtrVector_reco__CastorJetID_ : public ::edm::PtrVectorBase {
  public:
  __edm__PtrVector_reco__CastorJetID_();
  virtual ~__edm__PtrVector_reco__CastorJetID_() throw();
};
#ifdef __edm__PtrVector_reco__JetID_
#undef __edm__PtrVector_reco__JetID_
#endif
class __edm__PtrVector_reco__JetID_ : public ::edm::PtrVectorBase {
  public:
  __edm__PtrVector_reco__JetID_();
  virtual ~__edm__PtrVector_reco__JetID_() throw();
};
#ifdef __edm__PtrVector_reco__PFClusterJet_
#undef __edm__PtrVector_reco__PFClusterJet_
#endif
class __edm__PtrVector_reco__PFClusterJet_ : public ::edm::PtrVectorBase {
  public:
  __edm__PtrVector_reco__PFClusterJet_();
  virtual ~__edm__PtrVector_reco__PFClusterJet_() throw();
};
#ifdef __edm__PtrVector_reco__TrackJet_
#undef __edm__PtrVector_reco__TrackJet_
#endif
class __edm__PtrVector_reco__TrackJet_ : public ::edm::PtrVectorBase {
  public:
  __edm__PtrVector_reco__TrackJet_();
  virtual ~__edm__PtrVector_reco__TrackJet_() throw();
};
#ifdef __edm__PtrVector_reco__GenJet_
#undef __edm__PtrVector_reco__GenJet_
#endif
class __edm__PtrVector_reco__GenJet_ : public ::edm::PtrVectorBase {
  public:
  __edm__PtrVector_reco__GenJet_();
  virtual ~__edm__PtrVector_reco__GenJet_() throw();
};
#ifdef __edm__PtrVector_reco__BasicJet_
#undef __edm__PtrVector_reco__BasicJet_
#endif
class __edm__PtrVector_reco__BasicJet_ : public ::edm::PtrVectorBase {
  public:
  __edm__PtrVector_reco__BasicJet_();
  virtual ~__edm__PtrVector_reco__BasicJet_() throw();
};
#ifdef __edm__PtrVector_reco__PFJet_
#undef __edm__PtrVector_reco__PFJet_
#endif
class __edm__PtrVector_reco__PFJet_ : public ::edm::PtrVectorBase {
  public:
  __edm__PtrVector_reco__PFJet_();
  virtual ~__edm__PtrVector_reco__PFJet_() throw();
};
#ifdef __edm__PtrVector_reco__CaloJet_
#undef __edm__PtrVector_reco__CaloJet_
#endif
class __edm__PtrVector_reco__CaloJet_ : public ::edm::PtrVectorBase {
  public:
  __edm__PtrVector_reco__CaloJet_();
  virtual ~__edm__PtrVector_reco__CaloJet_() throw();
};
#ifdef __edm__PtrVector_reco__Jet_
#undef __edm__PtrVector_reco__Jet_
#endif
class __edm__PtrVector_reco__Jet_ : public ::edm::PtrVectorBase {
  public:
  __edm__PtrVector_reco__Jet_();
  virtual ~__edm__PtrVector_reco__Jet_() throw();
};
#ifdef __edm__RefVector_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_edm__refhelper__FindUsingAdvance_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_s_
#undef __edm__RefVector_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_edm__refhelper__FindUsingAdvance_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_s_
#endif
class __edm__RefVector_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_edm__refhelper__FindUsingAdvance_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_s_ {
  public:
  __edm__RefVector_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_edm__refhelper__FindUsingAdvance_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_s_();
  ::edm::RefVectorBase<unsigned int> refVector_;
};
#ifdef __edm__RefVector_std__vector_reco__CastorJetID__reco__CastorJetID_edm__refhelper__FindUsingAdvance_std__vector_reco__CastorJetID__reco__CastorJetID_s_
#undef __edm__RefVector_std__vector_reco__CastorJetID__reco__CastorJetID_edm__refhelper__FindUsingAdvance_std__vector_reco__CastorJetID__reco__CastorJetID_s_
#endif
class __edm__RefVector_std__vector_reco__CastorJetID__reco__CastorJetID_edm__refhelper__FindUsingAdvance_std__vector_reco__CastorJetID__reco__CastorJetID_s_ {
  public:
  __edm__RefVector_std__vector_reco__CastorJetID__reco__CastorJetID_edm__refhelper__FindUsingAdvance_std__vector_reco__CastorJetID__reco__CastorJetID_s_();
  ::edm::RefVectorBase<unsigned int> refVector_;
};
#ifdef __edm__RefVector_std__vector_reco__JetID__reco__JetID_edm__refhelper__FindUsingAdvance_std__vector_reco__JetID__reco__JetID_s_
#undef __edm__RefVector_std__vector_reco__JetID__reco__JetID_edm__refhelper__FindUsingAdvance_std__vector_reco__JetID__reco__JetID_s_
#endif
class __edm__RefVector_std__vector_reco__JetID__reco__JetID_edm__refhelper__FindUsingAdvance_std__vector_reco__JetID__reco__JetID_s_ {
  public:
  __edm__RefVector_std__vector_reco__JetID__reco__JetID_edm__refhelper__FindUsingAdvance_std__vector_reco__JetID__reco__JetID_s_();
  ::edm::RefVectorBase<unsigned int> refVector_;
};
#ifdef __reco__FFTJetProducerSummary
#undef __reco__FFTJetProducerSummary
#endif
class __reco__FFTJetProducerSummary {
  public:
  __reco__FFTJetProducerSummary();
  ::std::vector<float> thresholds_;
  ::std::vector<unsigned int> levelOccupancy_;
  ::math::XYZTLorentzVector unclustered_;
  ::std::vector<edm::Ptr<reco::Candidate> > unclusConstituents_;
  float unused_;
  float minScale_;
  float maxScale_;
  float scaleUsed_;
  unsigned int preclustersFound_;
  unsigned int iterationsPerformed_;
  bool converged_;
};
#ifdef __edm__Wrapper_reco__FFTJetProducerSummary_
#undef __edm__Wrapper_reco__FFTJetProducerSummary_
#endif
class __edm__Wrapper_reco__FFTJetProducerSummary_ {
  public:
  __edm__Wrapper_reco__FFTJetProducerSummary_();
  bool present;
  ::reco::FFTJetProducerSummary obj;
};
#ifdef __reco__PattRecoTree_double_reco__PattRecoPeak_double_s_
#undef __reco__PattRecoTree_double_reco__PattRecoPeak_double_s_
#endif
class __reco__PattRecoTree_double_reco__PattRecoPeak_double_s_ {
  public:
  __reco__PattRecoTree_double_reco__PattRecoPeak_double_s_();
  ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > > nodes_;
  ::std::vector<double> scales_;
  bool sparse_;
};
#ifdef __edm__Wrapper_reco__PattRecoTree_double_reco__PattRecoPeak_double_s_s_
#undef __edm__Wrapper_reco__PattRecoTree_double_reco__PattRecoPeak_double_s_s_
#endif
class __edm__Wrapper_reco__PattRecoTree_double_reco__PattRecoPeak_double_s_s_ {
  public:
  __edm__Wrapper_reco__PattRecoTree_double_reco__PattRecoPeak_double_s_s_();
  bool present;
  ::reco::PattRecoTree<double,reco::PattRecoPeak<double> > obj;
};
#ifdef __reco__PattRecoTree_float_reco__PattRecoPeak_float_s_
#undef __reco__PattRecoTree_float_reco__PattRecoPeak_float_s_
#endif
class __reco__PattRecoTree_float_reco__PattRecoPeak_float_s_ {
  public:
  __reco__PattRecoTree_float_reco__PattRecoPeak_float_s_();
  ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > > nodes_;
  ::std::vector<float> scales_;
  bool sparse_;
};
#ifdef __edm__Wrapper_reco__PattRecoTree_float_reco__PattRecoPeak_float_s_s_
#undef __edm__Wrapper_reco__PattRecoTree_float_reco__PattRecoPeak_float_s_s_
#endif
class __edm__Wrapper_reco__PattRecoTree_float_reco__PattRecoPeak_float_s_s_ {
  public:
  __edm__Wrapper_reco__PattRecoTree_float_reco__PattRecoPeak_float_s_s_();
  bool present;
  ::reco::PattRecoTree<float,reco::PattRecoPeak<float> > obj;
};
#ifdef __edm__RefProd_std__vector_reco__TrackExtrapolation_s_
#undef __edm__RefProd_std__vector_reco__TrackExtrapolation_s_
#endif
class __edm__RefProd_std__vector_reco__TrackExtrapolation_s_ {
  public:
  __edm__RefProd_std__vector_reco__TrackExtrapolation_s_();
  ::edm::RefCore product_;
};
#ifdef __edm__Wrapper_edm__RefProd_std__vector_reco__TrackExtrapolation_s_s_
#undef __edm__Wrapper_edm__RefProd_std__vector_reco__TrackExtrapolation_s_s_
#endif
class __edm__Wrapper_edm__RefProd_std__vector_reco__TrackExtrapolation_s_s_ {
  public:
  __edm__Wrapper_edm__RefProd_std__vector_reco__TrackExtrapolation_s_s_();
  bool present;
  ::edm::RefProd<std::vector<reco::TrackExtrapolation> > obj;
};
#ifdef __edm__Wrapper_edm__RefVector_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_edm__refhelper__FindUsingAdvance_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_s_s_
#undef __edm__Wrapper_edm__RefVector_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_edm__refhelper__FindUsingAdvance_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_s_s_
#endif
class __edm__Wrapper_edm__RefVector_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_edm__refhelper__FindUsingAdvance_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_s_s_ {
  public:
  __edm__Wrapper_edm__RefVector_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_edm__refhelper__FindUsingAdvance_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_s_s_();
  bool present;
  ::edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > obj;
};
#ifdef __edm__Ref_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_edm__refhelper__FindUsingAdvance_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_s_
#undef __edm__Ref_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_edm__refhelper__FindUsingAdvance_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_s_
#endif
class __edm__Ref_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_edm__refhelper__FindUsingAdvance_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_s_ {
  public:
  __edm__Ref_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_edm__refhelper__FindUsingAdvance_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_s_();
  ::edm::RefCoreWithIndex product_;
};
#ifdef __edm__Wrapper_edm__Ref_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_edm__refhelper__FindUsingAdvance_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_s_s_
#undef __edm__Wrapper_edm__Ref_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_edm__refhelper__FindUsingAdvance_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_s_s_
#endif
class __edm__Wrapper_edm__Ref_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_edm__refhelper__FindUsingAdvance_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_s_s_ {
  public:
  __edm__Wrapper_edm__Ref_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_edm__refhelper__FindUsingAdvance_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_s_s_();
  bool present;
  ::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > obj;
};
#ifdef __edm__Wrapper_std__vector_reco__TrackExtrapolation_s_
#undef __edm__Wrapper_std__vector_reco__TrackExtrapolation_s_
#endif
class __edm__Wrapper_std__vector_reco__TrackExtrapolation_s_ {
  public:
  __edm__Wrapper_std__vector_reco__TrackExtrapolation_s_();
  bool present;
  ::std::vector<reco::TrackExtrapolation> obj;
};
#ifdef __edm__Wrapper_reco__TrackExtrapolation_
#undef __edm__Wrapper_reco__TrackExtrapolation_
#endif
class __edm__Wrapper_reco__TrackExtrapolation_ {
  public:
  __edm__Wrapper_reco__TrackExtrapolation_();
  bool present;
  ::reco::TrackExtrapolation obj;
};
#ifdef __edm__ValueMap_reco__CastorJetID_
#undef __edm__ValueMap_reco__CastorJetID_
#endif
class __edm__ValueMap_reco__CastorJetID_ {
  public:
  __edm__ValueMap_reco__CastorJetID_();
#ifdef __edm__ValueMap_reco__CastorJetID___IDComparator
#undef __edm__ValueMap_reco__CastorJetID___IDComparator
#endif
  struct __edm__ValueMap_reco__CastorJetID___IDComparator {
    public:
    __edm__ValueMap_reco__CastorJetID___IDComparator();
  };
  ::std::vector<reco::CastorJetID> values_;
  ::std::vector<std::pair<edm::ProductID,unsigned int> > ids_;
};
#ifdef __edm__Wrapper_edm__ValueMap_reco__CastorJetID_s_
#undef __edm__Wrapper_edm__ValueMap_reco__CastorJetID_s_
#endif
class __edm__Wrapper_edm__ValueMap_reco__CastorJetID_s_ {
  public:
  __edm__Wrapper_edm__ValueMap_reco__CastorJetID_s_();
  bool present;
  ::edm::ValueMap<reco::CastorJetID> obj;
};
#ifdef __edm__Wrapper_std__vector_reco__CastorJetID_s_
#undef __edm__Wrapper_std__vector_reco__CastorJetID_s_
#endif
class __edm__Wrapper_std__vector_reco__CastorJetID_s_ {
  public:
  __edm__Wrapper_std__vector_reco__CastorJetID_s_();
  bool present;
  ::std::vector<reco::CastorJetID> obj;
};
#ifdef __edm__ValueMap_reco__JetID_
#undef __edm__ValueMap_reco__JetID_
#endif
class __edm__ValueMap_reco__JetID_ {
  public:
  __edm__ValueMap_reco__JetID_();
#ifdef __edm__ValueMap_reco__JetID___IDComparator
#undef __edm__ValueMap_reco__JetID___IDComparator
#endif
  struct __edm__ValueMap_reco__JetID___IDComparator {
    public:
    __edm__ValueMap_reco__JetID___IDComparator();
  };
  ::std::vector<reco::JetID> values_;
  ::std::vector<std::pair<edm::ProductID,unsigned int> > ids_;
};
#ifdef __edm__Wrapper_edm__ValueMap_reco__JetID_s_
#undef __edm__Wrapper_edm__ValueMap_reco__JetID_s_
#endif
class __edm__Wrapper_edm__ValueMap_reco__JetID_s_ {
  public:
  __edm__Wrapper_edm__ValueMap_reco__JetID_s_();
  bool present;
  ::edm::ValueMap<reco::JetID> obj;
};
#ifdef __edm__Wrapper_std__vector_reco__JetID_s_
#undef __edm__Wrapper_std__vector_reco__JetID_s_
#endif
class __edm__Wrapper_std__vector_reco__JetID_s_ {
  public:
  __edm__Wrapper_std__vector_reco__JetID_s_();
  bool present;
  ::std::vector<reco::JetID> obj;
};
#ifdef __edm__RefProd_std__vector_reco__CastorJetID_s_
#undef __edm__RefProd_std__vector_reco__CastorJetID_s_
#endif
class __edm__RefProd_std__vector_reco__CastorJetID_s_ {
  public:
  __edm__RefProd_std__vector_reco__CastorJetID_s_();
  ::edm::RefCore product_;
};
#ifdef __edm__RefProd_std__vector_reco__JetID_s_
#undef __edm__RefProd_std__vector_reco__JetID_s_
#endif
class __edm__RefProd_std__vector_reco__JetID_s_ {
  public:
  __edm__RefProd_std__vector_reco__JetID_s_();
  ::edm::RefCore product_;
};
#ifdef __edm__Ptr_reco__CastorJetID_
#undef __edm__Ptr_reco__CastorJetID_
#endif
class __edm__Ptr_reco__CastorJetID_ {
  public:
  __edm__Ptr_reco__CastorJetID_();
  ::edm::RefCore core_;
  unsigned long key_;
};
#ifdef __edm__Ptr_reco__JetID_
#undef __edm__Ptr_reco__JetID_
#endif
class __edm__Ptr_reco__JetID_ {
  public:
  __edm__Ptr_reco__JetID_();
  ::edm::RefCore core_;
  unsigned long key_;
};
#ifdef __edm__Ptr_reco__PFClusterJet_
#undef __edm__Ptr_reco__PFClusterJet_
#endif
class __edm__Ptr_reco__PFClusterJet_ {
  public:
  __edm__Ptr_reco__PFClusterJet_();
  ::edm::RefCore core_;
  unsigned long key_;
};
#ifdef __edm__Ptr_reco__TrackJet_
#undef __edm__Ptr_reco__TrackJet_
#endif
class __edm__Ptr_reco__TrackJet_ {
  public:
  __edm__Ptr_reco__TrackJet_();
  ::edm::RefCore core_;
  unsigned long key_;
};
#ifdef __edm__Ptr_reco__GenJet_
#undef __edm__Ptr_reco__GenJet_
#endif
class __edm__Ptr_reco__GenJet_ {
  public:
  __edm__Ptr_reco__GenJet_();
  ::edm::RefCore core_;
  unsigned long key_;
};
#ifdef __edm__Ptr_reco__BasicJet_
#undef __edm__Ptr_reco__BasicJet_
#endif
class __edm__Ptr_reco__BasicJet_ {
  public:
  __edm__Ptr_reco__BasicJet_();
  ::edm::RefCore core_;
  unsigned long key_;
};
#ifdef __edm__Ptr_reco__PFJet_
#undef __edm__Ptr_reco__PFJet_
#endif
class __edm__Ptr_reco__PFJet_ {
  public:
  __edm__Ptr_reco__PFJet_();
  ::edm::RefCore core_;
  unsigned long key_;
};
#ifdef __edm__Ptr_reco__CaloJet_
#undef __edm__Ptr_reco__CaloJet_
#endif
class __edm__Ptr_reco__CaloJet_ {
  public:
  __edm__Ptr_reco__CaloJet_();
  ::edm::RefCore core_;
  unsigned long key_;
};
#ifdef __edm__Ptr_reco__Jet_
#undef __edm__Ptr_reco__Jet_
#endif
class __edm__Ptr_reco__Jet_ {
  public:
  __edm__Ptr_reco__Jet_();
  ::edm::RefCore core_;
  unsigned long key_;
};
#ifdef __edm__Ref_std__vector_reco__CastorJetID__reco__CastorJetID_edm__refhelper__FindUsingAdvance_std__vector_reco__CastorJetID__reco__CastorJetID_s_
#undef __edm__Ref_std__vector_reco__CastorJetID__reco__CastorJetID_edm__refhelper__FindUsingAdvance_std__vector_reco__CastorJetID__reco__CastorJetID_s_
#endif
class __edm__Ref_std__vector_reco__CastorJetID__reco__CastorJetID_edm__refhelper__FindUsingAdvance_std__vector_reco__CastorJetID__reco__CastorJetID_s_ {
  public:
  __edm__Ref_std__vector_reco__CastorJetID__reco__CastorJetID_edm__refhelper__FindUsingAdvance_std__vector_reco__CastorJetID__reco__CastorJetID_s_();
  ::edm::RefCoreWithIndex product_;
};
#ifdef __edm__Ref_std__vector_reco__JetID__reco__JetID_edm__refhelper__FindUsingAdvance_std__vector_reco__JetID__reco__JetID_s_
#undef __edm__Ref_std__vector_reco__JetID__reco__JetID_edm__refhelper__FindUsingAdvance_std__vector_reco__JetID__reco__JetID_s_
#endif
class __edm__Ref_std__vector_reco__JetID__reco__JetID_edm__refhelper__FindUsingAdvance_std__vector_reco__JetID__reco__JetID_s_ {
  public:
  __edm__Ref_std__vector_reco__JetID__reco__JetID_edm__refhelper__FindUsingAdvance_std__vector_reco__JetID__reco__JetID_s_();
  ::edm::RefCoreWithIndex product_;
};
#ifdef __reco__CATopJetTagInfo
#undef __reco__CATopJetTagInfo
#endif
class __reco__CATopJetTagInfo : public ::reco::JetTagInfo {
  public:
  __reco__CATopJetTagInfo();
  virtual ~__reco__CATopJetTagInfo() throw();
  virtual ::reco::CATopJetTagInfo* clone() const throw();
  ::reco::CATopJetProperties properties_;
};
#ifdef __reco__CATopJetProperties
#undef __reco__CATopJetProperties
#endif
class __reco__CATopJetProperties {
  public:
  __reco__CATopJetProperties();
  int nSubJets;
  double minMass;
  double topMass;
  double wMass;
};
#ifdef __reco__FFTJet_float_
#undef __reco__FFTJet_float_
#endif
class __reco__FFTJet_float_ {
  public:
  __reco__FFTJet_float_();
  virtual ~__reco__FFTJet_float_() throw();
  ::reco::PattRecoPeak<float> peak_;
  ::ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > vec_;
  ::ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > pileup_;
  float ncells_;
  float etSum_;
  float centroidEta_;
  float centroidPhi_;
  float etaWidth_;
  float phiWidth_;
  float etaPhiCorr_;
  float fuzziness_;
  float convergenceD_;
  float recoScale_;
  float recoScaleRatio_;
  float membershipFactor_;
  int code_;
  int status_;
};
#ifdef __reco__FFTJet_double_
#undef __reco__FFTJet_double_
#endif
class __reco__FFTJet_double_ {
  public:
  __reco__FFTJet_double_();
  virtual ~__reco__FFTJet_double_() throw();
  ::reco::PattRecoPeak<double> peak_;
  ::ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > vec_;
  ::ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > pileup_;
  double ncells_;
  double etSum_;
  double centroidEta_;
  double centroidPhi_;
  double etaWidth_;
  double phiWidth_;
  double etaPhiCorr_;
  double fuzziness_;
  double convergenceD_;
  double recoScale_;
  double recoScaleRatio_;
  double membershipFactor_;
  int code_;
  int status_;
};
#ifdef __reco__FFTAnyJet_reco__GenJet_
#undef __reco__FFTAnyJet_reco__GenJet_
#endif
class __reco__FFTAnyJet_reco__GenJet_ : public ::reco::GenJet {
  public:
  __reco__FFTAnyJet_reco__GenJet_();
  virtual ~__reco__FFTAnyJet_reco__GenJet_() throw();
  virtual ::reco::FFTAnyJet<reco::GenJet>* clone() const throw();
  ::reco::FFTJet<float> fftJetSpecific_;
};
#ifdef __edm__FwdRef_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_
#undef __edm__FwdRef_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_
#endif
class __edm__FwdRef_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_ {
  public:
  __edm__FwdRef_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_();
  ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > ref_;
  ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > backRef_;
};
#ifdef __edm__RefVector_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_
#undef __edm__RefVector_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_
#endif
class __edm__RefVector_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_ {
  public:
  __edm__RefVector_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_();
  ::edm::RefVectorBase<unsigned int> refVector_;
};
#ifdef __reco__FFTAnyJet_reco__CaloJet_
#undef __reco__FFTAnyJet_reco__CaloJet_
#endif
class __reco__FFTAnyJet_reco__CaloJet_ : public ::reco::CaloJet {
  public:
  __reco__FFTAnyJet_reco__CaloJet_();
  virtual ~__reco__FFTAnyJet_reco__CaloJet_() throw();
  virtual ::reco::FFTAnyJet<reco::CaloJet>* clone() const throw();
  ::reco::FFTJet<float> fftJetSpecific_;
};
#ifdef __edm__FwdRef_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_
#undef __edm__FwdRef_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_
#endif
class __edm__FwdRef_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_ {
  public:
  __edm__FwdRef_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_();
  ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > ref_;
  ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > backRef_;
};
#ifdef __edm__RefVector_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_
#undef __edm__RefVector_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_
#endif
class __edm__RefVector_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_ {
  public:
  __edm__RefVector_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_();
  ::edm::RefVectorBase<unsigned int> refVector_;
};
#ifdef __edm__FwdPtr_reco__FFTAnyJet_reco__CaloJet_s_
#undef __edm__FwdPtr_reco__FFTAnyJet_reco__CaloJet_s_
#endif
class __edm__FwdPtr_reco__FFTAnyJet_reco__CaloJet_s_ {
  public:
  __edm__FwdPtr_reco__FFTAnyJet_reco__CaloJet_s_();
  ::edm::Ptr<reco::FFTAnyJet<reco::CaloJet> > ptr_;
  ::edm::Ptr<reco::FFTAnyJet<reco::CaloJet> > backPtr_;
};
#ifdef __std__vector_edm__FwdPtr_reco__FFTAnyJet_reco__CaloJet_s_s_
#undef __std__vector_edm__FwdPtr_reco__FFTAnyJet_reco__CaloJet_s_s_
#endif
class __std__vector_edm__FwdPtr_reco__FFTAnyJet_reco__CaloJet_s_s_ : protected ::std::_Vector_base<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >,std::allocator<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > > {
  public:
  __std__vector_edm__FwdPtr_reco__FFTAnyJet_reco__CaloJet_s_s_();
};
#ifdef __std__vector_reco__FFTAnyJet_reco__CaloJet_s_
#undef __std__vector_reco__FFTAnyJet_reco__CaloJet_s_
#endif
class __std__vector_reco__FFTAnyJet_reco__CaloJet_s_ : protected ::std::_Vector_base<reco::FFTAnyJet<reco::CaloJet>,std::allocator<reco::FFTAnyJet<reco::CaloJet> > > {
  public:
  __std__vector_reco__FFTAnyJet_reco__CaloJet_s_();
};
#ifdef __edm__FwdPtr_reco__FFTAnyJet_reco__GenJet_s_
#undef __edm__FwdPtr_reco__FFTAnyJet_reco__GenJet_s_
#endif
class __edm__FwdPtr_reco__FFTAnyJet_reco__GenJet_s_ {
  public:
  __edm__FwdPtr_reco__FFTAnyJet_reco__GenJet_s_();
  ::edm::Ptr<reco::FFTAnyJet<reco::GenJet> > ptr_;
  ::edm::Ptr<reco::FFTAnyJet<reco::GenJet> > backPtr_;
};
#ifdef __std__vector_edm__FwdPtr_reco__FFTAnyJet_reco__GenJet_s_s_
#undef __std__vector_edm__FwdPtr_reco__FFTAnyJet_reco__GenJet_s_s_
#endif
class __std__vector_edm__FwdPtr_reco__FFTAnyJet_reco__GenJet_s_s_ : protected ::std::_Vector_base<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >,std::allocator<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > > {
  public:
  __std__vector_edm__FwdPtr_reco__FFTAnyJet_reco__GenJet_s_s_();
};
#ifdef __edm__Ref_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_
#undef __edm__Ref_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_
#endif
class __edm__Ref_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_ {
  public:
  __edm__Ref_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_();
  ::edm::RefCoreWithIndex product_;
};
#ifdef __std__vector_edm__FwdRef_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s_
#undef __std__vector_edm__FwdRef_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s_
#endif
class __std__vector_edm__FwdRef_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s_ : protected ::std::_Vector_base<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >,std::allocator<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > > {
  public:
  __std__vector_edm__FwdRef_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s_();
};
#ifdef __std__vector_reco__FFTAnyJet_reco__GenJet_s_
#undef __std__vector_reco__FFTAnyJet_reco__GenJet_s_
#endif
class __std__vector_reco__FFTAnyJet_reco__GenJet_s_ : protected ::std::_Vector_base<reco::FFTAnyJet<reco::GenJet>,std::allocator<reco::FFTAnyJet<reco::GenJet> > > {
  public:
  __std__vector_reco__FFTAnyJet_reco__GenJet_s_();
};
#ifdef __edm__RefProd_std__vector_reco__FFTAnyJet_reco__GenJet_s_s_
#undef __edm__RefProd_std__vector_reco__FFTAnyJet_reco__GenJet_s_s_
#endif
class __edm__RefProd_std__vector_reco__FFTAnyJet_reco__GenJet_s_s_ {
  public:
  __edm__RefProd_std__vector_reco__FFTAnyJet_reco__GenJet_s_s_();
  ::edm::RefCore product_;
};
#ifdef __std__vector_reco__CATopJetTagInfo_
#undef __std__vector_reco__CATopJetTagInfo_
#endif
class __std__vector_reco__CATopJetTagInfo_ : protected ::std::_Vector_base<reco::CATopJetTagInfo,std::allocator<reco::CATopJetTagInfo> > {
  public:
  __std__vector_reco__CATopJetTagInfo_();
};
#ifdef __edm__RefProd_std__vector_reco__CATopJetTagInfo_s_
#undef __edm__RefProd_std__vector_reco__CATopJetTagInfo_s_
#endif
class __edm__RefProd_std__vector_reco__CATopJetTagInfo_s_ {
  public:
  __edm__RefProd_std__vector_reco__CATopJetTagInfo_s_();
  ::edm::RefCore product_;
};
#ifdef __edm__RefProd_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s_
#undef __edm__RefProd_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s_
#endif
class __edm__RefProd_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s_ {
  public:
  __edm__RefProd_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s_();
  ::edm::RefCore product_;
};
#ifdef __edm__RefVector_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_
#undef __edm__RefVector_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_
#endif
class __edm__RefVector_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_ {
  public:
  __edm__RefVector_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_();
  ::edm::RefVectorBase<unsigned int> refVector_;
};
#ifdef __std__vector_edm__FwdRef_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s_
#undef __std__vector_edm__FwdRef_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s_
#endif
class __std__vector_edm__FwdRef_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s_ : protected ::std::_Vector_base<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >,std::allocator<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > > {
  public:
  __std__vector_edm__FwdRef_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s_();
};
#ifdef __edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_
#undef __edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_
#endif
class __edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_ {
  public:
  __edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_();
  ::edm::RefCoreWithIndex product_;
};
#ifdef __edm__Ref_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_
#undef __edm__Ref_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_
#endif
class __edm__Ref_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_ {
  public:
  __edm__Ref_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_();
  ::edm::RefCoreWithIndex product_;
};
#ifdef __edm__PtrVector_reco__FFTAnyJet_reco__CaloJet_s_
#undef __edm__PtrVector_reco__FFTAnyJet_reco__CaloJet_s_
#endif
class __edm__PtrVector_reco__FFTAnyJet_reco__CaloJet_s_ : public ::edm::PtrVectorBase {
  public:
  __edm__PtrVector_reco__FFTAnyJet_reco__CaloJet_s_();
  virtual ~__edm__PtrVector_reco__FFTAnyJet_reco__CaloJet_s_() throw();
};
#ifdef __edm__PtrVector_reco__FFTAnyJet_reco__GenJet_s_
#undef __edm__PtrVector_reco__FFTAnyJet_reco__GenJet_s_
#endif
class __edm__PtrVector_reco__FFTAnyJet_reco__GenJet_s_ : public ::edm::PtrVectorBase {
  public:
  __edm__PtrVector_reco__FFTAnyJet_reco__GenJet_s_();
  virtual ~__edm__PtrVector_reco__FFTAnyJet_reco__GenJet_s_() throw();
};
#ifdef __edm__Wrapper_std__vector_reco__CATopJetTagInfo_s_
#undef __edm__Wrapper_std__vector_reco__CATopJetTagInfo_s_
#endif
class __edm__Wrapper_std__vector_reco__CATopJetTagInfo_s_ {
  public:
  __edm__Wrapper_std__vector_reco__CATopJetTagInfo_s_();
  bool present;
  ::std::vector<reco::CATopJetTagInfo> obj;
};
#ifdef __edm__Association_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s_
#undef __edm__Association_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s_
#endif
class __edm__Association_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s_ : private ::edm::ValueMap<int> {
  public:
  __edm__Association_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s_();
  ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::CaloJet> > > ref_;
};
#ifdef __edm__Wrapper_edm__Association_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s_s_
#undef __edm__Wrapper_edm__Association_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s_s_
#endif
class __edm__Wrapper_edm__Association_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s_s_ {
  public:
  __edm__Wrapper_edm__Association_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s_s_();
  bool present;
  ::edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > > obj;
};
#ifdef __edm__Wrapper_std__vector_edm__FwdPtr_reco__FFTAnyJet_reco__CaloJet_s_s_s_
#undef __edm__Wrapper_std__vector_edm__FwdPtr_reco__FFTAnyJet_reco__CaloJet_s_s_s_
#endif
class __edm__Wrapper_std__vector_edm__FwdPtr_reco__FFTAnyJet_reco__CaloJet_s_s_s_ {
  public:
  __edm__Wrapper_std__vector_edm__FwdPtr_reco__FFTAnyJet_reco__CaloJet_s_s_s_();
  bool present;
  ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > obj;
};
#ifdef __edm__Wrapper_std__vector_edm__FwdRef_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s_s_
#undef __edm__Wrapper_std__vector_edm__FwdRef_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s_s_
#endif
class __edm__Wrapper_std__vector_edm__FwdRef_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s_s_ {
  public:
  __edm__Wrapper_std__vector_edm__FwdRef_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s_s_();
  bool present;
  ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > obj;
};
#ifdef __edm__Wrapper_edm__RefVector_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s_
#undef __edm__Wrapper_edm__RefVector_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s_
#endif
class __edm__Wrapper_edm__RefVector_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s_ {
  public:
  __edm__Wrapper_edm__RefVector_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s_();
  bool present;
  ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > obj;
};
#ifdef __edm__Wrapper_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s_
#undef __edm__Wrapper_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s_
#endif
class __edm__Wrapper_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s_ {
  public:
  __edm__Wrapper_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s_();
  bool present;
  ::std::vector<reco::FFTAnyJet<reco::CaloJet> > obj;
};
#ifdef __edm__Association_std__vector_reco__FFTAnyJet_reco__GenJet_s_s_
#undef __edm__Association_std__vector_reco__FFTAnyJet_reco__GenJet_s_s_
#endif
class __edm__Association_std__vector_reco__FFTAnyJet_reco__GenJet_s_s_ : private ::edm::ValueMap<int> {
  public:
  __edm__Association_std__vector_reco__FFTAnyJet_reco__GenJet_s_s_();
  ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::GenJet> > > ref_;
};
#ifdef __edm__Wrapper_edm__Association_std__vector_reco__FFTAnyJet_reco__GenJet_s_s_s_
#undef __edm__Wrapper_edm__Association_std__vector_reco__FFTAnyJet_reco__GenJet_s_s_s_
#endif
class __edm__Wrapper_edm__Association_std__vector_reco__FFTAnyJet_reco__GenJet_s_s_s_ {
  public:
  __edm__Wrapper_edm__Association_std__vector_reco__FFTAnyJet_reco__GenJet_s_s_s_();
  bool present;
  ::edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > > obj;
};
#ifdef __edm__Wrapper_std__vector_edm__FwdPtr_reco__FFTAnyJet_reco__GenJet_s_s_s_
#undef __edm__Wrapper_std__vector_edm__FwdPtr_reco__FFTAnyJet_reco__GenJet_s_s_s_
#endif
class __edm__Wrapper_std__vector_edm__FwdPtr_reco__FFTAnyJet_reco__GenJet_s_s_s_ {
  public:
  __edm__Wrapper_std__vector_edm__FwdPtr_reco__FFTAnyJet_reco__GenJet_s_s_s_();
  bool present;
  ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > obj;
};
#ifdef __edm__Wrapper_std__vector_edm__FwdRef_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s_s_
#undef __edm__Wrapper_std__vector_edm__FwdRef_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s_s_
#endif
class __edm__Wrapper_std__vector_edm__FwdRef_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s_s_ {
  public:
  __edm__Wrapper_std__vector_edm__FwdRef_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s_s_();
  bool present;
  ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > obj;
};
#ifdef __edm__Wrapper_edm__RefVector_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s_
#undef __edm__Wrapper_edm__RefVector_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s_
#endif
class __edm__Wrapper_edm__RefVector_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s_ {
  public:
  __edm__Wrapper_edm__RefVector_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s_();
  bool present;
  ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > obj;
};
#ifdef __edm__Wrapper_std__vector_reco__FFTAnyJet_reco__GenJet_s_s_
#undef __edm__Wrapper_std__vector_reco__FFTAnyJet_reco__GenJet_s_s_
#endif
class __edm__Wrapper_std__vector_reco__FFTAnyJet_reco__GenJet_s_s_ {
  public:
  __edm__Wrapper_std__vector_reco__FFTAnyJet_reco__GenJet_s_s_();
  bool present;
  ::std::vector<reco::FFTAnyJet<reco::GenJet> > obj;
};
#ifdef __edm__Association_std__vector_reco__PFJet_s_
#undef __edm__Association_std__vector_reco__PFJet_s_
#endif
class __edm__Association_std__vector_reco__PFJet_s_ : private ::edm::ValueMap<int> {
  public:
  __edm__Association_std__vector_reco__PFJet_s_();
  ::edm::RefProd<std::vector<reco::PFJet> > ref_;
};
#ifdef __edm__Wrapper_edm__Association_std__vector_reco__PFJet_s_s_
#undef __edm__Wrapper_edm__Association_std__vector_reco__PFJet_s_s_
#endif
class __edm__Wrapper_edm__Association_std__vector_reco__PFJet_s_s_ {
  public:
  __edm__Wrapper_edm__Association_std__vector_reco__PFJet_s_s_();
  bool present;
  ::edm::Association<std::vector<reco::PFJet> > obj;
};
#ifdef __edm__Association_std__vector_reco__GenJet_s_
#undef __edm__Association_std__vector_reco__GenJet_s_
#endif
class __edm__Association_std__vector_reco__GenJet_s_ : private ::edm::ValueMap<int> {
  public:
  __edm__Association_std__vector_reco__GenJet_s_();
  ::edm::RefProd<std::vector<reco::GenJet> > ref_;
};
#ifdef __edm__Wrapper_edm__Association_std__vector_reco__GenJet_s_s_
#undef __edm__Wrapper_edm__Association_std__vector_reco__GenJet_s_s_
#endif
class __edm__Wrapper_edm__Association_std__vector_reco__GenJet_s_s_ {
  public:
  __edm__Wrapper_edm__Association_std__vector_reco__GenJet_s_s_();
  bool present;
  ::edm::Association<std::vector<reco::GenJet> > obj;
};
#ifdef __edm__Ptr_reco__FFTAnyJet_reco__CaloJet_s_
#undef __edm__Ptr_reco__FFTAnyJet_reco__CaloJet_s_
#endif
class __edm__Ptr_reco__FFTAnyJet_reco__CaloJet_s_ {
  public:
  __edm__Ptr_reco__FFTAnyJet_reco__CaloJet_s_();
  ::edm::RefCore core_;
  unsigned long key_;
};
#ifdef __edm__Ptr_reco__FFTAnyJet_reco__GenJet_s_
#undef __edm__Ptr_reco__FFTAnyJet_reco__GenJet_s_
#endif
class __edm__Ptr_reco__FFTAnyJet_reco__GenJet_s_ {
  public:
  __edm__Ptr_reco__FFTAnyJet_reco__GenJet_s_();
  ::edm::RefCore core_;
  unsigned long key_;
};
#ifdef __reco__JetTrackMatch_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s_
#undef __reco__JetTrackMatch_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s_
#endif
class __reco__JetTrackMatch_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s_ {
  public:
  __reco__JetTrackMatch_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s_();
  ::edm::AssociationMap<edm::OneToMany<std::vector<reco::FFTAnyJet<reco::CaloJet> >,std::vector<reco::Track>,unsigned int> > mMap;
};
#ifdef __reco__JetTrackMatch_std__vector_reco__FFTAnyJet_reco__GenJet_s_s_
#undef __reco__JetTrackMatch_std__vector_reco__FFTAnyJet_reco__GenJet_s_s_
#endif
class __reco__JetTrackMatch_std__vector_reco__FFTAnyJet_reco__GenJet_s_s_ {
  public:
  __reco__JetTrackMatch_std__vector_reco__FFTAnyJet_reco__GenJet_s_s_();
  ::edm::AssociationMap<edm::OneToMany<std::vector<reco::FFTAnyJet<reco::GenJet> >,std::vector<reco::Track>,unsigned int> > mMap;
};
#ifdef __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_s_
#undef __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_s_
#endif
class __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_s_ : public ::edm::reftobase::RefHolderBase {
  public:
  __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_s_();
  virtual ~__edm__reftobase__RefHolder_edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_s_() throw();
  ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > ref_;
};
#ifdef __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s_
#undef __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s_
#endif
class __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s_ : public ::edm::reftobase::RefHolderBase {
  public:
  __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s_();
  virtual ~__edm__reftobase__RefHolder_edm__Ref_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s_() throw();
  ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > ref_;
};
#ifdef __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s_
#undef __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s_
#endif
class __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s_ : public ::edm::reftobase::RefHolderBase {
  public:
  __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s_();
  virtual ~__edm__reftobase__RefHolder_edm__Ref_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s_() throw();
  ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > ref_;
};
#ifdef __edm__reftobase__Holder_reco__BaseTagInfo_edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_s_
#undef __edm__reftobase__Holder_reco__BaseTagInfo_edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_s_
#endif
class __edm__reftobase__Holder_reco__BaseTagInfo_edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_s_ : public ::edm::reftobase::BaseHolder<reco::BaseTagInfo> {
  public:
  __edm__reftobase__Holder_reco__BaseTagInfo_edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_s_();
  virtual ~__edm__reftobase__Holder_reco__BaseTagInfo_edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_s_() throw();
  ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > ref_;
};
#ifdef __edm__reftobase__Holder_reco__Jet_edm__Ref_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s_
#undef __edm__reftobase__Holder_reco__Jet_edm__Ref_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s_
#endif
class __edm__reftobase__Holder_reco__Jet_edm__Ref_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s_ : public ::edm::reftobase::BaseHolder<reco::Jet> {
  public:
  __edm__reftobase__Holder_reco__Jet_edm__Ref_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s_();
  virtual ~__edm__reftobase__Holder_reco__Jet_edm__Ref_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s_() throw();
  ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > ref_;
};
#ifdef __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s_
#undef __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s_
#endif
class __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s_ : public ::edm::reftobase::BaseHolder<reco::Candidate> {
  public:
  __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s_();
  virtual ~__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s_() throw();
  ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > ref_;
};
#ifdef __edm__reftobase__Holder_reco__Jet_edm__Ref_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s_
#undef __edm__reftobase__Holder_reco__Jet_edm__Ref_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s_
#endif
class __edm__reftobase__Holder_reco__Jet_edm__Ref_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s_ : public ::edm::reftobase::BaseHolder<reco::Jet> {
  public:
  __edm__reftobase__Holder_reco__Jet_edm__Ref_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s_();
  virtual ~__edm__reftobase__Holder_reco__Jet_edm__Ref_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s_() throw();
  ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > ref_;
};
#ifdef __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s_
#undef __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s_
#endif
class __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s_ : public ::edm::reftobase::BaseHolder<reco::Candidate> {
  public:
  __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s_();
  virtual ~__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s_() throw();
  ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > ref_;
};
}


#endif // __CINT__
namespace {
//------Stub functions for class pair<edm::RefToBase<reco::Jet>,reco::CATopJetProperties> -------------------------------
static void destructor_12926(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<edm::RefToBase<reco::Jet>,reco::CATopJetProperties>*)o)->::std::pair<edm::RefToBase<reco::Jet>,reco::CATopJetProperties>::~pair)();
}
static  void operator_12927( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::pair<edm::RefToBase<reco::Jet>,reco::CATopJetProperties>*)o)->operator=)(*(const ::std::pair<edm::RefToBase<reco::Jet>,reco::CATopJetProperties>*)arg[0]);
  else   (((::std::pair<edm::RefToBase<reco::Jet>,reco::CATopJetProperties>*)o)->operator=)(*(const ::std::pair<edm::RefToBase<reco::Jet>,reco::CATopJetProperties>*)arg[0]);
}

static void constructor_12928( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<edm::RefToBase<reco::Jet>,reco::CATopJetProperties>(*(const ::std::pair<edm::RefToBase<reco::Jet>,reco::CATopJetProperties>*)arg[0]);
  else ::new(mem) ::std::pair<edm::RefToBase<reco::Jet>,reco::CATopJetProperties>(*(const ::std::pair<edm::RefToBase<reco::Jet>,reco::CATopJetProperties>*)arg[0]);
}

static void constructor_12929( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<edm::RefToBase<reco::Jet>,reco::CATopJetProperties>();
  else ::new(mem) ::std::pair<edm::RefToBase<reco::Jet>,reco::CATopJetProperties>();
}

static void constructor_12930( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<edm::RefToBase<reco::Jet>,reco::CATopJetProperties>(*(const ::edm::RefToBase<reco::Jet>*)arg[0],
      *(const ::reco::CATopJetProperties*)arg[1]);
  else ::new(mem) ::std::pair<edm::RefToBase<reco::Jet>,reco::CATopJetProperties>(*(const ::edm::RefToBase<reco::Jet>*)arg[0],
      *(const ::reco::CATopJetProperties*)arg[1]);
}

static void method_newdel_2924( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<edm::RefToBase<reco::Jet>,reco::CATopJetProperties> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<edm::RefToBase<reco::Jet>,reco::CATopJetProperties> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<edm::RefToBase<reco::Jet>,reco::CATopJetProperties> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<edm::RefToBase<reco::Jet>,reco::CATopJetProperties> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<edm::RefToBase<reco::Jet>,reco::CATopJetProperties> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<edm::RefToBase<reco::Jet>,reco::CATopJetProperties> -------------------------------
void __std__pair_edm__RefToBase_reco__Jet__reco__CATopJetProperties__db_datamem(Reflex::Class*);
void __std__pair_edm__RefToBase_reco__Jet__reco__CATopJetProperties__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_edm__RefToBase_reco__Jet__reco__CATopJetProperties__datamem_bld(&__std__pair_edm__RefToBase_reco__Jet__reco__CATopJetProperties__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_edm__RefToBase_reco__Jet__reco__CATopJetProperties__funcmem_bld(&__std__pair_edm__RefToBase_reco__Jet__reco__CATopJetProperties__db_funcmem);
void __std__pair_edm__RefToBase_reco__Jet__reco__CATopJetProperties__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<edm::RefToBase<reco::Jet>,reco::CATopJetProperties>"), typeid(::std::pair<edm::RefToBase<reco::Jet>,reco::CATopJetProperties>), sizeof(::std::pair<edm::RefToBase<reco::Jet>,reco::CATopJetProperties>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_4978, Reflex::Literal("std::pair<edm::RefToBase<reco::Jet>,reco::CATopJetProperties>::first_type"))
  .AddTypedef(type_7826, Reflex::Literal("std::pair<edm::RefToBase<reco::Jet>,reco::CATopJetProperties>::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_12926, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35925, type_35926), Reflex::Literal("operator="), operator_12927, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35926), Reflex::Literal("pair"), constructor_12928, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_12929, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35927, type_35928), Reflex::Literal("pair"), constructor_12930, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2924, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_edm__RefToBase_reco__Jet__reco__CATopJetProperties__datamem_bld);
}

//------Delayed data member builder for class pair<edm::RefToBase<reco::Jet>,reco::CATopJetProperties> -------------------
void __std__pair_edm__RefToBase_reco__Jet__reco__CATopJetProperties__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4978, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_edm__RefToBase_reco__Jet__reco__CATopJetProperties_, first), ::Reflex::PUBLIC)
  .AddDataMember(type_7826, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_edm__RefToBase_reco__Jet__reco__CATopJetProperties_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<edm::RefToBase<reco::Jet>,reco::CATopJetProperties> -------------------
void __std__pair_edm__RefToBase_reco__Jet__reco__CATopJetProperties__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class PattRecoPeak<double> -------------------------------
static void destructor_27577(void*, void * o, const std::vector<void*>&, void *) {
(((::reco::PattRecoPeak<double>*)o)->::reco::PattRecoPeak<double>::~PattRecoPeak)();
}
static  void operator_27578( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::reco::PattRecoPeak<double>*)o)->operator=)(*(const ::reco::PattRecoPeak<double>*)arg[0]);
  else   (((::reco::PattRecoPeak<double>*)o)->operator=)(*(const ::reco::PattRecoPeak<double>*)arg[0]);
}

static void constructor_27579( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::PattRecoPeak<double>(*(const ::reco::PattRecoPeak<double>*)arg[0]);
  else ::new(mem) ::reco::PattRecoPeak<double>(*(const ::reco::PattRecoPeak<double>*)arg[0]);
}

static void constructor_27580( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::PattRecoPeak<double>();
  else ::new(mem) ::reco::PattRecoPeak<double>();
}

static void constructor_27581( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::PattRecoPeak<double>(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      (const double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(double*)arg[9],
      *(double*)arg[10],
      *(double*)arg[11],
      *(double*)arg[12]);
  else ::new(mem) ::reco::PattRecoPeak<double>(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      (const double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(double*)arg[9],
      *(double*)arg[10],
      *(double*)arg[11],
      *(double*)arg[12]);
}

static  void method_27582( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::PattRecoPeak<double>*)o)->eta)());
  else   (((const ::reco::PattRecoPeak<double>*)o)->eta)();
}

static  void method_27583( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::PattRecoPeak<double>*)o)->phi)());
  else   (((const ::reco::PattRecoPeak<double>*)o)->phi)();
}

static  void method_27584( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::PattRecoPeak<double>*)o)->magnitude)());
  else   (((const ::reco::PattRecoPeak<double>*)o)->magnitude)();
}

static  void method_27585( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::PattRecoPeak<double>*)o)->driftSpeed)());
  else   (((const ::reco::PattRecoPeak<double>*)o)->driftSpeed)();
}

static  void method_27586( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::PattRecoPeak<double>*)o)->magSpeed)());
  else   (((const ::reco::PattRecoPeak<double>*)o)->magSpeed)();
}

static  void method_27587( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::PattRecoPeak<double>*)o)->lifetime)());
  else   (((const ::reco::PattRecoPeak<double>*)o)->lifetime)();
}

static  void method_27588( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::PattRecoPeak<double>*)o)->splitTime)());
  else   (((const ::reco::PattRecoPeak<double>*)o)->splitTime)();
}

static  void method_27589( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::PattRecoPeak<double>*)o)->mergeTime)());
  else   (((const ::reco::PattRecoPeak<double>*)o)->mergeTime)();
}

static  void method_27590( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::PattRecoPeak<double>*)o)->scale)());
  else   (((const ::reco::PattRecoPeak<double>*)o)->scale)();
}

static  void method_27591( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::PattRecoPeak<double>*)o)->nearestNeighborDistance)());
  else   (((const ::reco::PattRecoPeak<double>*)o)->nearestNeighborDistance)();
}

static  void method_27592( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::PattRecoPeak<double>*)o)->clusterRadius)());
  else   (((const ::reco::PattRecoPeak<double>*)o)->clusterRadius)();
}

static  void method_27593( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::PattRecoPeak<double>*)o)->clusterSeparation)());
  else   (((const ::reco::PattRecoPeak<double>*)o)->clusterSeparation)();
}

static  void method_27594( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::reco::PattRecoPeak<double>*)o)->hessian)((double*)arg[0]);
}

static void method_newdel_7809( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::reco::PattRecoPeak<double> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::reco::PattRecoPeak<double> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::reco::PattRecoPeak<double> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::reco::PattRecoPeak<double> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::reco::PattRecoPeak<double> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class PattRecoPeak<double> -------------------------------
void __reco__PattRecoPeak_double__db_datamem(Reflex::Class*);
void __reco__PattRecoPeak_double__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __reco__PattRecoPeak_double__datamem_bld(&__reco__PattRecoPeak_double__db_datamem);
Reflex::GenreflexMemberBuilder __reco__PattRecoPeak_double__funcmem_bld(&__reco__PattRecoPeak_double__db_funcmem);
void __reco__PattRecoPeak_double__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("reco::PattRecoPeak<double>"), typeid(::reco::PattRecoPeak<double>), sizeof(::reco::PattRecoPeak<double>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PattRecoPeak"), destructor_27577, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_40752, type_40753), Reflex::Literal("operator="), operator_27578, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_40753), Reflex::Literal("PattRecoPeak"), constructor_27579, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PattRecoPeak"), constructor_27580, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_101, type_101, type_101, type_3829, type_101, type_101, type_101, type_101, type_101, type_101, type_101, type_101, type_101), Reflex::Literal("PattRecoPeak"), constructor_27581, 0, "eta;phi;mag;hessianIn;driftSpeed;magSpeed;lifetime;scale;nearestDistance;clusterRadius;clusterSeparation;splitT;mergeT", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_7809, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__reco__PattRecoPeak_double__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__reco__PattRecoPeak_double__funcmem_bld);
}

//------Delayed data member builder for class PattRecoPeak<double> -------------------
void __reco__PattRecoPeak_double__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_101, Reflex::Literal("eta_"), OffsetOf(__shadow__::__reco__PattRecoPeak_double_, eta_), ::Reflex::PRIVATE)
  .AddDataMember(type_101, Reflex::Literal("phi_"), OffsetOf(__shadow__::__reco__PattRecoPeak_double_, phi_), ::Reflex::PRIVATE)
  .AddDataMember(type_101, Reflex::Literal("magnitude_"), OffsetOf(__shadow__::__reco__PattRecoPeak_double_, magnitude_), ::Reflex::PRIVATE)
  .AddDataMember(type_101, Reflex::Literal("speed_"), OffsetOf(__shadow__::__reco__PattRecoPeak_double_, speed_), ::Reflex::PRIVATE)
  .AddDataMember(type_101, Reflex::Literal("magSpeed_"), OffsetOf(__shadow__::__reco__PattRecoPeak_double_, magSpeed_), ::Reflex::PRIVATE)
  .AddDataMember(type_101, Reflex::Literal("lifetime_"), OffsetOf(__shadow__::__reco__PattRecoPeak_double_, lifetime_), ::Reflex::PRIVATE)
  .AddDataMember(type_101, Reflex::Literal("scale_"), OffsetOf(__shadow__::__reco__PattRecoPeak_double_, scale_), ::Reflex::PRIVATE)
  .AddDataMember(type_101, Reflex::Literal("nearestD_"), OffsetOf(__shadow__::__reco__PattRecoPeak_double_, nearestD_), ::Reflex::PRIVATE)
  .AddDataMember(type_101, Reflex::Literal("clusterRadius_"), OffsetOf(__shadow__::__reco__PattRecoPeak_double_, clusterRadius_), ::Reflex::PRIVATE)
  .AddDataMember(type_101, Reflex::Literal("clusterSeparation_"), OffsetOf(__shadow__::__reco__PattRecoPeak_double_, clusterSeparation_), ::Reflex::PRIVATE)
  .AddDataMember(type_40751, Reflex::Literal("hessian_"), OffsetOf(__shadow__::__reco__PattRecoPeak_double_, hessian_), ::Reflex::PRIVATE)
  .AddDataMember(type_101, Reflex::Literal("splitTime_"), OffsetOf(__shadow__::__reco__PattRecoPeak_double_, splitTime_), ::Reflex::PRIVATE)
  .AddDataMember(type_101, Reflex::Literal("mergeTime_"), OffsetOf(__shadow__::__reco__PattRecoPeak_double_, mergeTime_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class PattRecoPeak<double> -------------------
void __reco__PattRecoPeak_double__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_101), Reflex::Literal("eta"), method_27582, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_101), Reflex::Literal("phi"), method_27583, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_101), Reflex::Literal("magnitude"), method_27584, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_101), Reflex::Literal("driftSpeed"), method_27585, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_101), Reflex::Literal("magSpeed"), method_27586, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_101), Reflex::Literal("lifetime"), method_27587, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_101), Reflex::Literal("splitTime"), method_27588, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_101), Reflex::Literal("mergeTime"), method_27589, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_101), Reflex::Literal("scale"), method_27590, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_101), Reflex::Literal("nearestNeighborDistance"), method_27591, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_101), Reflex::Literal("clusterRadius"), method_27592, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_101), Reflex::Literal("clusterSeparation"), method_27593, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_3827), Reflex::Literal("hessian"), method_27594, 0, "hessianArray", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class PattRecoNode<reco::PattRecoPeak<double> > -------------------------------
static void destructor_28393(void*, void * o, const std::vector<void*>&, void *) {
(((::reco::PattRecoNode<reco::PattRecoPeak<double> >*)o)->::reco::PattRecoNode<reco::PattRecoPeak<double> >::~PattRecoNode)();
}
static  void operator_28394( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::reco::PattRecoNode<reco::PattRecoPeak<double> >*)o)->operator=)(*(const ::reco::PattRecoNode<reco::PattRecoPeak<double> >*)arg[0]);
  else   (((::reco::PattRecoNode<reco::PattRecoPeak<double> >*)o)->operator=)(*(const ::reco::PattRecoNode<reco::PattRecoPeak<double> >*)arg[0]);
}

static void constructor_28395( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::PattRecoNode<reco::PattRecoPeak<double> >(*(const ::reco::PattRecoNode<reco::PattRecoPeak<double> >*)arg[0]);
  else ::new(mem) ::reco::PattRecoNode<reco::PattRecoPeak<double> >(*(const ::reco::PattRecoNode<reco::PattRecoPeak<double> >*)arg[0]);
}

static void constructor_28396( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::PattRecoNode<reco::PattRecoPeak<double> >();
  else ::new(mem) ::reco::PattRecoNode<reco::PattRecoPeak<double> >();
}

static void constructor_28397( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::PattRecoNode<reco::PattRecoPeak<double> >(*(const ::reco::PattRecoPeak<double>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2],
      *(const unsigned int*)arg[3]);
  else ::new(mem) ::reco::PattRecoNode<reco::PattRecoPeak<double> >(*(const ::reco::PattRecoPeak<double>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2],
      *(const unsigned int*)arg[3]);
}

static  void method_28398( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::reco::PattRecoNode<reco::PattRecoPeak<double> >*)o)->getCluster)();
  else   (((const ::reco::PattRecoNode<reco::PattRecoPeak<double> >*)o)->getCluster)();
}

static  void method_28399( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::reco::PattRecoNode<reco::PattRecoPeak<double> >*)o)->originalLevel)());
  else   (((const ::reco::PattRecoNode<reco::PattRecoPeak<double> >*)o)->originalLevel)();
}

static  void method_28400( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::reco::PattRecoNode<reco::PattRecoPeak<double> >*)o)->mask)());
  else   (((const ::reco::PattRecoNode<reco::PattRecoPeak<double> >*)o)->mask)();
}

static  void method_28401( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::reco::PattRecoNode<reco::PattRecoPeak<double> >*)o)->parent)());
  else   (((const ::reco::PattRecoNode<reco::PattRecoPeak<double> >*)o)->parent)();
}

static void method_newdel_7891( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::reco::PattRecoNode<reco::PattRecoPeak<double> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::reco::PattRecoNode<reco::PattRecoPeak<double> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::reco::PattRecoNode<reco::PattRecoPeak<double> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::reco::PattRecoNode<reco::PattRecoPeak<double> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::reco::PattRecoNode<reco::PattRecoPeak<double> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class PattRecoNode<reco::PattRecoPeak<double> > -------------------------------
void __reco__PattRecoNode_reco__PattRecoPeak_double_s__db_datamem(Reflex::Class*);
void __reco__PattRecoNode_reco__PattRecoPeak_double_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __reco__PattRecoNode_reco__PattRecoPeak_double_s__datamem_bld(&__reco__PattRecoNode_reco__PattRecoPeak_double_s__db_datamem);
Reflex::GenreflexMemberBuilder __reco__PattRecoNode_reco__PattRecoPeak_double_s__funcmem_bld(&__reco__PattRecoNode_reco__PattRecoPeak_double_s__db_funcmem);
void __reco__PattRecoNode_reco__PattRecoPeak_double_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("reco::PattRecoNode<reco::PattRecoPeak<double> >"), typeid(::reco::PattRecoNode<reco::PattRecoPeak<double> >), sizeof(::reco::PattRecoNode<reco::PattRecoPeak<double> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PattRecoNode"), destructor_28393, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13951, type_13953), Reflex::Literal("operator="), operator_28394, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13953), Reflex::Literal("PattRecoNode"), constructor_28395, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PattRecoNode"), constructor_28396, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_40753, type_366c, type_366c, type_366c), Reflex::Literal("PattRecoNode"), constructor_28397, 0, "j;level;mask;parent", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_7891, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__reco__PattRecoNode_reco__PattRecoPeak_double_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__reco__PattRecoNode_reco__PattRecoPeak_double_s__funcmem_bld);
}

//------Delayed data member builder for class PattRecoNode<reco::PattRecoPeak<double> > -------------------
void __reco__PattRecoNode_reco__PattRecoPeak_double_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_7809, Reflex::Literal("jet_"), OffsetOf(__shadow__::__reco__PattRecoNode_reco__PattRecoPeak_double_s_, jet_), ::Reflex::PRIVATE)
  .AddDataMember(type_366, Reflex::Literal("originalLevel_"), OffsetOf(__shadow__::__reco__PattRecoNode_reco__PattRecoPeak_double_s_, originalLevel_), ::Reflex::PRIVATE)
  .AddDataMember(type_366, Reflex::Literal("nodeMask_"), OffsetOf(__shadow__::__reco__PattRecoNode_reco__PattRecoPeak_double_s_, nodeMask_), ::Reflex::PRIVATE)
  .AddDataMember(type_366, Reflex::Literal("parent_"), OffsetOf(__shadow__::__reco__PattRecoNode_reco__PattRecoPeak_double_s_, parent_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class PattRecoNode<reco::PattRecoPeak<double> > -------------------
void __reco__PattRecoNode_reco__PattRecoPeak_double_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_40753), Reflex::Literal("getCluster"), method_28398, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_366), Reflex::Literal("originalLevel"), method_28399, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_366), Reflex::Literal("mask"), method_28400, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_366), Reflex::Literal("parent"), method_28401, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class vector<reco::PattRecoNode<reco::PattRecoPeak<double> >,std::allocator<reco::PattRecoNode<reco::PattRecoPeak<double> > > > -------------------------------
static void constructor_13962( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >();
  else ::new(mem) ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >();
}

static void constructor_13963( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >(*(const ::std::allocator<reco::PattRecoNode<reco::PattRecoPeak<double> > >*)arg[0]);
  else ::new(mem) ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >(*(const ::std::allocator<reco::PattRecoNode<reco::PattRecoPeak<double> > >*)arg[0]);
}

static void constructor_13964( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >(*(::std::size_t*)arg[0],
      *(const ::reco::PattRecoNode<reco::PattRecoPeak<double> >*)arg[1]);
  else ::new(mem) ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >(*(::std::size_t*)arg[0],
      *(const ::reco::PattRecoNode<reco::PattRecoPeak<double> >*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >(*(::std::size_t*)arg[0],
      *(const ::reco::PattRecoNode<reco::PattRecoPeak<double> >*)arg[1],
      *(const ::std::allocator<reco::PattRecoNode<reco::PattRecoPeak<double> > >*)arg[2]);
  else ::new(mem) ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >(*(::std::size_t*)arg[0],
      *(const ::reco::PattRecoNode<reco::PattRecoPeak<double> >*)arg[1],
      *(const ::std::allocator<reco::PattRecoNode<reco::PattRecoPeak<double> > >*)arg[2]);
  }
}

static void constructor_13965( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >(*(const ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >*)arg[0]);
  else ::new(mem) ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >(*(const ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >*)arg[0]);
}

static void destructor_13966(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >*)o)->::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >::~vector)();
}
static  void operator_13967( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >*)o)->operator=)(*(const ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >*)arg[0]);
  else   (((::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >*)o)->operator=)(*(const ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >*)arg[0]);
}

static  void method_13968( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::reco::PattRecoNode<reco::PattRecoPeak<double> >*)arg[1]);
}

static  void method_13969( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::PattRecoNode<reco::PattRecoPeak<double> >*,std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > > >)((((::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >*)o)->begin)());
  else   (((::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >*)o)->begin)();
}

static  void method_13970( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const reco::PattRecoNode<reco::PattRecoPeak<double> >*,std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > > >)((((const ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >*)o)->begin)());
  else   (((const ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >*)o)->begin)();
}

static  void method_13971( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::PattRecoNode<reco::PattRecoPeak<double> >*,std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > > >)((((::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >*)o)->end)());
  else   (((::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >*)o)->end)();
}

static  void method_13972( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const reco::PattRecoNode<reco::PattRecoPeak<double> >*,std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > > >)((((const ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >*)o)->end)());
  else   (((const ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >*)o)->end)();
}

static  void method_13977( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >*)o)->size)());
  else   (((const ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >*)o)->size)();
}

static  void method_13978( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >*)o)->max_size)());
  else   (((const ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >*)o)->max_size)();
}

static  void method_13979( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::reco::PattRecoNode<reco::PattRecoPeak<double> >*)arg[1]);
  }
}

static  void method_13980( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >*)o)->capacity)());
  else   (((const ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >*)o)->capacity)();
}

static  void method_13981( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >*)o)->empty)());
  else   (((const ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >*)o)->empty)();
}

static  void method_13982( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_13983( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_13984( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_13986( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_13987( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_13988( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >*)o)->front)();
  else   (((::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >*)o)->front)();
}

static  void method_13989( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >*)o)->front)();
  else   (((const ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >*)o)->front)();
}

static  void method_13990( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >*)o)->back)();
  else   (((::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >*)o)->back)();
}

static  void method_13991( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >*)o)->back)();
  else   (((const ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >*)o)->back)();
}

static  void method_13992( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >*)o)->data)());
  else   (((::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >*)o)->data)();
}

static  void method_13993( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >*)o)->data)());
  else   (((const ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >*)o)->data)();
}

static  void method_13994( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >*)o)->push_back)(*(const ::reco::PattRecoNode<reco::PattRecoPeak<double> >*)arg[0]);
}

static  void method_13995( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >*)o)->pop_back)();
}

static  void method_13996( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::PattRecoNode<reco::PattRecoPeak<double> >*,std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > > >)((((::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<reco::PattRecoNode<reco::PattRecoPeak<double> >*,std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > > >*)arg[0],
    *(const ::reco::PattRecoNode<reco::PattRecoPeak<double> >*)arg[1]));
  else   (((::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<reco::PattRecoNode<reco::PattRecoPeak<double> >*,std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > > >*)arg[0],
    *(const ::reco::PattRecoNode<reco::PattRecoPeak<double> >*)arg[1]);
}

static  void method_13997( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<reco::PattRecoNode<reco::PattRecoPeak<double> >*,std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::reco::PattRecoNode<reco::PattRecoPeak<double> >*)arg[2]);
}

static  void method_13998( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::PattRecoNode<reco::PattRecoPeak<double> >*,std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > > >)((((::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::PattRecoNode<reco::PattRecoPeak<double> >*,std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > > >*)arg[0]));
  else   (((::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::PattRecoNode<reco::PattRecoPeak<double> >*,std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > > >*)arg[0]);
}

static  void method_13999( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::PattRecoNode<reco::PattRecoPeak<double> >*,std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > > >)((((::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::PattRecoNode<reco::PattRecoPeak<double> >*,std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<reco::PattRecoNode<reco::PattRecoPeak<double> >*,std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > > >*)arg[1]));
  else   (((::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::PattRecoNode<reco::PattRecoPeak<double> >*,std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<reco::PattRecoNode<reco::PattRecoPeak<double> >*,std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > > >*)arg[1]);
}

static  void method_14000( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >*)o)->swap)(*(::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >*)arg[0]);
}

static  void method_14001( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >*)o)->clear)();
}

static void method_newdel_2990( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x4( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<reco::PattRecoNode<reco::PattRecoPeak<double> >,std::allocator<reco::PattRecoNode<reco::PattRecoPeak<double> > > >")), ::Reflex::BaseOffset< ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >,::std::_Vector_base<reco::PattRecoNode<reco::PattRecoPeak<double> >,std::allocator<reco::PattRecoNode<reco::PattRecoPeak<double> > > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x5( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > > >::Generate();
  else ::Reflex::Proxy< ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > > >::Generate();
}

//------Dictionary for class vector<reco::PattRecoNode<reco::PattRecoPeak<double> >,std::allocator<reco::PattRecoNode<reco::PattRecoPeak<double> > > > -------------------------------
void __std__vector_reco__PattRecoNode_reco__PattRecoPeak_double_s_s__db_datamem(Reflex::Class*);
void __std__vector_reco__PattRecoNode_reco__PattRecoPeak_double_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_reco__PattRecoNode_reco__PattRecoPeak_double_s_s__datamem_bld(&__std__vector_reco__PattRecoNode_reco__PattRecoPeak_double_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_reco__PattRecoNode_reco__PattRecoPeak_double_s_s__funcmem_bld(&__std__vector_reco__PattRecoNode_reco__PattRecoPeak_double_s_s__db_funcmem);
void __std__vector_reco__PattRecoNode_reco__PattRecoPeak_double_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >"), typeid(::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >), sizeof(::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2488, ::Reflex::BaseOffset< ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >, ::std::_Vector_base<reco::PattRecoNode<reco::PattRecoPeak<double> >,std::allocator<reco::PattRecoNode<reco::PattRecoPeak<double> > > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_7891, Reflex::Literal("std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >::_Alloc_value_type"))
  .AddTypedef(type_2488, Reflex::Literal("std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >::_Base"))
  .AddTypedef(type_3297, Reflex::Literal("std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >::_Tp_alloc_type"))
  .AddTypedef(type_8468, Reflex::Literal("std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >::_Alloc_traits"))
  .AddTypedef(type_7891, Reflex::Literal("std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >::value_type"))
  .AddTypedef(type_9419, Reflex::Literal("std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >::pointer"))
  .AddTypedef(type_13949, Reflex::Literal("std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >::const_pointer"))
  .AddTypedef(type_13951, Reflex::Literal("std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >::reference"))
  .AddTypedef(type_13953, Reflex::Literal("std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >::const_reference"))
  .AddTypedef(type_8302, Reflex::Literal("std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >::iterator"))
  .AddTypedef(type_8303, Reflex::Literal("std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >::const_iterator"))
  .AddTypedef(type_3515, Reflex::Literal("std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >::const_reverse_iterator"))
  .AddTypedef(type_3516, Reflex::Literal("std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >::reverse_iterator"))
  .AddTypedef(type_3254, Reflex::Literal("std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >::size_type"))
  .AddTypedef(type_3138, Reflex::Literal("std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >::difference_type"))
  .AddTypedef(type_3297, Reflex::Literal("std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_13962, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_34584), Reflex::Literal("vector"), constructor_13963, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3254, type_13953, type_34584), Reflex::Literal("vector"), constructor_13964, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35973), Reflex::Literal("vector"), constructor_13965, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_13966, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2990, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x4, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x5, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_reco__PattRecoNode_reco__PattRecoPeak_double_s_s__funcmem_bld);
}

//------Delayed data member builder for class vector<reco::PattRecoNode<reco::PattRecoPeak<double> >,std::allocator<reco::PattRecoNode<reco::PattRecoPeak<double> > > > -------------------
void __std__vector_reco__PattRecoNode_reco__PattRecoPeak_double_s_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<reco::PattRecoNode<reco::PattRecoPeak<double> >,std::allocator<reco::PattRecoNode<reco::PattRecoPeak<double> > > > -------------------
void __std__vector_reco__PattRecoNode_reco__PattRecoPeak_double_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35974, type_35973), Reflex::Literal("operator="), operator_13967, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_3254, type_13953), Reflex::Literal("assign"), method_13968, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8302), Reflex::Literal("begin"), method_13969, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8303), Reflex::Literal("begin"), method_13970, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8302), Reflex::Literal("end"), method_13971, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8303), Reflex::Literal("end"), method_13972, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3254), Reflex::Literal("size"), method_13977, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3254), Reflex::Literal("max_size"), method_13978, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_3254, type_7891), Reflex::Literal("resize"), method_13979, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3254), Reflex::Literal("capacity"), method_13980, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("empty"), method_13981, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_3254), Reflex::Literal("reserve"), method_13982, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13951, type_3254), Reflex::Literal("operator[]"), operator_13983, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13953, type_3254), Reflex::Literal("operator[]"), operator_13984, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13951, type_3254), Reflex::Literal("at"), method_13986, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13953, type_3254), Reflex::Literal("at"), method_13987, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13951), Reflex::Literal("front"), method_13988, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13953), Reflex::Literal("front"), method_13989, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13951), Reflex::Literal("back"), method_13990, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13953), Reflex::Literal("back"), method_13991, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9419), Reflex::Literal("data"), method_13992, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13949), Reflex::Literal("data"), method_13993, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_13953), Reflex::Literal("push_back"), method_13994, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694), Reflex::Literal("pop_back"), method_13995, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8302, type_8302, type_13953), Reflex::Literal("insert"), method_13996, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_8302, type_3254, type_13953), Reflex::Literal("insert"), method_13997, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8302, type_8302), Reflex::Literal("erase"), method_13998, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8302, type_8302, type_8302), Reflex::Literal("erase"), method_13999, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_35974), Reflex::Literal("swap"), method_14000, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694), Reflex::Literal("clear"), method_14001, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class PattRecoPeak<float> -------------------------------
static void destructor_27608(void*, void * o, const std::vector<void*>&, void *) {
(((::reco::PattRecoPeak<float>*)o)->::reco::PattRecoPeak<float>::~PattRecoPeak)();
}
static  void operator_27609( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::reco::PattRecoPeak<float>*)o)->operator=)(*(const ::reco::PattRecoPeak<float>*)arg[0]);
  else   (((::reco::PattRecoPeak<float>*)o)->operator=)(*(const ::reco::PattRecoPeak<float>*)arg[0]);
}

static void constructor_27610( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::PattRecoPeak<float>(*(const ::reco::PattRecoPeak<float>*)arg[0]);
  else ::new(mem) ::reco::PattRecoPeak<float>(*(const ::reco::PattRecoPeak<float>*)arg[0]);
}

static void constructor_27611( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::PattRecoPeak<float>();
  else ::new(mem) ::reco::PattRecoPeak<float>();
}

static void constructor_27612( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::PattRecoPeak<float>(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      (const double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(double*)arg[9],
      *(double*)arg[10],
      *(double*)arg[11],
      *(double*)arg[12]);
  else ::new(mem) ::reco::PattRecoPeak<float>(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      (const double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(double*)arg[9],
      *(double*)arg[10],
      *(double*)arg[11],
      *(double*)arg[12]);
}

static  void method_27613( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::reco::PattRecoPeak<float>*)o)->eta)());
  else   (((const ::reco::PattRecoPeak<float>*)o)->eta)();
}

static  void method_27614( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::reco::PattRecoPeak<float>*)o)->phi)());
  else   (((const ::reco::PattRecoPeak<float>*)o)->phi)();
}

static  void method_27615( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::reco::PattRecoPeak<float>*)o)->magnitude)());
  else   (((const ::reco::PattRecoPeak<float>*)o)->magnitude)();
}

static  void method_27616( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::reco::PattRecoPeak<float>*)o)->driftSpeed)());
  else   (((const ::reco::PattRecoPeak<float>*)o)->driftSpeed)();
}

static  void method_27617( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::reco::PattRecoPeak<float>*)o)->magSpeed)());
  else   (((const ::reco::PattRecoPeak<float>*)o)->magSpeed)();
}

static  void method_27618( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::reco::PattRecoPeak<float>*)o)->lifetime)());
  else   (((const ::reco::PattRecoPeak<float>*)o)->lifetime)();
}

static  void method_27619( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::reco::PattRecoPeak<float>*)o)->splitTime)());
  else   (((const ::reco::PattRecoPeak<float>*)o)->splitTime)();
}

static  void method_27620( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::reco::PattRecoPeak<float>*)o)->mergeTime)());
  else   (((const ::reco::PattRecoPeak<float>*)o)->mergeTime)();
}

static  void method_27621( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::reco::PattRecoPeak<float>*)o)->scale)());
  else   (((const ::reco::PattRecoPeak<float>*)o)->scale)();
}

static  void method_27622( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::reco::PattRecoPeak<float>*)o)->nearestNeighborDistance)());
  else   (((const ::reco::PattRecoPeak<float>*)o)->nearestNeighborDistance)();
}

static  void method_27623( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::reco::PattRecoPeak<float>*)o)->clusterRadius)());
  else   (((const ::reco::PattRecoPeak<float>*)o)->clusterRadius)();
}

static  void method_27624( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::reco::PattRecoPeak<float>*)o)->clusterSeparation)());
  else   (((const ::reco::PattRecoPeak<float>*)o)->clusterSeparation)();
}

static  void method_27625( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::reco::PattRecoPeak<float>*)o)->hessian)((double*)arg[0]);
}

static void method_newdel_7810( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::reco::PattRecoPeak<float> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::reco::PattRecoPeak<float> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::reco::PattRecoPeak<float> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::reco::PattRecoPeak<float> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::reco::PattRecoPeak<float> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class PattRecoPeak<float> -------------------------------
void __reco__PattRecoPeak_float__db_datamem(Reflex::Class*);
void __reco__PattRecoPeak_float__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __reco__PattRecoPeak_float__datamem_bld(&__reco__PattRecoPeak_float__db_datamem);
Reflex::GenreflexMemberBuilder __reco__PattRecoPeak_float__funcmem_bld(&__reco__PattRecoPeak_float__db_funcmem);
void __reco__PattRecoPeak_float__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("reco::PattRecoPeak<float>"), typeid(::reco::PattRecoPeak<float>), sizeof(::reco::PattRecoPeak<float>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PattRecoPeak"), destructor_27608, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_40755, type_40756), Reflex::Literal("operator="), operator_27609, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_40756), Reflex::Literal("PattRecoPeak"), constructor_27610, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PattRecoPeak"), constructor_27611, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_101, type_101, type_101, type_3829, type_101, type_101, type_101, type_101, type_101, type_101, type_101, type_101, type_101), Reflex::Literal("PattRecoPeak"), constructor_27612, 0, "eta;phi;mag;hessianIn;driftSpeed;magSpeed;lifetime;scale;nearestDistance;clusterRadius;clusterSeparation;splitT;mergeT", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_7810, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__reco__PattRecoPeak_float__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__reco__PattRecoPeak_float__funcmem_bld);
}

//------Delayed data member builder for class PattRecoPeak<float> -------------------
void __reco__PattRecoPeak_float__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_894, Reflex::Literal("eta_"), OffsetOf(__shadow__::__reco__PattRecoPeak_float_, eta_), ::Reflex::PRIVATE)
  .AddDataMember(type_894, Reflex::Literal("phi_"), OffsetOf(__shadow__::__reco__PattRecoPeak_float_, phi_), ::Reflex::PRIVATE)
  .AddDataMember(type_894, Reflex::Literal("magnitude_"), OffsetOf(__shadow__::__reco__PattRecoPeak_float_, magnitude_), ::Reflex::PRIVATE)
  .AddDataMember(type_894, Reflex::Literal("speed_"), OffsetOf(__shadow__::__reco__PattRecoPeak_float_, speed_), ::Reflex::PRIVATE)
  .AddDataMember(type_894, Reflex::Literal("magSpeed_"), OffsetOf(__shadow__::__reco__PattRecoPeak_float_, magSpeed_), ::Reflex::PRIVATE)
  .AddDataMember(type_894, Reflex::Literal("lifetime_"), OffsetOf(__shadow__::__reco__PattRecoPeak_float_, lifetime_), ::Reflex::PRIVATE)
  .AddDataMember(type_894, Reflex::Literal("scale_"), OffsetOf(__shadow__::__reco__PattRecoPeak_float_, scale_), ::Reflex::PRIVATE)
  .AddDataMember(type_894, Reflex::Literal("nearestD_"), OffsetOf(__shadow__::__reco__PattRecoPeak_float_, nearestD_), ::Reflex::PRIVATE)
  .AddDataMember(type_894, Reflex::Literal("clusterRadius_"), OffsetOf(__shadow__::__reco__PattRecoPeak_float_, clusterRadius_), ::Reflex::PRIVATE)
  .AddDataMember(type_894, Reflex::Literal("clusterSeparation_"), OffsetOf(__shadow__::__reco__PattRecoPeak_float_, clusterSeparation_), ::Reflex::PRIVATE)
  .AddDataMember(type_40754, Reflex::Literal("hessian_"), OffsetOf(__shadow__::__reco__PattRecoPeak_float_, hessian_), ::Reflex::PRIVATE)
  .AddDataMember(type_894, Reflex::Literal("splitTime_"), OffsetOf(__shadow__::__reco__PattRecoPeak_float_, splitTime_), ::Reflex::PRIVATE)
  .AddDataMember(type_894, Reflex::Literal("mergeTime_"), OffsetOf(__shadow__::__reco__PattRecoPeak_float_, mergeTime_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class PattRecoPeak<float> -------------------
void __reco__PattRecoPeak_float__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_894), Reflex::Literal("eta"), method_27613, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_894), Reflex::Literal("phi"), method_27614, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_894), Reflex::Literal("magnitude"), method_27615, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_894), Reflex::Literal("driftSpeed"), method_27616, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_894), Reflex::Literal("magSpeed"), method_27617, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_894), Reflex::Literal("lifetime"), method_27618, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_894), Reflex::Literal("splitTime"), method_27619, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_894), Reflex::Literal("mergeTime"), method_27620, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_894), Reflex::Literal("scale"), method_27621, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_894), Reflex::Literal("nearestNeighborDistance"), method_27622, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_894), Reflex::Literal("clusterRadius"), method_27623, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_894), Reflex::Literal("clusterSeparation"), method_27624, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_3827), Reflex::Literal("hessian"), method_27625, 0, "hessianArray", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class PattRecoNode<reco::PattRecoPeak<float> > -------------------------------
static void destructor_28406(void*, void * o, const std::vector<void*>&, void *) {
(((::reco::PattRecoNode<reco::PattRecoPeak<float> >*)o)->::reco::PattRecoNode<reco::PattRecoPeak<float> >::~PattRecoNode)();
}
static  void operator_28407( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::reco::PattRecoNode<reco::PattRecoPeak<float> >*)o)->operator=)(*(const ::reco::PattRecoNode<reco::PattRecoPeak<float> >*)arg[0]);
  else   (((::reco::PattRecoNode<reco::PattRecoPeak<float> >*)o)->operator=)(*(const ::reco::PattRecoNode<reco::PattRecoPeak<float> >*)arg[0]);
}

static void constructor_28408( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::PattRecoNode<reco::PattRecoPeak<float> >(*(const ::reco::PattRecoNode<reco::PattRecoPeak<float> >*)arg[0]);
  else ::new(mem) ::reco::PattRecoNode<reco::PattRecoPeak<float> >(*(const ::reco::PattRecoNode<reco::PattRecoPeak<float> >*)arg[0]);
}

static void constructor_28409( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::PattRecoNode<reco::PattRecoPeak<float> >();
  else ::new(mem) ::reco::PattRecoNode<reco::PattRecoPeak<float> >();
}

static void constructor_28410( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::PattRecoNode<reco::PattRecoPeak<float> >(*(const ::reco::PattRecoPeak<float>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2],
      *(const unsigned int*)arg[3]);
  else ::new(mem) ::reco::PattRecoNode<reco::PattRecoPeak<float> >(*(const ::reco::PattRecoPeak<float>*)arg[0],
      *(const unsigned int*)arg[1],
      *(const unsigned int*)arg[2],
      *(const unsigned int*)arg[3]);
}

static  void method_28411( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::reco::PattRecoNode<reco::PattRecoPeak<float> >*)o)->getCluster)();
  else   (((const ::reco::PattRecoNode<reco::PattRecoPeak<float> >*)o)->getCluster)();
}

static  void method_28412( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::reco::PattRecoNode<reco::PattRecoPeak<float> >*)o)->originalLevel)());
  else   (((const ::reco::PattRecoNode<reco::PattRecoPeak<float> >*)o)->originalLevel)();
}

static  void method_28413( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::reco::PattRecoNode<reco::PattRecoPeak<float> >*)o)->mask)());
  else   (((const ::reco::PattRecoNode<reco::PattRecoPeak<float> >*)o)->mask)();
}

static  void method_28414( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::reco::PattRecoNode<reco::PattRecoPeak<float> >*)o)->parent)());
  else   (((const ::reco::PattRecoNode<reco::PattRecoPeak<float> >*)o)->parent)();
}

static void method_newdel_7892( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::reco::PattRecoNode<reco::PattRecoPeak<float> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::reco::PattRecoNode<reco::PattRecoPeak<float> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::reco::PattRecoNode<reco::PattRecoPeak<float> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::reco::PattRecoNode<reco::PattRecoPeak<float> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::reco::PattRecoNode<reco::PattRecoPeak<float> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class PattRecoNode<reco::PattRecoPeak<float> > -------------------------------
void __reco__PattRecoNode_reco__PattRecoPeak_float_s__db_datamem(Reflex::Class*);
void __reco__PattRecoNode_reco__PattRecoPeak_float_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __reco__PattRecoNode_reco__PattRecoPeak_float_s__datamem_bld(&__reco__PattRecoNode_reco__PattRecoPeak_float_s__db_datamem);
Reflex::GenreflexMemberBuilder __reco__PattRecoNode_reco__PattRecoPeak_float_s__funcmem_bld(&__reco__PattRecoNode_reco__PattRecoPeak_float_s__db_funcmem);
void __reco__PattRecoNode_reco__PattRecoPeak_float_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("reco::PattRecoNode<reco::PattRecoPeak<float> >"), typeid(::reco::PattRecoNode<reco::PattRecoPeak<float> >), sizeof(::reco::PattRecoNode<reco::PattRecoPeak<float> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PattRecoNode"), destructor_28406, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14081, type_14083), Reflex::Literal("operator="), operator_28407, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_14083), Reflex::Literal("PattRecoNode"), constructor_28408, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PattRecoNode"), constructor_28409, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_40756, type_366c, type_366c, type_366c), Reflex::Literal("PattRecoNode"), constructor_28410, 0, "j;level;mask;parent", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_7892, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__reco__PattRecoNode_reco__PattRecoPeak_float_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__reco__PattRecoNode_reco__PattRecoPeak_float_s__funcmem_bld);
}

//------Delayed data member builder for class PattRecoNode<reco::PattRecoPeak<float> > -------------------
void __reco__PattRecoNode_reco__PattRecoPeak_float_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_7810, Reflex::Literal("jet_"), OffsetOf(__shadow__::__reco__PattRecoNode_reco__PattRecoPeak_float_s_, jet_), ::Reflex::PRIVATE)
  .AddDataMember(type_366, Reflex::Literal("originalLevel_"), OffsetOf(__shadow__::__reco__PattRecoNode_reco__PattRecoPeak_float_s_, originalLevel_), ::Reflex::PRIVATE)
  .AddDataMember(type_366, Reflex::Literal("nodeMask_"), OffsetOf(__shadow__::__reco__PattRecoNode_reco__PattRecoPeak_float_s_, nodeMask_), ::Reflex::PRIVATE)
  .AddDataMember(type_366, Reflex::Literal("parent_"), OffsetOf(__shadow__::__reco__PattRecoNode_reco__PattRecoPeak_float_s_, parent_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class PattRecoNode<reco::PattRecoPeak<float> > -------------------
void __reco__PattRecoNode_reco__PattRecoPeak_float_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_40756), Reflex::Literal("getCluster"), method_28411, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_366), Reflex::Literal("originalLevel"), method_28412, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_366), Reflex::Literal("mask"), method_28413, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_366), Reflex::Literal("parent"), method_28414, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class vector<reco::PattRecoNode<reco::PattRecoPeak<float> >,std::allocator<reco::PattRecoNode<reco::PattRecoPeak<float> > > > -------------------------------
static void constructor_14092( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >();
  else ::new(mem) ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >();
}

static void constructor_14093( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >(*(const ::std::allocator<reco::PattRecoNode<reco::PattRecoPeak<float> > >*)arg[0]);
  else ::new(mem) ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >(*(const ::std::allocator<reco::PattRecoNode<reco::PattRecoPeak<float> > >*)arg[0]);
}

static void constructor_14094( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >(*(::std::size_t*)arg[0],
      *(const ::reco::PattRecoNode<reco::PattRecoPeak<float> >*)arg[1]);
  else ::new(mem) ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >(*(::std::size_t*)arg[0],
      *(const ::reco::PattRecoNode<reco::PattRecoPeak<float> >*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >(*(::std::size_t*)arg[0],
      *(const ::reco::PattRecoNode<reco::PattRecoPeak<float> >*)arg[1],
      *(const ::std::allocator<reco::PattRecoNode<reco::PattRecoPeak<float> > >*)arg[2]);
  else ::new(mem) ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >(*(::std::size_t*)arg[0],
      *(const ::reco::PattRecoNode<reco::PattRecoPeak<float> >*)arg[1],
      *(const ::std::allocator<reco::PattRecoNode<reco::PattRecoPeak<float> > >*)arg[2]);
  }
}

static void constructor_14095( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >(*(const ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >*)arg[0]);
  else ::new(mem) ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >(*(const ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >*)arg[0]);
}

static void destructor_14096(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >*)o)->::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >::~vector)();
}
static  void operator_14097( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >*)o)->operator=)(*(const ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >*)arg[0]);
  else   (((::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >*)o)->operator=)(*(const ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >*)arg[0]);
}

static  void method_14098( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::reco::PattRecoNode<reco::PattRecoPeak<float> >*)arg[1]);
}

static  void method_14099( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::PattRecoNode<reco::PattRecoPeak<float> >*,std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > > >)((((::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >*)o)->begin)());
  else   (((::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >*)o)->begin)();
}

static  void method_14100( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const reco::PattRecoNode<reco::PattRecoPeak<float> >*,std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > > >)((((const ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >*)o)->begin)());
  else   (((const ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >*)o)->begin)();
}

static  void method_14101( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::PattRecoNode<reco::PattRecoPeak<float> >*,std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > > >)((((::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >*)o)->end)());
  else   (((::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >*)o)->end)();
}

static  void method_14102( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const reco::PattRecoNode<reco::PattRecoPeak<float> >*,std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > > >)((((const ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >*)o)->end)());
  else   (((const ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >*)o)->end)();
}

static  void method_14107( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >*)o)->size)());
  else   (((const ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >*)o)->size)();
}

static  void method_14108( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >*)o)->max_size)());
  else   (((const ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >*)o)->max_size)();
}

static  void method_14109( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::reco::PattRecoNode<reco::PattRecoPeak<float> >*)arg[1]);
  }
}

static  void method_14110( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >*)o)->capacity)());
  else   (((const ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >*)o)->capacity)();
}

static  void method_14111( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >*)o)->empty)());
  else   (((const ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >*)o)->empty)();
}

static  void method_14112( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_14113( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_14114( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_14116( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_14117( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_14118( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >*)o)->front)();
  else   (((::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >*)o)->front)();
}

static  void method_14119( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >*)o)->front)();
  else   (((const ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >*)o)->front)();
}

static  void method_14120( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >*)o)->back)();
  else   (((::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >*)o)->back)();
}

static  void method_14121( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >*)o)->back)();
  else   (((const ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >*)o)->back)();
}

static  void method_14122( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >*)o)->data)());
  else   (((::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >*)o)->data)();
}

static  void method_14123( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >*)o)->data)());
  else   (((const ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >*)o)->data)();
}

static  void method_14124( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >*)o)->push_back)(*(const ::reco::PattRecoNode<reco::PattRecoPeak<float> >*)arg[0]);
}

static  void method_14125( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >*)o)->pop_back)();
}

static  void method_14126( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::PattRecoNode<reco::PattRecoPeak<float> >*,std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > > >)((((::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<reco::PattRecoNode<reco::PattRecoPeak<float> >*,std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > > >*)arg[0],
    *(const ::reco::PattRecoNode<reco::PattRecoPeak<float> >*)arg[1]));
  else   (((::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<reco::PattRecoNode<reco::PattRecoPeak<float> >*,std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > > >*)arg[0],
    *(const ::reco::PattRecoNode<reco::PattRecoPeak<float> >*)arg[1]);
}

static  void method_14127( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<reco::PattRecoNode<reco::PattRecoPeak<float> >*,std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::reco::PattRecoNode<reco::PattRecoPeak<float> >*)arg[2]);
}

static  void method_14128( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::PattRecoNode<reco::PattRecoPeak<float> >*,std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > > >)((((::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::PattRecoNode<reco::PattRecoPeak<float> >*,std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > > >*)arg[0]));
  else   (((::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::PattRecoNode<reco::PattRecoPeak<float> >*,std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > > >*)arg[0]);
}

static  void method_14129( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::PattRecoNode<reco::PattRecoPeak<float> >*,std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > > >)((((::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::PattRecoNode<reco::PattRecoPeak<float> >*,std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<reco::PattRecoNode<reco::PattRecoPeak<float> >*,std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > > >*)arg[1]));
  else   (((::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::PattRecoNode<reco::PattRecoPeak<float> >*,std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<reco::PattRecoNode<reco::PattRecoPeak<float> >*,std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > > >*)arg[1]);
}

static  void method_14130( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >*)o)->swap)(*(::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >*)arg[0]);
}

static  void method_14131( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >*)o)->clear)();
}

static void method_newdel_2992( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x9( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<reco::PattRecoNode<reco::PattRecoPeak<float> >,std::allocator<reco::PattRecoNode<reco::PattRecoPeak<float> > > >")), ::Reflex::BaseOffset< ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >,::std::_Vector_base<reco::PattRecoNode<reco::PattRecoPeak<float> >,std::allocator<reco::PattRecoNode<reco::PattRecoPeak<float> > > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x10( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > > >::Generate();
  else ::Reflex::Proxy< ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > > >::Generate();
}

//------Dictionary for class vector<reco::PattRecoNode<reco::PattRecoPeak<float> >,std::allocator<reco::PattRecoNode<reco::PattRecoPeak<float> > > > -------------------------------
void __std__vector_reco__PattRecoNode_reco__PattRecoPeak_float_s_s__db_datamem(Reflex::Class*);
void __std__vector_reco__PattRecoNode_reco__PattRecoPeak_float_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_reco__PattRecoNode_reco__PattRecoPeak_float_s_s__datamem_bld(&__std__vector_reco__PattRecoNode_reco__PattRecoPeak_float_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_reco__PattRecoNode_reco__PattRecoPeak_float_s_s__funcmem_bld(&__std__vector_reco__PattRecoNode_reco__PattRecoPeak_float_s_s__db_funcmem);
void __std__vector_reco__PattRecoNode_reco__PattRecoPeak_float_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >"), typeid(::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >), sizeof(::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2489, ::Reflex::BaseOffset< ::std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >, ::std::_Vector_base<reco::PattRecoNode<reco::PattRecoPeak<float> >,std::allocator<reco::PattRecoNode<reco::PattRecoPeak<float> > > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_7892, Reflex::Literal("std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >::_Alloc_value_type"))
  .AddTypedef(type_2489, Reflex::Literal("std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >::_Base"))
  .AddTypedef(type_3299, Reflex::Literal("std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >::_Tp_alloc_type"))
  .AddTypedef(type_8469, Reflex::Literal("std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >::_Alloc_traits"))
  .AddTypedef(type_7892, Reflex::Literal("std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >::value_type"))
  .AddTypedef(type_9438, Reflex::Literal("std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >::pointer"))
  .AddTypedef(type_14079, Reflex::Literal("std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >::const_pointer"))
  .AddTypedef(type_14081, Reflex::Literal("std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >::reference"))
  .AddTypedef(type_14083, Reflex::Literal("std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >::const_reference"))
  .AddTypedef(type_8304, Reflex::Literal("std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >::iterator"))
  .AddTypedef(type_8305, Reflex::Literal("std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >::const_iterator"))
  .AddTypedef(type_3517, Reflex::Literal("std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >::const_reverse_iterator"))
  .AddTypedef(type_3518, Reflex::Literal("std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >::reverse_iterator"))
  .AddTypedef(type_3254, Reflex::Literal("std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >::size_type"))
  .AddTypedef(type_3138, Reflex::Literal("std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >::difference_type"))
  .AddTypedef(type_3299, Reflex::Literal("std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_14092, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_34597), Reflex::Literal("vector"), constructor_14093, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3254, type_14083, type_34597), Reflex::Literal("vector"), constructor_14094, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35979), Reflex::Literal("vector"), constructor_14095, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_14096, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2992, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x9, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x10, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_reco__PattRecoNode_reco__PattRecoPeak_float_s_s__funcmem_bld);
}

//------Delayed data member builder for class vector<reco::PattRecoNode<reco::PattRecoPeak<float> >,std::allocator<reco::PattRecoNode<reco::PattRecoPeak<float> > > > -------------------
void __std__vector_reco__PattRecoNode_reco__PattRecoPeak_float_s_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<reco::PattRecoNode<reco::PattRecoPeak<float> >,std::allocator<reco::PattRecoNode<reco::PattRecoPeak<float> > > > -------------------
void __std__vector_reco__PattRecoNode_reco__PattRecoPeak_float_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35980, type_35979), Reflex::Literal("operator="), operator_14097, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_3254, type_14083), Reflex::Literal("assign"), method_14098, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8304), Reflex::Literal("begin"), method_14099, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8305), Reflex::Literal("begin"), method_14100, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8304), Reflex::Literal("end"), method_14101, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8305), Reflex::Literal("end"), method_14102, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3254), Reflex::Literal("size"), method_14107, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3254), Reflex::Literal("max_size"), method_14108, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_3254, type_7892), Reflex::Literal("resize"), method_14109, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3254), Reflex::Literal("capacity"), method_14110, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("empty"), method_14111, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_3254), Reflex::Literal("reserve"), method_14112, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14081, type_3254), Reflex::Literal("operator[]"), operator_14113, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14083, type_3254), Reflex::Literal("operator[]"), operator_14114, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14081, type_3254), Reflex::Literal("at"), method_14116, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14083, type_3254), Reflex::Literal("at"), method_14117, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14081), Reflex::Literal("front"), method_14118, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14083), Reflex::Literal("front"), method_14119, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14081), Reflex::Literal("back"), method_14120, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14083), Reflex::Literal("back"), method_14121, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9438), Reflex::Literal("data"), method_14122, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14079), Reflex::Literal("data"), method_14123, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_14083), Reflex::Literal("push_back"), method_14124, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694), Reflex::Literal("pop_back"), method_14125, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8304, type_8304, type_14083), Reflex::Literal("insert"), method_14126, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_8304, type_3254, type_14083), Reflex::Literal("insert"), method_14127, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8304, type_8304), Reflex::Literal("erase"), method_14128, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8304, type_8304, type_8304), Reflex::Literal("erase"), method_14129, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_35980), Reflex::Literal("swap"), method_14130, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694), Reflex::Literal("clear"), method_14131, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class TrackExtrapolation -------------------------------
static  void operator_27415( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::reco::TrackExtrapolation*)o)->operator=)(*(const ::reco::TrackExtrapolation*)arg[0]);
  else   (((::reco::TrackExtrapolation*)o)->operator=)(*(const ::reco::TrackExtrapolation*)arg[0]);
}

static void constructor_27416( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::TrackExtrapolation(*(const ::reco::TrackExtrapolation*)arg[0]);
  else ::new(mem) ::reco::TrackExtrapolation(*(const ::reco::TrackExtrapolation*)arg[0]);
}

static void constructor_27417( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::TrackExtrapolation();
  else ::new(mem) ::reco::TrackExtrapolation();
}

static void constructor_27418( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::TrackExtrapolation(*(const ::reco::TrackRef*)arg[0],
      *(const ::std::vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >*)arg[1],
      *(const ::std::vector<ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >*)arg[2]);
  else ::new(mem) ::reco::TrackExtrapolation(*(const ::reco::TrackRef*)arg[0],
      *(const ::std::vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >*)arg[1],
      *(const ::std::vector<ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >*)arg[2]);
}

static void destructor_27419(void*, void * o, const std::vector<void*>&, void *) {
(((::reco::TrackExtrapolation*)o)->::reco::TrackExtrapolation::~TrackExtrapolation)();
}
static  void method_27420( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::reco::TrackExtrapolation*)o)->track)();
  else   (((const ::reco::TrackExtrapolation*)o)->track)();
}

static  void method_27421( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::reco::TrackExtrapolation*)o)->positions)();
  else   (((const ::reco::TrackExtrapolation*)o)->positions)();
}

static  void method_27422( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::reco::TrackExtrapolation*)o)->momenta)();
  else   (((const ::reco::TrackExtrapolation*)o)->momenta)();
}

static void method_newdel_7787( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::reco::TrackExtrapolation >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::reco::TrackExtrapolation >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::reco::TrackExtrapolation >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::reco::TrackExtrapolation >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::reco::TrackExtrapolation >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class TrackExtrapolation -------------------------------
void __reco__TrackExtrapolation_db_datamem(Reflex::Class*);
void __reco__TrackExtrapolation_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __reco__TrackExtrapolation_datamem_bld(&__reco__TrackExtrapolation_db_datamem);
Reflex::GenreflexMemberBuilder __reco__TrackExtrapolation_funcmem_bld(&__reco__TrackExtrapolation_db_funcmem);
void __reco__TrackExtrapolation_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("reco::TrackExtrapolation"), typeid(::reco::TrackExtrapolation), sizeof(::reco::TrackExtrapolation), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddTypedef(type_6775, Reflex::Literal("reco::TrackExtrapolation::Point"))
  .AddTypedef(type_6781, Reflex::Literal("reco::TrackExtrapolation::Vector"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14146, type_14148), Reflex::Literal("operator="), operator_27415, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_14148), Reflex::Literal("TrackExtrapolation"), constructor_27416, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TrackExtrapolation"), constructor_27417, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_40740, type_36090, type_36088), Reflex::Literal("TrackExtrapolation"), constructor_27418, 0, "track;pos;mom", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TrackExtrapolation"), destructor_27419, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_7787, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__reco__TrackExtrapolation_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__reco__TrackExtrapolation_funcmem_bld);
}

//------Delayed data member builder for class TrackExtrapolation -------------------
void __reco__TrackExtrapolation_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_7857, Reflex::Literal("track_"), OffsetOf(__shadow__::__reco__TrackExtrapolation, track_), ::Reflex::PROTECTED)
  .AddDataMember(type_3008, Reflex::Literal("pos_"), OffsetOf(__shadow__::__reco__TrackExtrapolation, pos_), ::Reflex::PROTECTED)
  .AddDataMember(type_3007, Reflex::Literal("mom_"), OffsetOf(__shadow__::__reco__TrackExtrapolation, mom_), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class TrackExtrapolation -------------------
void __reco__TrackExtrapolation_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_40740), Reflex::Literal("track"), method_27420, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_36090), Reflex::Literal("positions"), method_27421, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_36088), Reflex::Literal("momenta"), method_27422, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class vector<reco::TrackExtrapolation,std::allocator<reco::TrackExtrapolation> > -------------------------------
static void constructor_14157( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::TrackExtrapolation>();
  else ::new(mem) ::std::vector<reco::TrackExtrapolation>();
}

static void constructor_14158( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::TrackExtrapolation>(*(const ::std::allocator<reco::TrackExtrapolation>*)arg[0]);
  else ::new(mem) ::std::vector<reco::TrackExtrapolation>(*(const ::std::allocator<reco::TrackExtrapolation>*)arg[0]);
}

static void constructor_14159( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::TrackExtrapolation>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<reco::TrackExtrapolation>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::TrackExtrapolation>(*(::std::size_t*)arg[0],
      *(const ::reco::TrackExtrapolation*)arg[1]);
  else ::new(mem) ::std::vector<reco::TrackExtrapolation>(*(::std::size_t*)arg[0],
      *(const ::reco::TrackExtrapolation*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::TrackExtrapolation>(*(::std::size_t*)arg[0],
      *(const ::reco::TrackExtrapolation*)arg[1],
      *(const ::std::allocator<reco::TrackExtrapolation>*)arg[2]);
  else ::new(mem) ::std::vector<reco::TrackExtrapolation>(*(::std::size_t*)arg[0],
      *(const ::reco::TrackExtrapolation*)arg[1],
      *(const ::std::allocator<reco::TrackExtrapolation>*)arg[2]);
  }
}

static void constructor_14160( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::TrackExtrapolation>(*(const ::std::vector<reco::TrackExtrapolation>*)arg[0]);
  else ::new(mem) ::std::vector<reco::TrackExtrapolation>(*(const ::std::vector<reco::TrackExtrapolation>*)arg[0]);
}

static void destructor_14161(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<reco::TrackExtrapolation>*)o)->::std::vector<reco::TrackExtrapolation>::~vector)();
}
static  void operator_14162( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::TrackExtrapolation>*)o)->operator=)(*(const ::std::vector<reco::TrackExtrapolation>*)arg[0]);
  else   (((::std::vector<reco::TrackExtrapolation>*)o)->operator=)(*(const ::std::vector<reco::TrackExtrapolation>*)arg[0]);
}

static  void method_14163( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::TrackExtrapolation>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::reco::TrackExtrapolation*)arg[1]);
}

static  void method_14164( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::TrackExtrapolation*,std::vector<reco::TrackExtrapolation> >)((((::std::vector<reco::TrackExtrapolation>*)o)->begin)());
  else   (((::std::vector<reco::TrackExtrapolation>*)o)->begin)();
}

static  void method_14165( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const reco::TrackExtrapolation*,std::vector<reco::TrackExtrapolation> >)((((const ::std::vector<reco::TrackExtrapolation>*)o)->begin)());
  else   (((const ::std::vector<reco::TrackExtrapolation>*)o)->begin)();
}

static  void method_14166( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::TrackExtrapolation*,std::vector<reco::TrackExtrapolation> >)((((::std::vector<reco::TrackExtrapolation>*)o)->end)());
  else   (((::std::vector<reco::TrackExtrapolation>*)o)->end)();
}

static  void method_14167( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const reco::TrackExtrapolation*,std::vector<reco::TrackExtrapolation> >)((((const ::std::vector<reco::TrackExtrapolation>*)o)->end)());
  else   (((const ::std::vector<reco::TrackExtrapolation>*)o)->end)();
}

static  void method_14172( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<reco::TrackExtrapolation>*)o)->size)());
  else   (((const ::std::vector<reco::TrackExtrapolation>*)o)->size)();
}

static  void method_14173( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<reco::TrackExtrapolation>*)o)->max_size)());
  else   (((const ::std::vector<reco::TrackExtrapolation>*)o)->max_size)();
}

static  void method_14174( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<reco::TrackExtrapolation>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<reco::TrackExtrapolation>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::reco::TrackExtrapolation*)arg[1]);
  }
}

static  void method_14175( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<reco::TrackExtrapolation>*)o)->capacity)());
  else   (((const ::std::vector<reco::TrackExtrapolation>*)o)->capacity)();
}

static  void method_14176( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<reco::TrackExtrapolation>*)o)->empty)());
  else   (((const ::std::vector<reco::TrackExtrapolation>*)o)->empty)();
}

static  void method_14177( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::TrackExtrapolation>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_14178( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::TrackExtrapolation>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<reco::TrackExtrapolation>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_14179( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::TrackExtrapolation>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<reco::TrackExtrapolation>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_14181( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::TrackExtrapolation>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<reco::TrackExtrapolation>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_14182( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::TrackExtrapolation>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<reco::TrackExtrapolation>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_14183( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::TrackExtrapolation>*)o)->front)();
  else   (((::std::vector<reco::TrackExtrapolation>*)o)->front)();
}

static  void method_14184( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::TrackExtrapolation>*)o)->front)();
  else   (((const ::std::vector<reco::TrackExtrapolation>*)o)->front)();
}

static  void method_14185( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::TrackExtrapolation>*)o)->back)();
  else   (((::std::vector<reco::TrackExtrapolation>*)o)->back)();
}

static  void method_14186( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::TrackExtrapolation>*)o)->back)();
  else   (((const ::std::vector<reco::TrackExtrapolation>*)o)->back)();
}

static  void method_14187( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<reco::TrackExtrapolation>*)o)->data)());
  else   (((::std::vector<reco::TrackExtrapolation>*)o)->data)();
}

static  void method_14188( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<reco::TrackExtrapolation>*)o)->data)());
  else   (((const ::std::vector<reco::TrackExtrapolation>*)o)->data)();
}

static  void method_14189( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::TrackExtrapolation>*)o)->push_back)(*(const ::reco::TrackExtrapolation*)arg[0]);
}

static  void method_14190( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<reco::TrackExtrapolation>*)o)->pop_back)();
}

static  void method_14191( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::TrackExtrapolation*,std::vector<reco::TrackExtrapolation> >)((((::std::vector<reco::TrackExtrapolation>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<reco::TrackExtrapolation*,std::vector<reco::TrackExtrapolation> >*)arg[0],
    *(const ::reco::TrackExtrapolation*)arg[1]));
  else   (((::std::vector<reco::TrackExtrapolation>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<reco::TrackExtrapolation*,std::vector<reco::TrackExtrapolation> >*)arg[0],
    *(const ::reco::TrackExtrapolation*)arg[1]);
}

static  void method_14192( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::TrackExtrapolation>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<reco::TrackExtrapolation*,std::vector<reco::TrackExtrapolation> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::reco::TrackExtrapolation*)arg[2]);
}

static  void method_14193( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::TrackExtrapolation*,std::vector<reco::TrackExtrapolation> >)((((::std::vector<reco::TrackExtrapolation>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::TrackExtrapolation*,std::vector<reco::TrackExtrapolation> >*)arg[0]));
  else   (((::std::vector<reco::TrackExtrapolation>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::TrackExtrapolation*,std::vector<reco::TrackExtrapolation> >*)arg[0]);
}

static  void method_14194( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::TrackExtrapolation*,std::vector<reco::TrackExtrapolation> >)((((::std::vector<reco::TrackExtrapolation>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::TrackExtrapolation*,std::vector<reco::TrackExtrapolation> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<reco::TrackExtrapolation*,std::vector<reco::TrackExtrapolation> >*)arg[1]));
  else   (((::std::vector<reco::TrackExtrapolation>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::TrackExtrapolation*,std::vector<reco::TrackExtrapolation> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<reco::TrackExtrapolation*,std::vector<reco::TrackExtrapolation> >*)arg[1]);
}

static  void method_14195( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::TrackExtrapolation>*)o)->swap)(*(::std::vector<reco::TrackExtrapolation>*)arg[0]);
}

static  void method_14196( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<reco::TrackExtrapolation>*)o)->clear)();
}

static void method_newdel_2993( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<reco::TrackExtrapolation> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<reco::TrackExtrapolation> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<reco::TrackExtrapolation> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<reco::TrackExtrapolation> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<reco::TrackExtrapolation> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x13( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<reco::TrackExtrapolation,std::allocator<reco::TrackExtrapolation> >")), ::Reflex::BaseOffset< ::std::vector<reco::TrackExtrapolation>,::std::_Vector_base<reco::TrackExtrapolation,std::allocator<reco::TrackExtrapolation> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x14( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<reco::TrackExtrapolation> >::Generate();
  else ::Reflex::Proxy< ::std::vector<reco::TrackExtrapolation> >::Generate();
}

//------Dictionary for class vector<reco::TrackExtrapolation,std::allocator<reco::TrackExtrapolation> > -------------------------------
void __std__vector_reco__TrackExtrapolation__db_datamem(Reflex::Class*);
void __std__vector_reco__TrackExtrapolation__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_reco__TrackExtrapolation__datamem_bld(&__std__vector_reco__TrackExtrapolation__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_reco__TrackExtrapolation__funcmem_bld(&__std__vector_reco__TrackExtrapolation__db_funcmem);
void __std__vector_reco__TrackExtrapolation__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<reco::TrackExtrapolation>"), typeid(::std::vector<reco::TrackExtrapolation>), sizeof(::std::vector<reco::TrackExtrapolation>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2490, ::Reflex::BaseOffset< ::std::vector<reco::TrackExtrapolation>, ::std::_Vector_base<reco::TrackExtrapolation,std::allocator<reco::TrackExtrapolation> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_7787, Reflex::Literal("std::vector<reco::TrackExtrapolation>::_Alloc_value_type"))
  .AddTypedef(type_2490, Reflex::Literal("std::vector<reco::TrackExtrapolation>::_Base"))
  .AddTypedef(type_3300, Reflex::Literal("std::vector<reco::TrackExtrapolation>::_Tp_alloc_type"))
  .AddTypedef(type_8470, Reflex::Literal("std::vector<reco::TrackExtrapolation>::_Alloc_traits"))
  .AddTypedef(type_7787, Reflex::Literal("std::vector<reco::TrackExtrapolation>::value_type"))
  .AddTypedef(type_9457, Reflex::Literal("std::vector<reco::TrackExtrapolation>::pointer"))
  .AddTypedef(type_14144, Reflex::Literal("std::vector<reco::TrackExtrapolation>::const_pointer"))
  .AddTypedef(type_14146, Reflex::Literal("std::vector<reco::TrackExtrapolation>::reference"))
  .AddTypedef(type_14148, Reflex::Literal("std::vector<reco::TrackExtrapolation>::const_reference"))
  .AddTypedef(type_8306, Reflex::Literal("std::vector<reco::TrackExtrapolation>::iterator"))
  .AddTypedef(type_8307, Reflex::Literal("std::vector<reco::TrackExtrapolation>::const_iterator"))
  .AddTypedef(type_3519, Reflex::Literal("std::vector<reco::TrackExtrapolation>::const_reverse_iterator"))
  .AddTypedef(type_3520, Reflex::Literal("std::vector<reco::TrackExtrapolation>::reverse_iterator"))
  .AddTypedef(type_3254, Reflex::Literal("std::vector<reco::TrackExtrapolation>::size_type"))
  .AddTypedef(type_3138, Reflex::Literal("std::vector<reco::TrackExtrapolation>::difference_type"))
  .AddTypedef(type_3300, Reflex::Literal("std::vector<reco::TrackExtrapolation>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_14157, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_34610), Reflex::Literal("vector"), constructor_14158, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3254, type_14148, type_34610), Reflex::Literal("vector"), constructor_14159, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20846), Reflex::Literal("vector"), constructor_14160, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_14161, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2993, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x13, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x14, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_reco__TrackExtrapolation__funcmem_bld);
}

//------Delayed data member builder for class vector<reco::TrackExtrapolation,std::allocator<reco::TrackExtrapolation> > -------------------
void __std__vector_reco__TrackExtrapolation__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<reco::TrackExtrapolation,std::allocator<reco::TrackExtrapolation> > -------------------
void __std__vector_reco__TrackExtrapolation__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35982, type_20846), Reflex::Literal("operator="), operator_14162, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_3254, type_14148), Reflex::Literal("assign"), method_14163, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8306), Reflex::Literal("begin"), method_14164, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8307), Reflex::Literal("begin"), method_14165, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8306), Reflex::Literal("end"), method_14166, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8307), Reflex::Literal("end"), method_14167, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3254), Reflex::Literal("size"), method_14172, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3254), Reflex::Literal("max_size"), method_14173, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_3254, type_7787), Reflex::Literal("resize"), method_14174, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3254), Reflex::Literal("capacity"), method_14175, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("empty"), method_14176, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_3254), Reflex::Literal("reserve"), method_14177, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14146, type_3254), Reflex::Literal("operator[]"), operator_14178, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14148, type_3254), Reflex::Literal("operator[]"), operator_14179, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14146, type_3254), Reflex::Literal("at"), method_14181, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14148, type_3254), Reflex::Literal("at"), method_14182, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14146), Reflex::Literal("front"), method_14183, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14148), Reflex::Literal("front"), method_14184, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14146), Reflex::Literal("back"), method_14185, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14148), Reflex::Literal("back"), method_14186, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9457), Reflex::Literal("data"), method_14187, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14144), Reflex::Literal("data"), method_14188, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_14148), Reflex::Literal("push_back"), method_14189, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694), Reflex::Literal("pop_back"), method_14190, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8306, type_8306, type_14148), Reflex::Literal("insert"), method_14191, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_8306, type_3254, type_14148), Reflex::Literal("insert"), method_14192, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8306, type_8306), Reflex::Literal("erase"), method_14193, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8306, type_8306, type_8306), Reflex::Literal("erase"), method_14194, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_35982), Reflex::Literal("swap"), method_14195, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694), Reflex::Literal("clear"), method_14196, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<reco::PFJet::Specific,std::allocator<reco::PFJet::Specific> > -------------------------------
static void constructor_14223( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::PFJet::Specific>();
  else ::new(mem) ::std::vector<reco::PFJet::Specific>();
}

static void constructor_14224( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::PFJet::Specific>(*(const ::std::allocator<reco::PFJet::Specific>*)arg[0]);
  else ::new(mem) ::std::vector<reco::PFJet::Specific>(*(const ::std::allocator<reco::PFJet::Specific>*)arg[0]);
}

static void constructor_14225( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::PFJet::Specific>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<reco::PFJet::Specific>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::PFJet::Specific>(*(::std::size_t*)arg[0],
      *(const ::reco::PFJet::Specific*)arg[1]);
  else ::new(mem) ::std::vector<reco::PFJet::Specific>(*(::std::size_t*)arg[0],
      *(const ::reco::PFJet::Specific*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::PFJet::Specific>(*(::std::size_t*)arg[0],
      *(const ::reco::PFJet::Specific*)arg[1],
      *(const ::std::allocator<reco::PFJet::Specific>*)arg[2]);
  else ::new(mem) ::std::vector<reco::PFJet::Specific>(*(::std::size_t*)arg[0],
      *(const ::reco::PFJet::Specific*)arg[1],
      *(const ::std::allocator<reco::PFJet::Specific>*)arg[2]);
  }
}

static void constructor_14226( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::PFJet::Specific>(*(const ::std::vector<reco::PFJet::Specific>*)arg[0]);
  else ::new(mem) ::std::vector<reco::PFJet::Specific>(*(const ::std::vector<reco::PFJet::Specific>*)arg[0]);
}

static void destructor_14227(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<reco::PFJet::Specific>*)o)->::std::vector<reco::PFJet::Specific>::~vector)();
}
static  void operator_14228( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::PFJet::Specific>*)o)->operator=)(*(const ::std::vector<reco::PFJet::Specific>*)arg[0]);
  else   (((::std::vector<reco::PFJet::Specific>*)o)->operator=)(*(const ::std::vector<reco::PFJet::Specific>*)arg[0]);
}

static  void method_14229( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::PFJet::Specific>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::reco::PFJet::Specific*)arg[1]);
}

static  void method_14230( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::PFJet::Specific*,std::vector<reco::PFJet::Specific> >)((((::std::vector<reco::PFJet::Specific>*)o)->begin)());
  else   (((::std::vector<reco::PFJet::Specific>*)o)->begin)();
}

static  void method_14231( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const reco::PFJet::Specific*,std::vector<reco::PFJet::Specific> >)((((const ::std::vector<reco::PFJet::Specific>*)o)->begin)());
  else   (((const ::std::vector<reco::PFJet::Specific>*)o)->begin)();
}

static  void method_14232( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::PFJet::Specific*,std::vector<reco::PFJet::Specific> >)((((::std::vector<reco::PFJet::Specific>*)o)->end)());
  else   (((::std::vector<reco::PFJet::Specific>*)o)->end)();
}

static  void method_14233( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const reco::PFJet::Specific*,std::vector<reco::PFJet::Specific> >)((((const ::std::vector<reco::PFJet::Specific>*)o)->end)());
  else   (((const ::std::vector<reco::PFJet::Specific>*)o)->end)();
}

static  void method_14238( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<reco::PFJet::Specific>*)o)->size)());
  else   (((const ::std::vector<reco::PFJet::Specific>*)o)->size)();
}

static  void method_14239( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<reco::PFJet::Specific>*)o)->max_size)());
  else   (((const ::std::vector<reco::PFJet::Specific>*)o)->max_size)();
}

static  void method_14240( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<reco::PFJet::Specific>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<reco::PFJet::Specific>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::reco::PFJet::Specific*)arg[1]);
  }
}

static  void method_14241( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<reco::PFJet::Specific>*)o)->capacity)());
  else   (((const ::std::vector<reco::PFJet::Specific>*)o)->capacity)();
}

static  void method_14242( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<reco::PFJet::Specific>*)o)->empty)());
  else   (((const ::std::vector<reco::PFJet::Specific>*)o)->empty)();
}

static  void method_14243( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::PFJet::Specific>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_14244( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::PFJet::Specific>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<reco::PFJet::Specific>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_14245( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::PFJet::Specific>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<reco::PFJet::Specific>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_14247( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::PFJet::Specific>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<reco::PFJet::Specific>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_14248( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::PFJet::Specific>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<reco::PFJet::Specific>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_14249( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::PFJet::Specific>*)o)->front)();
  else   (((::std::vector<reco::PFJet::Specific>*)o)->front)();
}

static  void method_14250( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::PFJet::Specific>*)o)->front)();
  else   (((const ::std::vector<reco::PFJet::Specific>*)o)->front)();
}

static  void method_14251( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::PFJet::Specific>*)o)->back)();
  else   (((::std::vector<reco::PFJet::Specific>*)o)->back)();
}

static  void method_14252( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::PFJet::Specific>*)o)->back)();
  else   (((const ::std::vector<reco::PFJet::Specific>*)o)->back)();
}

static  void method_14253( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<reco::PFJet::Specific>*)o)->data)());
  else   (((::std::vector<reco::PFJet::Specific>*)o)->data)();
}

static  void method_14254( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<reco::PFJet::Specific>*)o)->data)());
  else   (((const ::std::vector<reco::PFJet::Specific>*)o)->data)();
}

static  void method_14255( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::PFJet::Specific>*)o)->push_back)(*(const ::reco::PFJet::Specific*)arg[0]);
}

static  void method_14256( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<reco::PFJet::Specific>*)o)->pop_back)();
}

static  void method_14257( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::PFJet::Specific*,std::vector<reco::PFJet::Specific> >)((((::std::vector<reco::PFJet::Specific>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<reco::PFJet::Specific*,std::vector<reco::PFJet::Specific> >*)arg[0],
    *(const ::reco::PFJet::Specific*)arg[1]));
  else   (((::std::vector<reco::PFJet::Specific>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<reco::PFJet::Specific*,std::vector<reco::PFJet::Specific> >*)arg[0],
    *(const ::reco::PFJet::Specific*)arg[1]);
}

static  void method_14258( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::PFJet::Specific>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<reco::PFJet::Specific*,std::vector<reco::PFJet::Specific> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::reco::PFJet::Specific*)arg[2]);
}

static  void method_14259( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::PFJet::Specific*,std::vector<reco::PFJet::Specific> >)((((::std::vector<reco::PFJet::Specific>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::PFJet::Specific*,std::vector<reco::PFJet::Specific> >*)arg[0]));
  else   (((::std::vector<reco::PFJet::Specific>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::PFJet::Specific*,std::vector<reco::PFJet::Specific> >*)arg[0]);
}

static  void method_14260( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::PFJet::Specific*,std::vector<reco::PFJet::Specific> >)((((::std::vector<reco::PFJet::Specific>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::PFJet::Specific*,std::vector<reco::PFJet::Specific> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<reco::PFJet::Specific*,std::vector<reco::PFJet::Specific> >*)arg[1]));
  else   (((::std::vector<reco::PFJet::Specific>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::PFJet::Specific*,std::vector<reco::PFJet::Specific> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<reco::PFJet::Specific*,std::vector<reco::PFJet::Specific> >*)arg[1]);
}

static  void method_14261( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::PFJet::Specific>*)o)->swap)(*(::std::vector<reco::PFJet::Specific>*)arg[0]);
}

static  void method_14262( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<reco::PFJet::Specific>*)o)->clear)();
}

static void method_newdel_2994( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<reco::PFJet::Specific> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<reco::PFJet::Specific> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<reco::PFJet::Specific> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<reco::PFJet::Specific> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<reco::PFJet::Specific> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x16( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<reco::PFJet::Specific,std::allocator<reco::PFJet::Specific> >")), ::Reflex::BaseOffset< ::std::vector<reco::PFJet::Specific>,::std::_Vector_base<reco::PFJet::Specific,std::allocator<reco::PFJet::Specific> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x17( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<reco::PFJet::Specific> >::Generate();
  else ::Reflex::Proxy< ::std::vector<reco::PFJet::Specific> >::Generate();
}

//------Dictionary for class vector<reco::PFJet::Specific,std::allocator<reco::PFJet::Specific> > -------------------------------
void __std__vector_reco__PFJet__Specific__db_datamem(Reflex::Class*);
void __std__vector_reco__PFJet__Specific__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_reco__PFJet__Specific__datamem_bld(&__std__vector_reco__PFJet__Specific__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_reco__PFJet__Specific__funcmem_bld(&__std__vector_reco__PFJet__Specific__db_funcmem);
void __std__vector_reco__PFJet__Specific__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<reco::PFJet::Specific>"), typeid(::std::vector<reco::PFJet::Specific>), sizeof(::std::vector<reco::PFJet::Specific>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2491, ::Reflex::BaseOffset< ::std::vector<reco::PFJet::Specific>, ::std::_Vector_base<reco::PFJet::Specific,std::allocator<reco::PFJet::Specific> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_14203, Reflex::Literal("std::vector<reco::PFJet::Specific>::_Alloc_value_type"))
  .AddTypedef(type_2491, Reflex::Literal("std::vector<reco::PFJet::Specific>::_Base"))
  .AddTypedef(type_3301, Reflex::Literal("std::vector<reco::PFJet::Specific>::_Tp_alloc_type"))
  .AddTypedef(type_8471, Reflex::Literal("std::vector<reco::PFJet::Specific>::_Alloc_traits"))
  .AddTypedef(type_14203, Reflex::Literal("std::vector<reco::PFJet::Specific>::value_type"))
  .AddTypedef(type_9476, Reflex::Literal("std::vector<reco::PFJet::Specific>::pointer"))
  .AddTypedef(type_14210, Reflex::Literal("std::vector<reco::PFJet::Specific>::const_pointer"))
  .AddTypedef(type_14212, Reflex::Literal("std::vector<reco::PFJet::Specific>::reference"))
  .AddTypedef(type_14214, Reflex::Literal("std::vector<reco::PFJet::Specific>::const_reference"))
  .AddTypedef(type_8308, Reflex::Literal("std::vector<reco::PFJet::Specific>::iterator"))
  .AddTypedef(type_8309, Reflex::Literal("std::vector<reco::PFJet::Specific>::const_iterator"))
  .AddTypedef(type_3521, Reflex::Literal("std::vector<reco::PFJet::Specific>::const_reverse_iterator"))
  .AddTypedef(type_3522, Reflex::Literal("std::vector<reco::PFJet::Specific>::reverse_iterator"))
  .AddTypedef(type_3254, Reflex::Literal("std::vector<reco::PFJet::Specific>::size_type"))
  .AddTypedef(type_3138, Reflex::Literal("std::vector<reco::PFJet::Specific>::difference_type"))
  .AddTypedef(type_3301, Reflex::Literal("std::vector<reco::PFJet::Specific>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_14223, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_34623), Reflex::Literal("vector"), constructor_14224, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3254, type_14214, type_34623), Reflex::Literal("vector"), constructor_14225, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_36007), Reflex::Literal("vector"), constructor_14226, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_14227, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2994, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x16, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x17, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_reco__PFJet__Specific__funcmem_bld);
}

//------Delayed data member builder for class vector<reco::PFJet::Specific,std::allocator<reco::PFJet::Specific> > -------------------
void __std__vector_reco__PFJet__Specific__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<reco::PFJet::Specific,std::allocator<reco::PFJet::Specific> > -------------------
void __std__vector_reco__PFJet__Specific__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_36008, type_36007), Reflex::Literal("operator="), operator_14228, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_3254, type_14214), Reflex::Literal("assign"), method_14229, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8308), Reflex::Literal("begin"), method_14230, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8309), Reflex::Literal("begin"), method_14231, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8308), Reflex::Literal("end"), method_14232, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8309), Reflex::Literal("end"), method_14233, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3254), Reflex::Literal("size"), method_14238, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3254), Reflex::Literal("max_size"), method_14239, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_3254, type_14203), Reflex::Literal("resize"), method_14240, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3254), Reflex::Literal("capacity"), method_14241, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("empty"), method_14242, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_3254), Reflex::Literal("reserve"), method_14243, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14212, type_3254), Reflex::Literal("operator[]"), operator_14244, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14214, type_3254), Reflex::Literal("operator[]"), operator_14245, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14212, type_3254), Reflex::Literal("at"), method_14247, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14214, type_3254), Reflex::Literal("at"), method_14248, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14212), Reflex::Literal("front"), method_14249, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14214), Reflex::Literal("front"), method_14250, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14212), Reflex::Literal("back"), method_14251, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14214), Reflex::Literal("back"), method_14252, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9476), Reflex::Literal("data"), method_14253, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14210), Reflex::Literal("data"), method_14254, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_14214), Reflex::Literal("push_back"), method_14255, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694), Reflex::Literal("pop_back"), method_14256, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8308, type_8308, type_14214), Reflex::Literal("insert"), method_14257, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_8308, type_3254, type_14214), Reflex::Literal("insert"), method_14258, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8308, type_8308), Reflex::Literal("erase"), method_14259, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8308, type_8308, type_8308), Reflex::Literal("erase"), method_14260, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_36008), Reflex::Literal("swap"), method_14261, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694), Reflex::Literal("clear"), method_14262, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<reco::JPTJet::Specific,std::allocator<reco::JPTJet::Specific> > -------------------------------
static void constructor_14289( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::JPTJet::Specific>();
  else ::new(mem) ::std::vector<reco::JPTJet::Specific>();
}

static void constructor_14290( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::JPTJet::Specific>(*(const ::std::allocator<reco::JPTJet::Specific>*)arg[0]);
  else ::new(mem) ::std::vector<reco::JPTJet::Specific>(*(const ::std::allocator<reco::JPTJet::Specific>*)arg[0]);
}

static void constructor_14291( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::JPTJet::Specific>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<reco::JPTJet::Specific>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::JPTJet::Specific>(*(::std::size_t*)arg[0],
      *(const ::reco::JPTJet::Specific*)arg[1]);
  else ::new(mem) ::std::vector<reco::JPTJet::Specific>(*(::std::size_t*)arg[0],
      *(const ::reco::JPTJet::Specific*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::JPTJet::Specific>(*(::std::size_t*)arg[0],
      *(const ::reco::JPTJet::Specific*)arg[1],
      *(const ::std::allocator<reco::JPTJet::Specific>*)arg[2]);
  else ::new(mem) ::std::vector<reco::JPTJet::Specific>(*(::std::size_t*)arg[0],
      *(const ::reco::JPTJet::Specific*)arg[1],
      *(const ::std::allocator<reco::JPTJet::Specific>*)arg[2]);
  }
}

static void constructor_14292( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::JPTJet::Specific>(*(const ::std::vector<reco::JPTJet::Specific>*)arg[0]);
  else ::new(mem) ::std::vector<reco::JPTJet::Specific>(*(const ::std::vector<reco::JPTJet::Specific>*)arg[0]);
}

static void destructor_14293(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<reco::JPTJet::Specific>*)o)->::std::vector<reco::JPTJet::Specific>::~vector)();
}
static  void operator_14294( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::JPTJet::Specific>*)o)->operator=)(*(const ::std::vector<reco::JPTJet::Specific>*)arg[0]);
  else   (((::std::vector<reco::JPTJet::Specific>*)o)->operator=)(*(const ::std::vector<reco::JPTJet::Specific>*)arg[0]);
}

static  void method_14295( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::JPTJet::Specific>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::reco::JPTJet::Specific*)arg[1]);
}

static  void method_14296( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::JPTJet::Specific*,std::vector<reco::JPTJet::Specific> >)((((::std::vector<reco::JPTJet::Specific>*)o)->begin)());
  else   (((::std::vector<reco::JPTJet::Specific>*)o)->begin)();
}

static  void method_14297( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const reco::JPTJet::Specific*,std::vector<reco::JPTJet::Specific> >)((((const ::std::vector<reco::JPTJet::Specific>*)o)->begin)());
  else   (((const ::std::vector<reco::JPTJet::Specific>*)o)->begin)();
}

static  void method_14298( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::JPTJet::Specific*,std::vector<reco::JPTJet::Specific> >)((((::std::vector<reco::JPTJet::Specific>*)o)->end)());
  else   (((::std::vector<reco::JPTJet::Specific>*)o)->end)();
}

static  void method_14299( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const reco::JPTJet::Specific*,std::vector<reco::JPTJet::Specific> >)((((const ::std::vector<reco::JPTJet::Specific>*)o)->end)());
  else   (((const ::std::vector<reco::JPTJet::Specific>*)o)->end)();
}

static  void method_14304( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<reco::JPTJet::Specific>*)o)->size)());
  else   (((const ::std::vector<reco::JPTJet::Specific>*)o)->size)();
}

static  void method_14305( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<reco::JPTJet::Specific>*)o)->max_size)());
  else   (((const ::std::vector<reco::JPTJet::Specific>*)o)->max_size)();
}

static  void method_14306( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<reco::JPTJet::Specific>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<reco::JPTJet::Specific>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::reco::JPTJet::Specific*)arg[1]);
  }
}

static  void method_14307( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<reco::JPTJet::Specific>*)o)->capacity)());
  else   (((const ::std::vector<reco::JPTJet::Specific>*)o)->capacity)();
}

static  void method_14308( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<reco::JPTJet::Specific>*)o)->empty)());
  else   (((const ::std::vector<reco::JPTJet::Specific>*)o)->empty)();
}

static  void method_14309( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::JPTJet::Specific>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_14310( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::JPTJet::Specific>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<reco::JPTJet::Specific>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_14311( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::JPTJet::Specific>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<reco::JPTJet::Specific>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_14313( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::JPTJet::Specific>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<reco::JPTJet::Specific>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_14314( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::JPTJet::Specific>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<reco::JPTJet::Specific>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_14315( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::JPTJet::Specific>*)o)->front)();
  else   (((::std::vector<reco::JPTJet::Specific>*)o)->front)();
}

static  void method_14316( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::JPTJet::Specific>*)o)->front)();
  else   (((const ::std::vector<reco::JPTJet::Specific>*)o)->front)();
}

static  void method_14317( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::JPTJet::Specific>*)o)->back)();
  else   (((::std::vector<reco::JPTJet::Specific>*)o)->back)();
}

static  void method_14318( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::JPTJet::Specific>*)o)->back)();
  else   (((const ::std::vector<reco::JPTJet::Specific>*)o)->back)();
}

static  void method_14319( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<reco::JPTJet::Specific>*)o)->data)());
  else   (((::std::vector<reco::JPTJet::Specific>*)o)->data)();
}

static  void method_14320( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<reco::JPTJet::Specific>*)o)->data)());
  else   (((const ::std::vector<reco::JPTJet::Specific>*)o)->data)();
}

static  void method_14321( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::JPTJet::Specific>*)o)->push_back)(*(const ::reco::JPTJet::Specific*)arg[0]);
}

static  void method_14322( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<reco::JPTJet::Specific>*)o)->pop_back)();
}

static  void method_14323( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::JPTJet::Specific*,std::vector<reco::JPTJet::Specific> >)((((::std::vector<reco::JPTJet::Specific>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<reco::JPTJet::Specific*,std::vector<reco::JPTJet::Specific> >*)arg[0],
    *(const ::reco::JPTJet::Specific*)arg[1]));
  else   (((::std::vector<reco::JPTJet::Specific>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<reco::JPTJet::Specific*,std::vector<reco::JPTJet::Specific> >*)arg[0],
    *(const ::reco::JPTJet::Specific*)arg[1]);
}

static  void method_14324( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::JPTJet::Specific>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<reco::JPTJet::Specific*,std::vector<reco::JPTJet::Specific> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::reco::JPTJet::Specific*)arg[2]);
}

static  void method_14325( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::JPTJet::Specific*,std::vector<reco::JPTJet::Specific> >)((((::std::vector<reco::JPTJet::Specific>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::JPTJet::Specific*,std::vector<reco::JPTJet::Specific> >*)arg[0]));
  else   (((::std::vector<reco::JPTJet::Specific>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::JPTJet::Specific*,std::vector<reco::JPTJet::Specific> >*)arg[0]);
}

static  void method_14326( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::JPTJet::Specific*,std::vector<reco::JPTJet::Specific> >)((((::std::vector<reco::JPTJet::Specific>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::JPTJet::Specific*,std::vector<reco::JPTJet::Specific> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<reco::JPTJet::Specific*,std::vector<reco::JPTJet::Specific> >*)arg[1]));
  else   (((::std::vector<reco::JPTJet::Specific>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::JPTJet::Specific*,std::vector<reco::JPTJet::Specific> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<reco::JPTJet::Specific*,std::vector<reco::JPTJet::Specific> >*)arg[1]);
}

static  void method_14327( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::JPTJet::Specific>*)o)->swap)(*(::std::vector<reco::JPTJet::Specific>*)arg[0]);
}

static  void method_14328( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<reco::JPTJet::Specific>*)o)->clear)();
}

static void method_newdel_2995( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<reco::JPTJet::Specific> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<reco::JPTJet::Specific> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<reco::JPTJet::Specific> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<reco::JPTJet::Specific> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<reco::JPTJet::Specific> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x19( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<reco::JPTJet::Specific,std::allocator<reco::JPTJet::Specific> >")), ::Reflex::BaseOffset< ::std::vector<reco::JPTJet::Specific>,::std::_Vector_base<reco::JPTJet::Specific,std::allocator<reco::JPTJet::Specific> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x20( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<reco::JPTJet::Specific> >::Generate();
  else ::Reflex::Proxy< ::std::vector<reco::JPTJet::Specific> >::Generate();
}

//------Dictionary for class vector<reco::JPTJet::Specific,std::allocator<reco::JPTJet::Specific> > -------------------------------
void __std__vector_reco__JPTJet__Specific__db_datamem(Reflex::Class*);
void __std__vector_reco__JPTJet__Specific__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_reco__JPTJet__Specific__datamem_bld(&__std__vector_reco__JPTJet__Specific__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_reco__JPTJet__Specific__funcmem_bld(&__std__vector_reco__JPTJet__Specific__db_funcmem);
void __std__vector_reco__JPTJet__Specific__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<reco::JPTJet::Specific>"), typeid(::std::vector<reco::JPTJet::Specific>), sizeof(::std::vector<reco::JPTJet::Specific>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2492, ::Reflex::BaseOffset< ::std::vector<reco::JPTJet::Specific>, ::std::_Vector_base<reco::JPTJet::Specific,std::allocator<reco::JPTJet::Specific> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_14269, Reflex::Literal("std::vector<reco::JPTJet::Specific>::_Alloc_value_type"))
  .AddTypedef(type_2492, Reflex::Literal("std::vector<reco::JPTJet::Specific>::_Base"))
  .AddTypedef(type_3302, Reflex::Literal("std::vector<reco::JPTJet::Specific>::_Tp_alloc_type"))
  .AddTypedef(type_8472, Reflex::Literal("std::vector<reco::JPTJet::Specific>::_Alloc_traits"))
  .AddTypedef(type_14269, Reflex::Literal("std::vector<reco::JPTJet::Specific>::value_type"))
  .AddTypedef(type_9495, Reflex::Literal("std::vector<reco::JPTJet::Specific>::pointer"))
  .AddTypedef(type_14276, Reflex::Literal("std::vector<reco::JPTJet::Specific>::const_pointer"))
  .AddTypedef(type_14278, Reflex::Literal("std::vector<reco::JPTJet::Specific>::reference"))
  .AddTypedef(type_14280, Reflex::Literal("std::vector<reco::JPTJet::Specific>::const_reference"))
  .AddTypedef(type_8310, Reflex::Literal("std::vector<reco::JPTJet::Specific>::iterator"))
  .AddTypedef(type_8311, Reflex::Literal("std::vector<reco::JPTJet::Specific>::const_iterator"))
  .AddTypedef(type_3523, Reflex::Literal("std::vector<reco::JPTJet::Specific>::const_reverse_iterator"))
  .AddTypedef(type_3524, Reflex::Literal("std::vector<reco::JPTJet::Specific>::reverse_iterator"))
  .AddTypedef(type_3254, Reflex::Literal("std::vector<reco::JPTJet::Specific>::size_type"))
  .AddTypedef(type_3138, Reflex::Literal("std::vector<reco::JPTJet::Specific>::difference_type"))
  .AddTypedef(type_3302, Reflex::Literal("std::vector<reco::JPTJet::Specific>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_14289, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_34636), Reflex::Literal("vector"), constructor_14290, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3254, type_14280, type_34636), Reflex::Literal("vector"), constructor_14291, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_36040), Reflex::Literal("vector"), constructor_14292, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_14293, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2995, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x19, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x20, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_reco__JPTJet__Specific__funcmem_bld);
}

//------Delayed data member builder for class vector<reco::JPTJet::Specific,std::allocator<reco::JPTJet::Specific> > -------------------
void __std__vector_reco__JPTJet__Specific__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<reco::JPTJet::Specific,std::allocator<reco::JPTJet::Specific> > -------------------
void __std__vector_reco__JPTJet__Specific__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_36041, type_36040), Reflex::Literal("operator="), operator_14294, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_3254, type_14280), Reflex::Literal("assign"), method_14295, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8310), Reflex::Literal("begin"), method_14296, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8311), Reflex::Literal("begin"), method_14297, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8310), Reflex::Literal("end"), method_14298, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8311), Reflex::Literal("end"), method_14299, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3254), Reflex::Literal("size"), method_14304, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3254), Reflex::Literal("max_size"), method_14305, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_3254, type_14269), Reflex::Literal("resize"), method_14306, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3254), Reflex::Literal("capacity"), method_14307, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("empty"), method_14308, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_3254), Reflex::Literal("reserve"), method_14309, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14278, type_3254), Reflex::Literal("operator[]"), operator_14310, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14280, type_3254), Reflex::Literal("operator[]"), operator_14311, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14278, type_3254), Reflex::Literal("at"), method_14313, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14280, type_3254), Reflex::Literal("at"), method_14314, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14278), Reflex::Literal("front"), method_14315, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14280), Reflex::Literal("front"), method_14316, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14278), Reflex::Literal("back"), method_14317, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14280), Reflex::Literal("back"), method_14318, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9495), Reflex::Literal("data"), method_14319, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14276), Reflex::Literal("data"), method_14320, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_14280), Reflex::Literal("push_back"), method_14321, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694), Reflex::Literal("pop_back"), method_14322, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8310, type_8310, type_14280), Reflex::Literal("insert"), method_14323, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_8310, type_3254, type_14280), Reflex::Literal("insert"), method_14324, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8310, type_8310), Reflex::Literal("erase"), method_14325, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8310, type_8310, type_8310), Reflex::Literal("erase"), method_14326, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_36041), Reflex::Literal("swap"), method_14327, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694), Reflex::Literal("clear"), method_14328, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<reco::CaloJet::Specific,std::allocator<reco::CaloJet::Specific> > -------------------------------
static void constructor_14355( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::CaloJet::Specific>();
  else ::new(mem) ::std::vector<reco::CaloJet::Specific>();
}

static void constructor_14356( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::CaloJet::Specific>(*(const ::std::allocator<reco::CaloJet::Specific>*)arg[0]);
  else ::new(mem) ::std::vector<reco::CaloJet::Specific>(*(const ::std::allocator<reco::CaloJet::Specific>*)arg[0]);
}

static void constructor_14357( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::CaloJet::Specific>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<reco::CaloJet::Specific>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::CaloJet::Specific>(*(::std::size_t*)arg[0],
      *(const ::reco::CaloJet::Specific*)arg[1]);
  else ::new(mem) ::std::vector<reco::CaloJet::Specific>(*(::std::size_t*)arg[0],
      *(const ::reco::CaloJet::Specific*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::CaloJet::Specific>(*(::std::size_t*)arg[0],
      *(const ::reco::CaloJet::Specific*)arg[1],
      *(const ::std::allocator<reco::CaloJet::Specific>*)arg[2]);
  else ::new(mem) ::std::vector<reco::CaloJet::Specific>(*(::std::size_t*)arg[0],
      *(const ::reco::CaloJet::Specific*)arg[1],
      *(const ::std::allocator<reco::CaloJet::Specific>*)arg[2]);
  }
}

static void constructor_14358( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::CaloJet::Specific>(*(const ::std::vector<reco::CaloJet::Specific>*)arg[0]);
  else ::new(mem) ::std::vector<reco::CaloJet::Specific>(*(const ::std::vector<reco::CaloJet::Specific>*)arg[0]);
}

static void destructor_14359(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<reco::CaloJet::Specific>*)o)->::std::vector<reco::CaloJet::Specific>::~vector)();
}
static  void operator_14360( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::CaloJet::Specific>*)o)->operator=)(*(const ::std::vector<reco::CaloJet::Specific>*)arg[0]);
  else   (((::std::vector<reco::CaloJet::Specific>*)o)->operator=)(*(const ::std::vector<reco::CaloJet::Specific>*)arg[0]);
}

static  void method_14361( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::CaloJet::Specific>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::reco::CaloJet::Specific*)arg[1]);
}

static  void method_14362( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::CaloJet::Specific*,std::vector<reco::CaloJet::Specific> >)((((::std::vector<reco::CaloJet::Specific>*)o)->begin)());
  else   (((::std::vector<reco::CaloJet::Specific>*)o)->begin)();
}

static  void method_14363( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const reco::CaloJet::Specific*,std::vector<reco::CaloJet::Specific> >)((((const ::std::vector<reco::CaloJet::Specific>*)o)->begin)());
  else   (((const ::std::vector<reco::CaloJet::Specific>*)o)->begin)();
}

static  void method_14364( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::CaloJet::Specific*,std::vector<reco::CaloJet::Specific> >)((((::std::vector<reco::CaloJet::Specific>*)o)->end)());
  else   (((::std::vector<reco::CaloJet::Specific>*)o)->end)();
}

static  void method_14365( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const reco::CaloJet::Specific*,std::vector<reco::CaloJet::Specific> >)((((const ::std::vector<reco::CaloJet::Specific>*)o)->end)());
  else   (((const ::std::vector<reco::CaloJet::Specific>*)o)->end)();
}

static  void method_14370( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<reco::CaloJet::Specific>*)o)->size)());
  else   (((const ::std::vector<reco::CaloJet::Specific>*)o)->size)();
}

static  void method_14371( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<reco::CaloJet::Specific>*)o)->max_size)());
  else   (((const ::std::vector<reco::CaloJet::Specific>*)o)->max_size)();
}

static  void method_14372( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<reco::CaloJet::Specific>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<reco::CaloJet::Specific>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::reco::CaloJet::Specific*)arg[1]);
  }
}

static  void method_14373( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<reco::CaloJet::Specific>*)o)->capacity)());
  else   (((const ::std::vector<reco::CaloJet::Specific>*)o)->capacity)();
}

static  void method_14374( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<reco::CaloJet::Specific>*)o)->empty)());
  else   (((const ::std::vector<reco::CaloJet::Specific>*)o)->empty)();
}

static  void method_14375( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::CaloJet::Specific>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_14376( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::CaloJet::Specific>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<reco::CaloJet::Specific>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_14377( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::CaloJet::Specific>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<reco::CaloJet::Specific>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_14379( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::CaloJet::Specific>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<reco::CaloJet::Specific>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_14380( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::CaloJet::Specific>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<reco::CaloJet::Specific>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_14381( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::CaloJet::Specific>*)o)->front)();
  else   (((::std::vector<reco::CaloJet::Specific>*)o)->front)();
}

static  void method_14382( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::CaloJet::Specific>*)o)->front)();
  else   (((const ::std::vector<reco::CaloJet::Specific>*)o)->front)();
}

static  void method_14383( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::CaloJet::Specific>*)o)->back)();
  else   (((::std::vector<reco::CaloJet::Specific>*)o)->back)();
}

static  void method_14384( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::CaloJet::Specific>*)o)->back)();
  else   (((const ::std::vector<reco::CaloJet::Specific>*)o)->back)();
}

static  void method_14385( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<reco::CaloJet::Specific>*)o)->data)());
  else   (((::std::vector<reco::CaloJet::Specific>*)o)->data)();
}

static  void method_14386( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<reco::CaloJet::Specific>*)o)->data)());
  else   (((const ::std::vector<reco::CaloJet::Specific>*)o)->data)();
}

static  void method_14387( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::CaloJet::Specific>*)o)->push_back)(*(const ::reco::CaloJet::Specific*)arg[0]);
}

static  void method_14388( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<reco::CaloJet::Specific>*)o)->pop_back)();
}

static  void method_14389( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::CaloJet::Specific*,std::vector<reco::CaloJet::Specific> >)((((::std::vector<reco::CaloJet::Specific>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<reco::CaloJet::Specific*,std::vector<reco::CaloJet::Specific> >*)arg[0],
    *(const ::reco::CaloJet::Specific*)arg[1]));
  else   (((::std::vector<reco::CaloJet::Specific>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<reco::CaloJet::Specific*,std::vector<reco::CaloJet::Specific> >*)arg[0],
    *(const ::reco::CaloJet::Specific*)arg[1]);
}

static  void method_14390( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::CaloJet::Specific>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<reco::CaloJet::Specific*,std::vector<reco::CaloJet::Specific> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::reco::CaloJet::Specific*)arg[2]);
}

static  void method_14391( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::CaloJet::Specific*,std::vector<reco::CaloJet::Specific> >)((((::std::vector<reco::CaloJet::Specific>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::CaloJet::Specific*,std::vector<reco::CaloJet::Specific> >*)arg[0]));
  else   (((::std::vector<reco::CaloJet::Specific>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::CaloJet::Specific*,std::vector<reco::CaloJet::Specific> >*)arg[0]);
}

static  void method_14392( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::CaloJet::Specific*,std::vector<reco::CaloJet::Specific> >)((((::std::vector<reco::CaloJet::Specific>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::CaloJet::Specific*,std::vector<reco::CaloJet::Specific> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<reco::CaloJet::Specific*,std::vector<reco::CaloJet::Specific> >*)arg[1]));
  else   (((::std::vector<reco::CaloJet::Specific>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::CaloJet::Specific*,std::vector<reco::CaloJet::Specific> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<reco::CaloJet::Specific*,std::vector<reco::CaloJet::Specific> >*)arg[1]);
}

static  void method_14393( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::CaloJet::Specific>*)o)->swap)(*(::std::vector<reco::CaloJet::Specific>*)arg[0]);
}

static  void method_14394( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<reco::CaloJet::Specific>*)o)->clear)();
}

static void method_newdel_2996( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<reco::CaloJet::Specific> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<reco::CaloJet::Specific> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<reco::CaloJet::Specific> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<reco::CaloJet::Specific> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<reco::CaloJet::Specific> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x22( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<reco::CaloJet::Specific,std::allocator<reco::CaloJet::Specific> >")), ::Reflex::BaseOffset< ::std::vector<reco::CaloJet::Specific>,::std::_Vector_base<reco::CaloJet::Specific,std::allocator<reco::CaloJet::Specific> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x23( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<reco::CaloJet::Specific> >::Generate();
  else ::Reflex::Proxy< ::std::vector<reco::CaloJet::Specific> >::Generate();
}

//------Dictionary for class vector<reco::CaloJet::Specific,std::allocator<reco::CaloJet::Specific> > -------------------------------
void __std__vector_reco__CaloJet__Specific__db_datamem(Reflex::Class*);
void __std__vector_reco__CaloJet__Specific__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_reco__CaloJet__Specific__datamem_bld(&__std__vector_reco__CaloJet__Specific__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_reco__CaloJet__Specific__funcmem_bld(&__std__vector_reco__CaloJet__Specific__db_funcmem);
void __std__vector_reco__CaloJet__Specific__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<reco::CaloJet::Specific>"), typeid(::std::vector<reco::CaloJet::Specific>), sizeof(::std::vector<reco::CaloJet::Specific>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2493, ::Reflex::BaseOffset< ::std::vector<reco::CaloJet::Specific>, ::std::_Vector_base<reco::CaloJet::Specific,std::allocator<reco::CaloJet::Specific> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_14335, Reflex::Literal("std::vector<reco::CaloJet::Specific>::_Alloc_value_type"))
  .AddTypedef(type_2493, Reflex::Literal("std::vector<reco::CaloJet::Specific>::_Base"))
  .AddTypedef(type_3303, Reflex::Literal("std::vector<reco::CaloJet::Specific>::_Tp_alloc_type"))
  .AddTypedef(type_8473, Reflex::Literal("std::vector<reco::CaloJet::Specific>::_Alloc_traits"))
  .AddTypedef(type_14335, Reflex::Literal("std::vector<reco::CaloJet::Specific>::value_type"))
  .AddTypedef(type_9514, Reflex::Literal("std::vector<reco::CaloJet::Specific>::pointer"))
  .AddTypedef(type_14342, Reflex::Literal("std::vector<reco::CaloJet::Specific>::const_pointer"))
  .AddTypedef(type_14344, Reflex::Literal("std::vector<reco::CaloJet::Specific>::reference"))
  .AddTypedef(type_14346, Reflex::Literal("std::vector<reco::CaloJet::Specific>::const_reference"))
  .AddTypedef(type_8312, Reflex::Literal("std::vector<reco::CaloJet::Specific>::iterator"))
  .AddTypedef(type_8313, Reflex::Literal("std::vector<reco::CaloJet::Specific>::const_iterator"))
  .AddTypedef(type_3525, Reflex::Literal("std::vector<reco::CaloJet::Specific>::const_reverse_iterator"))
  .AddTypedef(type_3526, Reflex::Literal("std::vector<reco::CaloJet::Specific>::reverse_iterator"))
  .AddTypedef(type_3254, Reflex::Literal("std::vector<reco::CaloJet::Specific>::size_type"))
  .AddTypedef(type_3138, Reflex::Literal("std::vector<reco::CaloJet::Specific>::difference_type"))
  .AddTypedef(type_3303, Reflex::Literal("std::vector<reco::CaloJet::Specific>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_14355, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_34649), Reflex::Literal("vector"), constructor_14356, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3254, type_14346, type_34649), Reflex::Literal("vector"), constructor_14357, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_36059), Reflex::Literal("vector"), constructor_14358, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_14359, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2996, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x22, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x23, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_reco__CaloJet__Specific__funcmem_bld);
}

//------Delayed data member builder for class vector<reco::CaloJet::Specific,std::allocator<reco::CaloJet::Specific> > -------------------
void __std__vector_reco__CaloJet__Specific__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<reco::CaloJet::Specific,std::allocator<reco::CaloJet::Specific> > -------------------
void __std__vector_reco__CaloJet__Specific__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_36060, type_36059), Reflex::Literal("operator="), operator_14360, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_3254, type_14346), Reflex::Literal("assign"), method_14361, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8312), Reflex::Literal("begin"), method_14362, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8313), Reflex::Literal("begin"), method_14363, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8312), Reflex::Literal("end"), method_14364, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8313), Reflex::Literal("end"), method_14365, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3254), Reflex::Literal("size"), method_14370, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3254), Reflex::Literal("max_size"), method_14371, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_3254, type_14335), Reflex::Literal("resize"), method_14372, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3254), Reflex::Literal("capacity"), method_14373, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("empty"), method_14374, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_3254), Reflex::Literal("reserve"), method_14375, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14344, type_3254), Reflex::Literal("operator[]"), operator_14376, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14346, type_3254), Reflex::Literal("operator[]"), operator_14377, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14344, type_3254), Reflex::Literal("at"), method_14379, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14346, type_3254), Reflex::Literal("at"), method_14380, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14344), Reflex::Literal("front"), method_14381, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14346), Reflex::Literal("front"), method_14382, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14344), Reflex::Literal("back"), method_14383, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14346), Reflex::Literal("back"), method_14384, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9514), Reflex::Literal("data"), method_14385, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14342), Reflex::Literal("data"), method_14386, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_14346), Reflex::Literal("push_back"), method_14387, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694), Reflex::Literal("pop_back"), method_14388, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8312, type_8312, type_14346), Reflex::Literal("insert"), method_14389, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_8312, type_3254, type_14346), Reflex::Literal("insert"), method_14390, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8312, type_8312), Reflex::Literal("erase"), method_14391, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8312, type_8312, type_8312), Reflex::Literal("erase"), method_14392, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_36060), Reflex::Literal("swap"), method_14393, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694), Reflex::Literal("clear"), method_14394, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class Ptr<reco::PFCluster> -------------------------------
static  void operator_24827( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Ptr<reco::PFCluster>*)o)->operator=)(*(const ::edm::Ptr<reco::PFCluster>*)arg[0]);
  else   (((::edm::Ptr<reco::PFCluster>*)o)->operator=)(*(const ::edm::Ptr<reco::PFCluster>*)arg[0]);
}

static void constructor_24828( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<reco::PFCluster>(*(const ::edm::Ptr<reco::PFCluster>*)arg[0]);
  else ::new(mem) ::edm::Ptr<reco::PFCluster>(*(const ::edm::Ptr<reco::PFCluster>*)arg[0]);
}

static void constructor_24829( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<reco::PFCluster>(*(const ::edm::ProductID*)arg[0],
      *(unsigned long*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
  else ::new(mem) ::edm::Ptr<reco::PFCluster>(*(const ::edm::ProductID*)arg[0],
      *(unsigned long*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
}

static void constructor_24830( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<reco::PFCluster>(*(const ::edm::ProductID*)arg[0],
      (const ::reco::PFCluster*)arg[1],
      *(unsigned long*)arg[2]);
  else ::new(mem) ::edm::Ptr<reco::PFCluster>(*(const ::edm::ProductID*)arg[0],
      (const ::reco::PFCluster*)arg[1],
      *(unsigned long*)arg[2]);
}

static void constructor_24831( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<reco::PFCluster>(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::Ptr<reco::PFCluster>(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_24832( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<reco::PFCluster>();
  else ::new(mem) ::edm::Ptr<reco::PFCluster>();
}

static void destructor_24833(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Ptr<reco::PFCluster>*)o)->::edm::Ptr<reco::PFCluster>::~Ptr)();
}
static  void operator_24834( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ptr<reco::PFCluster>*)o)->operator*)();
  else   (((const ::edm::Ptr<reco::PFCluster>*)o)->operator*)();
}

static  void operator_24835( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<reco::PFCluster>*)o)->operator->)());
  else   (((const ::edm::Ptr<reco::PFCluster>*)o)->operator->)();
}

static  void method_24836( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<reco::PFCluster>*)o)->get)());
  else   (((const ::edm::Ptr<reco::PFCluster>*)o)->get)();
}

static  void method_24837( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::PFCluster>*)o)->isNull)());
  else   (((const ::edm::Ptr<reco::PFCluster>*)o)->isNull)();
}

static  void method_24838( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::PFCluster>*)o)->isNonnull)());
  else   (((const ::edm::Ptr<reco::PFCluster>*)o)->isNonnull)();
}

static  void operator_24839( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::PFCluster>*)o)->operator!)());
  else   (((const ::edm::Ptr<reco::PFCluster>*)o)->operator!)();
}

static  void method_24840( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::PFCluster>*)o)->isAvailable)());
  else   (((const ::edm::Ptr<reco::PFCluster>*)o)->isAvailable)();
}

static  void method_24841( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::PFCluster>*)o)->isTransient)());
  else   (((const ::edm::Ptr<reco::PFCluster>*)o)->isTransient)();
}

static  void method_24842( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::Ptr<reco::PFCluster>*)o)->id)());
  else   (((const ::edm::Ptr<reco::PFCluster>*)o)->id)();
}

static  void method_24843( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<reco::PFCluster>*)o)->productGetter)());
  else   (((const ::edm::Ptr<reco::PFCluster>*)o)->productGetter)();
}

static  void method_24844( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long)((((const ::edm::Ptr<reco::PFCluster>*)o)->key)());
  else   (((const ::edm::Ptr<reco::PFCluster>*)o)->key)();
}

static  void method_24845( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::PFCluster>*)o)->hasProductCache)());
  else   (((const ::edm::Ptr<reco::PFCluster>*)o)->hasProductCache)();
}

static  void method_24846( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ptr<reco::PFCluster>*)o)->refCore)();
  else   (((const ::edm::Ptr<reco::PFCluster>*)o)->refCore)();
}

static  void method_24847( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<reco::PFCluster>*)o)->product)());
  else   (((const ::edm::Ptr<reco::PFCluster>*)o)->product)();
}

static  void method_24848( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::Ptr<reco::PFCluster>*)o)->Class_Version)());
  else   (((::edm::Ptr<reco::PFCluster>*)o)->Class_Version)();
}

static void method_newdel_4990( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Ptr<reco::PFCluster> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Ptr<reco::PFCluster> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Ptr<reco::PFCluster> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Ptr<reco::PFCluster> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Ptr<reco::PFCluster> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Ptr<reco::PFCluster> -------------------------------
void __edm__Ptr_reco__PFCluster__db_datamem(Reflex::Class*);
void __edm__Ptr_reco__PFCluster__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Ptr_reco__PFCluster__datamem_bld(&__edm__Ptr_reco__PFCluster__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Ptr_reco__PFCluster__funcmem_bld(&__edm__Ptr_reco__PFCluster__db_funcmem);
void __edm__Ptr_reco__PFCluster__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Ptr<reco::PFCluster>"), typeid(::edm::Ptr<reco::PFCluster>), sizeof(::edm::Ptr<reco::PFCluster>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::Ptr<reco::PFCluster>::Class_Version())
  .AddTypedef(type_358, Reflex::Literal("edm::Ptr<reco::PFCluster>::key_type"))
  .AddTypedef(type_7973, Reflex::Literal("edm::Ptr<reco::PFCluster>::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14409, type_14411), Reflex::Literal("operator="), operator_24827, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_14411), Reflex::Literal("Ptr"), constructor_24828, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20599, type_358, type_20675), Reflex::Literal("Ptr"), constructor_24829, 0, "productID;itemKey;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20599, type_15959, type_358), Reflex::Literal("Ptr"), constructor_24830, 0, "productID;item;item_key", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20599), Reflex::Literal("Ptr"), constructor_24831, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Ptr"), constructor_24832, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Ptr"), destructor_24833, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4990, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Ptr_reco__PFCluster__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Ptr_reco__PFCluster__funcmem_bld);
}

//------Delayed data member builder for class Ptr<reco::PFCluster> -------------------
void __edm__Ptr_reco__PFCluster__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4935, Reflex::Literal("core_"), OffsetOf(__shadow__::__edm__Ptr_reco__PFCluster_, core_), ::Reflex::PRIVATE)
  .AddDataMember(type_358, Reflex::Literal("key_"), OffsetOf(__shadow__::__edm__Ptr_reco__PFCluster_, key_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Ptr<reco::PFCluster> -------------------
void __edm__Ptr_reco__PFCluster__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15963), Reflex::Literal("operator*"), operator_24834, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15959), Reflex::Literal("operator->"), operator_24835, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15959), Reflex::Literal("get"), method_24836, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isNull"), method_24837, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isNonnull"), method_24838, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("operator!"), operator_24839, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isAvailable"), method_24840, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isTransient"), method_24841, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4933), Reflex::Literal("id"), method_24842, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20675), Reflex::Literal("productGetter"), method_24843, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_358), Reflex::Literal("key"), method_24844, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("hasProductCache"), method_24845, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23940), Reflex::Literal("refCore"), method_24846, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4071), Reflex::Literal("product"), method_24847, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_237), Reflex::Literal("Class_Version"), method_24848, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class vector<edm::Ptr<reco::PFCluster>,std::allocator<edm::Ptr<reco::PFCluster> > > -------------------------------
static void constructor_14420( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::Ptr<reco::PFCluster> >();
  else ::new(mem) ::std::vector<edm::Ptr<reco::PFCluster> >();
}

static void constructor_14421( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::Ptr<reco::PFCluster> >(*(const ::std::allocator<edm::Ptr<reco::PFCluster> >*)arg[0]);
  else ::new(mem) ::std::vector<edm::Ptr<reco::PFCluster> >(*(const ::std::allocator<edm::Ptr<reco::PFCluster> >*)arg[0]);
}

static void constructor_14422( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::Ptr<reco::PFCluster> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<edm::Ptr<reco::PFCluster> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::Ptr<reco::PFCluster> >(*(::std::size_t*)arg[0],
      *(const ::edm::Ptr<reco::PFCluster>*)arg[1]);
  else ::new(mem) ::std::vector<edm::Ptr<reco::PFCluster> >(*(::std::size_t*)arg[0],
      *(const ::edm::Ptr<reco::PFCluster>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::Ptr<reco::PFCluster> >(*(::std::size_t*)arg[0],
      *(const ::edm::Ptr<reco::PFCluster>*)arg[1],
      *(const ::std::allocator<edm::Ptr<reco::PFCluster> >*)arg[2]);
  else ::new(mem) ::std::vector<edm::Ptr<reco::PFCluster> >(*(::std::size_t*)arg[0],
      *(const ::edm::Ptr<reco::PFCluster>*)arg[1],
      *(const ::std::allocator<edm::Ptr<reco::PFCluster> >*)arg[2]);
  }
}

static void constructor_14423( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::Ptr<reco::PFCluster> >(*(const ::std::vector<edm::Ptr<reco::PFCluster> >*)arg[0]);
  else ::new(mem) ::std::vector<edm::Ptr<reco::PFCluster> >(*(const ::std::vector<edm::Ptr<reco::PFCluster> >*)arg[0]);
}

static void destructor_14424(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<edm::Ptr<reco::PFCluster> >*)o)->::std::vector<edm::Ptr<reco::PFCluster> >::~vector)();
}
static  void operator_14425( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::Ptr<reco::PFCluster> >*)o)->operator=)(*(const ::std::vector<edm::Ptr<reco::PFCluster> >*)arg[0]);
  else   (((::std::vector<edm::Ptr<reco::PFCluster> >*)o)->operator=)(*(const ::std::vector<edm::Ptr<reco::PFCluster> >*)arg[0]);
}

static  void method_14426( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::Ptr<reco::PFCluster> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::edm::Ptr<reco::PFCluster>*)arg[1]);
}

static  void method_14427( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::Ptr<reco::PFCluster>*,std::vector<edm::Ptr<reco::PFCluster> > >)((((::std::vector<edm::Ptr<reco::PFCluster> >*)o)->begin)());
  else   (((::std::vector<edm::Ptr<reco::PFCluster> >*)o)->begin)();
}

static  void method_14428( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const edm::Ptr<reco::PFCluster>*,std::vector<edm::Ptr<reco::PFCluster> > >)((((const ::std::vector<edm::Ptr<reco::PFCluster> >*)o)->begin)());
  else   (((const ::std::vector<edm::Ptr<reco::PFCluster> >*)o)->begin)();
}

static  void method_14429( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::Ptr<reco::PFCluster>*,std::vector<edm::Ptr<reco::PFCluster> > >)((((::std::vector<edm::Ptr<reco::PFCluster> >*)o)->end)());
  else   (((::std::vector<edm::Ptr<reco::PFCluster> >*)o)->end)();
}

static  void method_14430( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const edm::Ptr<reco::PFCluster>*,std::vector<edm::Ptr<reco::PFCluster> > >)((((const ::std::vector<edm::Ptr<reco::PFCluster> >*)o)->end)());
  else   (((const ::std::vector<edm::Ptr<reco::PFCluster> >*)o)->end)();
}

static  void method_14435( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<edm::Ptr<reco::PFCluster> >*)o)->size)());
  else   (((const ::std::vector<edm::Ptr<reco::PFCluster> >*)o)->size)();
}

static  void method_14436( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<edm::Ptr<reco::PFCluster> >*)o)->max_size)());
  else   (((const ::std::vector<edm::Ptr<reco::PFCluster> >*)o)->max_size)();
}

static  void method_14437( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<edm::Ptr<reco::PFCluster> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<edm::Ptr<reco::PFCluster> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::edm::Ptr<reco::PFCluster>*)arg[1]);
  }
}

static  void method_14438( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<edm::Ptr<reco::PFCluster> >*)o)->capacity)());
  else   (((const ::std::vector<edm::Ptr<reco::PFCluster> >*)o)->capacity)();
}

static  void method_14439( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<edm::Ptr<reco::PFCluster> >*)o)->empty)());
  else   (((const ::std::vector<edm::Ptr<reco::PFCluster> >*)o)->empty)();
}

static  void method_14440( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::Ptr<reco::PFCluster> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_14441( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::Ptr<reco::PFCluster> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<edm::Ptr<reco::PFCluster> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_14442( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::Ptr<reco::PFCluster> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<edm::Ptr<reco::PFCluster> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_14444( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::Ptr<reco::PFCluster> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<edm::Ptr<reco::PFCluster> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_14445( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::Ptr<reco::PFCluster> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<edm::Ptr<reco::PFCluster> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_14446( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::Ptr<reco::PFCluster> >*)o)->front)();
  else   (((::std::vector<edm::Ptr<reco::PFCluster> >*)o)->front)();
}

static  void method_14447( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::Ptr<reco::PFCluster> >*)o)->front)();
  else   (((const ::std::vector<edm::Ptr<reco::PFCluster> >*)o)->front)();
}

static  void method_14448( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::Ptr<reco::PFCluster> >*)o)->back)();
  else   (((::std::vector<edm::Ptr<reco::PFCluster> >*)o)->back)();
}

static  void method_14449( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::Ptr<reco::PFCluster> >*)o)->back)();
  else   (((const ::std::vector<edm::Ptr<reco::PFCluster> >*)o)->back)();
}

static  void method_14450( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<edm::Ptr<reco::PFCluster> >*)o)->data)());
  else   (((::std::vector<edm::Ptr<reco::PFCluster> >*)o)->data)();
}

static  void method_14451( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<edm::Ptr<reco::PFCluster> >*)o)->data)());
  else   (((const ::std::vector<edm::Ptr<reco::PFCluster> >*)o)->data)();
}

static  void method_14452( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::Ptr<reco::PFCluster> >*)o)->push_back)(*(const ::edm::Ptr<reco::PFCluster>*)arg[0]);
}

static  void method_14453( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<edm::Ptr<reco::PFCluster> >*)o)->pop_back)();
}

static  void method_14454( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::Ptr<reco::PFCluster>*,std::vector<edm::Ptr<reco::PFCluster> > >)((((::std::vector<edm::Ptr<reco::PFCluster> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<edm::Ptr<reco::PFCluster>*,std::vector<edm::Ptr<reco::PFCluster> > >*)arg[0],
    *(const ::edm::Ptr<reco::PFCluster>*)arg[1]));
  else   (((::std::vector<edm::Ptr<reco::PFCluster> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<edm::Ptr<reco::PFCluster>*,std::vector<edm::Ptr<reco::PFCluster> > >*)arg[0],
    *(const ::edm::Ptr<reco::PFCluster>*)arg[1]);
}

static  void method_14455( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::Ptr<reco::PFCluster> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<edm::Ptr<reco::PFCluster>*,std::vector<edm::Ptr<reco::PFCluster> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::edm::Ptr<reco::PFCluster>*)arg[2]);
}

static  void method_14456( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::Ptr<reco::PFCluster>*,std::vector<edm::Ptr<reco::PFCluster> > >)((((::std::vector<edm::Ptr<reco::PFCluster> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::Ptr<reco::PFCluster>*,std::vector<edm::Ptr<reco::PFCluster> > >*)arg[0]));
  else   (((::std::vector<edm::Ptr<reco::PFCluster> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::Ptr<reco::PFCluster>*,std::vector<edm::Ptr<reco::PFCluster> > >*)arg[0]);
}

static  void method_14457( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::Ptr<reco::PFCluster>*,std::vector<edm::Ptr<reco::PFCluster> > >)((((::std::vector<edm::Ptr<reco::PFCluster> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::Ptr<reco::PFCluster>*,std::vector<edm::Ptr<reco::PFCluster> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<edm::Ptr<reco::PFCluster>*,std::vector<edm::Ptr<reco::PFCluster> > >*)arg[1]));
  else   (((::std::vector<edm::Ptr<reco::PFCluster> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::Ptr<reco::PFCluster>*,std::vector<edm::Ptr<reco::PFCluster> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<edm::Ptr<reco::PFCluster>*,std::vector<edm::Ptr<reco::PFCluster> > >*)arg[1]);
}

static  void method_14458( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::Ptr<reco::PFCluster> >*)o)->swap)(*(::std::vector<edm::Ptr<reco::PFCluster> >*)arg[0]);
}

static  void method_14459( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<edm::Ptr<reco::PFCluster> >*)o)->clear)();
}

static void method_newdel_2997( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<edm::Ptr<reco::PFCluster> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<edm::Ptr<reco::PFCluster> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<edm::Ptr<reco::PFCluster> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<edm::Ptr<reco::PFCluster> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<edm::Ptr<reco::PFCluster> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x26( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<edm::Ptr<reco::PFCluster>,std::allocator<edm::Ptr<reco::PFCluster> > >")), ::Reflex::BaseOffset< ::std::vector<edm::Ptr<reco::PFCluster> >,::std::_Vector_base<edm::Ptr<reco::PFCluster>,std::allocator<edm::Ptr<reco::PFCluster> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x27( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<edm::Ptr<reco::PFCluster> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<edm::Ptr<reco::PFCluster> > >::Generate();
}

//------Dictionary for class vector<edm::Ptr<reco::PFCluster>,std::allocator<edm::Ptr<reco::PFCluster> > > -------------------------------
void __std__vector_edm__Ptr_reco__PFCluster_s__db_datamem(Reflex::Class*);
void __std__vector_edm__Ptr_reco__PFCluster_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_edm__Ptr_reco__PFCluster_s__datamem_bld(&__std__vector_edm__Ptr_reco__PFCluster_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_edm__Ptr_reco__PFCluster_s__funcmem_bld(&__std__vector_edm__Ptr_reco__PFCluster_s__db_funcmem);
void __std__vector_edm__Ptr_reco__PFCluster_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<edm::Ptr<reco::PFCluster> >"), typeid(::std::vector<edm::Ptr<reco::PFCluster> >), sizeof(::std::vector<edm::Ptr<reco::PFCluster> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2494, ::Reflex::BaseOffset< ::std::vector<edm::Ptr<reco::PFCluster> >, ::std::_Vector_base<edm::Ptr<reco::PFCluster>,std::allocator<edm::Ptr<reco::PFCluster> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_4990, Reflex::Literal("std::vector<edm::Ptr<reco::PFCluster> >::_Alloc_value_type"))
  .AddTypedef(type_2494, Reflex::Literal("std::vector<edm::Ptr<reco::PFCluster> >::_Base"))
  .AddTypedef(type_3304, Reflex::Literal("std::vector<edm::Ptr<reco::PFCluster> >::_Tp_alloc_type"))
  .AddTypedef(type_8474, Reflex::Literal("std::vector<edm::Ptr<reco::PFCluster> >::_Alloc_traits"))
  .AddTypedef(type_4990, Reflex::Literal("std::vector<edm::Ptr<reco::PFCluster> >::value_type"))
  .AddTypedef(type_9533, Reflex::Literal("std::vector<edm::Ptr<reco::PFCluster> >::pointer"))
  .AddTypedef(type_14407, Reflex::Literal("std::vector<edm::Ptr<reco::PFCluster> >::const_pointer"))
  .AddTypedef(type_14409, Reflex::Literal("std::vector<edm::Ptr<reco::PFCluster> >::reference"))
  .AddTypedef(type_14411, Reflex::Literal("std::vector<edm::Ptr<reco::PFCluster> >::const_reference"))
  .AddTypedef(type_8314, Reflex::Literal("std::vector<edm::Ptr<reco::PFCluster> >::iterator"))
  .AddTypedef(type_8315, Reflex::Literal("std::vector<edm::Ptr<reco::PFCluster> >::const_iterator"))
  .AddTypedef(type_3527, Reflex::Literal("std::vector<edm::Ptr<reco::PFCluster> >::const_reverse_iterator"))
  .AddTypedef(type_3528, Reflex::Literal("std::vector<edm::Ptr<reco::PFCluster> >::reverse_iterator"))
  .AddTypedef(type_3254, Reflex::Literal("std::vector<edm::Ptr<reco::PFCluster> >::size_type"))
  .AddTypedef(type_3138, Reflex::Literal("std::vector<edm::Ptr<reco::PFCluster> >::difference_type"))
  .AddTypedef(type_3304, Reflex::Literal("std::vector<edm::Ptr<reco::PFCluster> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_14420, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_34662), Reflex::Literal("vector"), constructor_14421, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3254, type_14411, type_34662), Reflex::Literal("vector"), constructor_14422, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_36062), Reflex::Literal("vector"), constructor_14423, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_14424, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2997, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x26, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x27, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_edm__Ptr_reco__PFCluster_s__funcmem_bld);
}

//------Delayed data member builder for class vector<edm::Ptr<reco::PFCluster>,std::allocator<edm::Ptr<reco::PFCluster> > > -------------------
void __std__vector_edm__Ptr_reco__PFCluster_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<edm::Ptr<reco::PFCluster>,std::allocator<edm::Ptr<reco::PFCluster> > > -------------------
void __std__vector_edm__Ptr_reco__PFCluster_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_36063, type_36062), Reflex::Literal("operator="), operator_14425, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_3254, type_14411), Reflex::Literal("assign"), method_14426, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8314), Reflex::Literal("begin"), method_14427, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8315), Reflex::Literal("begin"), method_14428, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8314), Reflex::Literal("end"), method_14429, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8315), Reflex::Literal("end"), method_14430, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3254), Reflex::Literal("size"), method_14435, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3254), Reflex::Literal("max_size"), method_14436, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_3254, type_4990), Reflex::Literal("resize"), method_14437, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3254), Reflex::Literal("capacity"), method_14438, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("empty"), method_14439, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_3254), Reflex::Literal("reserve"), method_14440, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14409, type_3254), Reflex::Literal("operator[]"), operator_14441, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14411, type_3254), Reflex::Literal("operator[]"), operator_14442, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14409, type_3254), Reflex::Literal("at"), method_14444, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14411, type_3254), Reflex::Literal("at"), method_14445, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14409), Reflex::Literal("front"), method_14446, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14411), Reflex::Literal("front"), method_14447, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14409), Reflex::Literal("back"), method_14448, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14411), Reflex::Literal("back"), method_14449, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9533), Reflex::Literal("data"), method_14450, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14407), Reflex::Literal("data"), method_14451, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_14411), Reflex::Literal("push_back"), method_14452, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694), Reflex::Literal("pop_back"), method_14453, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8314, type_8314, type_14411), Reflex::Literal("insert"), method_14454, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_8314, type_3254, type_14411), Reflex::Literal("insert"), method_14455, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8314, type_8314), Reflex::Literal("erase"), method_14456, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8314, type_8314, type_8314), Reflex::Literal("erase"), method_14457, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_36063), Reflex::Literal("swap"), method_14458, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694), Reflex::Literal("clear"), method_14459, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class CastorJetID -------------------------------
static void destructor_27878(void*, void * o, const std::vector<void*>&, void *) {
(((::reco::CastorJetID*)o)->::reco::CastorJetID::~CastorJetID)();
}
static  void operator_27879( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::reco::CastorJetID*)o)->operator=)(*(const ::reco::CastorJetID*)arg[0]);
  else   (((::reco::CastorJetID*)o)->operator=)(*(const ::reco::CastorJetID*)arg[0]);
}

static void constructor_27880( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::CastorJetID(*(const ::reco::CastorJetID*)arg[0]);
  else ::new(mem) ::reco::CastorJetID(*(const ::reco::CastorJetID*)arg[0]);
}

static void constructor_27881( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::CastorJetID();
  else ::new(mem) ::reco::CastorJetID();
}

static void method_newdel_7846( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::reco::CastorJetID >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::reco::CastorJetID >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::reco::CastorJetID >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::reco::CastorJetID >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::reco::CastorJetID >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class CastorJetID -------------------------------
void __reco__CastorJetID_db_datamem(Reflex::Class*);
void __reco__CastorJetID_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __reco__CastorJetID_datamem_bld(&__reco__CastorJetID_db_datamem);
Reflex::GenreflexMemberBuilder __reco__CastorJetID_funcmem_bld(&__reco__CastorJetID_db_funcmem);
void __reco__CastorJetID_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("reco::CastorJetID"), typeid(::reco::CastorJetID), sizeof(::reco::CastorJetID), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~CastorJetID"), destructor_27878, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14540, type_14542), Reflex::Literal("operator="), operator_27879, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_14542), Reflex::Literal("CastorJetID"), constructor_27880, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("CastorJetID"), constructor_27881, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_7846, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__reco__CastorJetID_datamem_bld);
}

//------Delayed data member builder for class CastorJetID -------------------
void __reco__CastorJetID_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_101, Reflex::Literal("emEnergy"), OffsetOf(__shadow__::__reco__CastorJetID, emEnergy), ::Reflex::PUBLIC)
  .AddDataMember(type_101, Reflex::Literal("hadEnergy"), OffsetOf(__shadow__::__reco__CastorJetID, hadEnergy), ::Reflex::PUBLIC)
  .AddDataMember(type_101, Reflex::Literal("fem"), OffsetOf(__shadow__::__reco__CastorJetID, fem), ::Reflex::PUBLIC)
  .AddDataMember(type_101, Reflex::Literal("width"), OffsetOf(__shadow__::__reco__CastorJetID, width), ::Reflex::PUBLIC)
  .AddDataMember(type_101, Reflex::Literal("depth"), OffsetOf(__shadow__::__reco__CastorJetID, depth), ::Reflex::PUBLIC)
  .AddDataMember(type_101, Reflex::Literal("fhot"), OffsetOf(__shadow__::__reco__CastorJetID, fhot), ::Reflex::PUBLIC)
  .AddDataMember(type_101, Reflex::Literal("sigmaz"), OffsetOf(__shadow__::__reco__CastorJetID, sigmaz), ::Reflex::PUBLIC)
  .AddDataMember(type_68, Reflex::Literal("nTowers"), OffsetOf(__shadow__::__reco__CastorJetID, nTowers), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class CastorJetID -------------------
void __reco__CastorJetID_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class vector<reco::CastorJetID,std::allocator<reco::CastorJetID> > -------------------------------
static void constructor_14551( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::CastorJetID>();
  else ::new(mem) ::std::vector<reco::CastorJetID>();
}

static void constructor_14552( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::CastorJetID>(*(const ::std::allocator<reco::CastorJetID>*)arg[0]);
  else ::new(mem) ::std::vector<reco::CastorJetID>(*(const ::std::allocator<reco::CastorJetID>*)arg[0]);
}

static void constructor_14553( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::CastorJetID>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<reco::CastorJetID>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::CastorJetID>(*(::std::size_t*)arg[0],
      *(const ::reco::CastorJetID*)arg[1]);
  else ::new(mem) ::std::vector<reco::CastorJetID>(*(::std::size_t*)arg[0],
      *(const ::reco::CastorJetID*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::CastorJetID>(*(::std::size_t*)arg[0],
      *(const ::reco::CastorJetID*)arg[1],
      *(const ::std::allocator<reco::CastorJetID>*)arg[2]);
  else ::new(mem) ::std::vector<reco::CastorJetID>(*(::std::size_t*)arg[0],
      *(const ::reco::CastorJetID*)arg[1],
      *(const ::std::allocator<reco::CastorJetID>*)arg[2]);
  }
}

static void constructor_14554( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::CastorJetID>(*(const ::std::vector<reco::CastorJetID>*)arg[0]);
  else ::new(mem) ::std::vector<reco::CastorJetID>(*(const ::std::vector<reco::CastorJetID>*)arg[0]);
}

static void destructor_14555(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<reco::CastorJetID>*)o)->::std::vector<reco::CastorJetID>::~vector)();
}
static  void operator_14556( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::CastorJetID>*)o)->operator=)(*(const ::std::vector<reco::CastorJetID>*)arg[0]);
  else   (((::std::vector<reco::CastorJetID>*)o)->operator=)(*(const ::std::vector<reco::CastorJetID>*)arg[0]);
}

static  void method_14557( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::CastorJetID>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::reco::CastorJetID*)arg[1]);
}

static  void method_14558( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::CastorJetID*,std::vector<reco::CastorJetID> >)((((::std::vector<reco::CastorJetID>*)o)->begin)());
  else   (((::std::vector<reco::CastorJetID>*)o)->begin)();
}

static  void method_14559( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const reco::CastorJetID*,std::vector<reco::CastorJetID> >)((((const ::std::vector<reco::CastorJetID>*)o)->begin)());
  else   (((const ::std::vector<reco::CastorJetID>*)o)->begin)();
}

static  void method_14560( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::CastorJetID*,std::vector<reco::CastorJetID> >)((((::std::vector<reco::CastorJetID>*)o)->end)());
  else   (((::std::vector<reco::CastorJetID>*)o)->end)();
}

static  void method_14561( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const reco::CastorJetID*,std::vector<reco::CastorJetID> >)((((const ::std::vector<reco::CastorJetID>*)o)->end)());
  else   (((const ::std::vector<reco::CastorJetID>*)o)->end)();
}

static  void method_14566( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<reco::CastorJetID>*)o)->size)());
  else   (((const ::std::vector<reco::CastorJetID>*)o)->size)();
}

static  void method_14567( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<reco::CastorJetID>*)o)->max_size)());
  else   (((const ::std::vector<reco::CastorJetID>*)o)->max_size)();
}

static  void method_14568( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<reco::CastorJetID>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<reco::CastorJetID>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::reco::CastorJetID*)arg[1]);
  }
}

static  void method_14569( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<reco::CastorJetID>*)o)->capacity)());
  else   (((const ::std::vector<reco::CastorJetID>*)o)->capacity)();
}

static  void method_14570( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<reco::CastorJetID>*)o)->empty)());
  else   (((const ::std::vector<reco::CastorJetID>*)o)->empty)();
}

static  void method_14571( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::CastorJetID>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_14572( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::CastorJetID>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<reco::CastorJetID>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_14573( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::CastorJetID>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<reco::CastorJetID>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_14575( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::CastorJetID>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<reco::CastorJetID>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_14576( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::CastorJetID>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<reco::CastorJetID>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_14577( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::CastorJetID>*)o)->front)();
  else   (((::std::vector<reco::CastorJetID>*)o)->front)();
}

static  void method_14578( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::CastorJetID>*)o)->front)();
  else   (((const ::std::vector<reco::CastorJetID>*)o)->front)();
}

static  void method_14579( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::CastorJetID>*)o)->back)();
  else   (((::std::vector<reco::CastorJetID>*)o)->back)();
}

static  void method_14580( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::CastorJetID>*)o)->back)();
  else   (((const ::std::vector<reco::CastorJetID>*)o)->back)();
}

static  void method_14581( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<reco::CastorJetID>*)o)->data)());
  else   (((::std::vector<reco::CastorJetID>*)o)->data)();
}

static  void method_14582( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<reco::CastorJetID>*)o)->data)());
  else   (((const ::std::vector<reco::CastorJetID>*)o)->data)();
}

static  void method_14583( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::CastorJetID>*)o)->push_back)(*(const ::reco::CastorJetID*)arg[0]);
}

static  void method_14584( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<reco::CastorJetID>*)o)->pop_back)();
}

static  void method_14585( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::CastorJetID*,std::vector<reco::CastorJetID> >)((((::std::vector<reco::CastorJetID>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<reco::CastorJetID*,std::vector<reco::CastorJetID> >*)arg[0],
    *(const ::reco::CastorJetID*)arg[1]));
  else   (((::std::vector<reco::CastorJetID>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<reco::CastorJetID*,std::vector<reco::CastorJetID> >*)arg[0],
    *(const ::reco::CastorJetID*)arg[1]);
}

static  void method_14586( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::CastorJetID>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<reco::CastorJetID*,std::vector<reco::CastorJetID> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::reco::CastorJetID*)arg[2]);
}

static  void method_14587( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::CastorJetID*,std::vector<reco::CastorJetID> >)((((::std::vector<reco::CastorJetID>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::CastorJetID*,std::vector<reco::CastorJetID> >*)arg[0]));
  else   (((::std::vector<reco::CastorJetID>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::CastorJetID*,std::vector<reco::CastorJetID> >*)arg[0]);
}

static  void method_14588( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::CastorJetID*,std::vector<reco::CastorJetID> >)((((::std::vector<reco::CastorJetID>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::CastorJetID*,std::vector<reco::CastorJetID> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<reco::CastorJetID*,std::vector<reco::CastorJetID> >*)arg[1]));
  else   (((::std::vector<reco::CastorJetID>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::CastorJetID*,std::vector<reco::CastorJetID> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<reco::CastorJetID*,std::vector<reco::CastorJetID> >*)arg[1]);
}

static  void method_14589( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::CastorJetID>*)o)->swap)(*(::std::vector<reco::CastorJetID>*)arg[0]);
}

static  void method_14590( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<reco::CastorJetID>*)o)->clear)();
}

static void method_newdel_2999( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<reco::CastorJetID> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<reco::CastorJetID> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<reco::CastorJetID> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<reco::CastorJetID> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<reco::CastorJetID> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x30( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<reco::CastorJetID,std::allocator<reco::CastorJetID> >")), ::Reflex::BaseOffset< ::std::vector<reco::CastorJetID>,::std::_Vector_base<reco::CastorJetID,std::allocator<reco::CastorJetID> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x31( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<reco::CastorJetID> >::Generate();
  else ::Reflex::Proxy< ::std::vector<reco::CastorJetID> >::Generate();
}

//------Dictionary for class vector<reco::CastorJetID,std::allocator<reco::CastorJetID> > -------------------------------
void __std__vector_reco__CastorJetID__db_datamem(Reflex::Class*);
void __std__vector_reco__CastorJetID__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_reco__CastorJetID__datamem_bld(&__std__vector_reco__CastorJetID__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_reco__CastorJetID__funcmem_bld(&__std__vector_reco__CastorJetID__db_funcmem);
void __std__vector_reco__CastorJetID__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<reco::CastorJetID>"), typeid(::std::vector<reco::CastorJetID>), sizeof(::std::vector<reco::CastorJetID>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2496, ::Reflex::BaseOffset< ::std::vector<reco::CastorJetID>, ::std::_Vector_base<reco::CastorJetID,std::allocator<reco::CastorJetID> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_7846, Reflex::Literal("std::vector<reco::CastorJetID>::_Alloc_value_type"))
  .AddTypedef(type_2496, Reflex::Literal("std::vector<reco::CastorJetID>::_Base"))
  .AddTypedef(type_3306, Reflex::Literal("std::vector<reco::CastorJetID>::_Tp_alloc_type"))
  .AddTypedef(type_8476, Reflex::Literal("std::vector<reco::CastorJetID>::_Alloc_traits"))
  .AddTypedef(type_7846, Reflex::Literal("std::vector<reco::CastorJetID>::value_type"))
  .AddTypedef(type_9571, Reflex::Literal("std::vector<reco::CastorJetID>::pointer"))
  .AddTypedef(type_14538, Reflex::Literal("std::vector<reco::CastorJetID>::const_pointer"))
  .AddTypedef(type_14540, Reflex::Literal("std::vector<reco::CastorJetID>::reference"))
  .AddTypedef(type_14542, Reflex::Literal("std::vector<reco::CastorJetID>::const_reference"))
  .AddTypedef(type_8319, Reflex::Literal("std::vector<reco::CastorJetID>::iterator"))
  .AddTypedef(type_8320, Reflex::Literal("std::vector<reco::CastorJetID>::const_iterator"))
  .AddTypedef(type_3531, Reflex::Literal("std::vector<reco::CastorJetID>::const_reverse_iterator"))
  .AddTypedef(type_3532, Reflex::Literal("std::vector<reco::CastorJetID>::reverse_iterator"))
  .AddTypedef(type_3254, Reflex::Literal("std::vector<reco::CastorJetID>::size_type"))
  .AddTypedef(type_3138, Reflex::Literal("std::vector<reco::CastorJetID>::difference_type"))
  .AddTypedef(type_3306, Reflex::Literal("std::vector<reco::CastorJetID>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_14551, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_34688), Reflex::Literal("vector"), constructor_14552, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3254, type_14542, type_34688), Reflex::Literal("vector"), constructor_14553, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20858), Reflex::Literal("vector"), constructor_14554, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_14555, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2999, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x30, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x31, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_reco__CastorJetID__funcmem_bld);
}

//------Delayed data member builder for class vector<reco::CastorJetID,std::allocator<reco::CastorJetID> > -------------------
void __std__vector_reco__CastorJetID__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<reco::CastorJetID,std::allocator<reco::CastorJetID> > -------------------
void __std__vector_reco__CastorJetID__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_36069, type_20858), Reflex::Literal("operator="), operator_14556, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_3254, type_14542), Reflex::Literal("assign"), method_14557, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8319), Reflex::Literal("begin"), method_14558, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8320), Reflex::Literal("begin"), method_14559, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8319), Reflex::Literal("end"), method_14560, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8320), Reflex::Literal("end"), method_14561, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3254), Reflex::Literal("size"), method_14566, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3254), Reflex::Literal("max_size"), method_14567, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_3254, type_7846), Reflex::Literal("resize"), method_14568, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3254), Reflex::Literal("capacity"), method_14569, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("empty"), method_14570, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_3254), Reflex::Literal("reserve"), method_14571, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14540, type_3254), Reflex::Literal("operator[]"), operator_14572, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14542, type_3254), Reflex::Literal("operator[]"), operator_14573, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14540, type_3254), Reflex::Literal("at"), method_14575, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14542, type_3254), Reflex::Literal("at"), method_14576, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14540), Reflex::Literal("front"), method_14577, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14542), Reflex::Literal("front"), method_14578, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14540), Reflex::Literal("back"), method_14579, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14542), Reflex::Literal("back"), method_14580, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9571), Reflex::Literal("data"), method_14581, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14538), Reflex::Literal("data"), method_14582, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_14542), Reflex::Literal("push_back"), method_14583, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694), Reflex::Literal("pop_back"), method_14584, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8319, type_8319, type_14542), Reflex::Literal("insert"), method_14585, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_8319, type_3254, type_14542), Reflex::Literal("insert"), method_14586, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8319, type_8319), Reflex::Literal("erase"), method_14587, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8319, type_8319, type_8319), Reflex::Literal("erase"), method_14588, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_36069), Reflex::Literal("swap"), method_14589, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694), Reflex::Literal("clear"), method_14590, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class JetID -------------------------------
static void destructor_27829(void*, void * o, const std::vector<void*>&, void *) {
(((::reco::JetID*)o)->::reco::JetID::~JetID)();
}
static  void operator_27830( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::reco::JetID*)o)->operator=)(*(const ::reco::JetID*)arg[0]);
  else   (((::reco::JetID*)o)->operator=)(*(const ::reco::JetID*)arg[0]);
}

static void constructor_27831( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::JetID(*(const ::reco::JetID*)arg[0]);
  else ::new(mem) ::reco::JetID(*(const ::reco::JetID*)arg[0]);
}

static void constructor_27832( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::JetID();
  else ::new(mem) ::reco::JetID();
}

static void method_newdel_7841( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::reco::JetID >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::reco::JetID >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::reco::JetID >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::reco::JetID >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::reco::JetID >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class JetID -------------------------------
void __reco__JetID_db_datamem(Reflex::Class*);
void __reco__JetID_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __reco__JetID_datamem_bld(&__reco__JetID_db_datamem);
Reflex::GenreflexMemberBuilder __reco__JetID_funcmem_bld(&__reco__JetID_db_funcmem);
void __reco__JetID_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("reco::JetID"), typeid(::reco::JetID), sizeof(::reco::JetID), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~JetID"), destructor_27829, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14605, type_14607), Reflex::Literal("operator="), operator_27830, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_14607), Reflex::Literal("JetID"), constructor_27831, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("JetID"), constructor_27832, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_7841, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__reco__JetID_datamem_bld);
}

//------Delayed data member builder for class JetID -------------------
void __reco__JetID_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_894, Reflex::Literal("fHPD"), OffsetOf(__shadow__::__reco__JetID, fHPD), ::Reflex::PUBLIC)
  .AddDataMember(type_894, Reflex::Literal("fRBX"), OffsetOf(__shadow__::__reco__JetID, fRBX), ::Reflex::PUBLIC)
  .AddDataMember(type_237, Reflex::Literal("n90Hits"), OffsetOf(__shadow__::__reco__JetID, n90Hits), ::Reflex::PUBLIC)
  .AddDataMember(type_894, Reflex::Literal("fSubDetector1"), OffsetOf(__shadow__::__reco__JetID, fSubDetector1), ::Reflex::PUBLIC)
  .AddDataMember(type_894, Reflex::Literal("fSubDetector2"), OffsetOf(__shadow__::__reco__JetID, fSubDetector2), ::Reflex::PUBLIC)
  .AddDataMember(type_894, Reflex::Literal("fSubDetector3"), OffsetOf(__shadow__::__reco__JetID, fSubDetector3), ::Reflex::PUBLIC)
  .AddDataMember(type_894, Reflex::Literal("fSubDetector4"), OffsetOf(__shadow__::__reco__JetID, fSubDetector4), ::Reflex::PUBLIC)
  .AddDataMember(type_894, Reflex::Literal("restrictedEMF"), OffsetOf(__shadow__::__reco__JetID, restrictedEMF), ::Reflex::PUBLIC)
  .AddDataMember(type_237, Reflex::Literal("nHCALTowers"), OffsetOf(__shadow__::__reco__JetID, nHCALTowers), ::Reflex::PUBLIC)
  .AddDataMember(type_237, Reflex::Literal("nECALTowers"), OffsetOf(__shadow__::__reco__JetID, nECALTowers), ::Reflex::PUBLIC)
  .AddDataMember(type_894, Reflex::Literal("approximatefHPD"), OffsetOf(__shadow__::__reco__JetID, approximatefHPD), ::Reflex::PUBLIC)
  .AddDataMember(type_894, Reflex::Literal("approximatefRBX"), OffsetOf(__shadow__::__reco__JetID, approximatefRBX), ::Reflex::PUBLIC)
  .AddDataMember(type_237, Reflex::Literal("hitsInN90"), OffsetOf(__shadow__::__reco__JetID, hitsInN90), ::Reflex::PUBLIC)
  .AddDataMember(type_237, Reflex::Literal("numberOfHits2RPC"), OffsetOf(__shadow__::__reco__JetID, numberOfHits2RPC), ::Reflex::PUBLIC)
  .AddDataMember(type_237, Reflex::Literal("numberOfHits3RPC"), OffsetOf(__shadow__::__reco__JetID, numberOfHits3RPC), ::Reflex::PUBLIC)
  .AddDataMember(type_237, Reflex::Literal("numberOfHitsRPC"), OffsetOf(__shadow__::__reco__JetID, numberOfHitsRPC), ::Reflex::PUBLIC)
  .AddDataMember(type_894, Reflex::Literal("fEB"), OffsetOf(__shadow__::__reco__JetID, fEB), ::Reflex::PUBLIC)
  .AddDataMember(type_894, Reflex::Literal("fEE"), OffsetOf(__shadow__::__reco__JetID, fEE), ::Reflex::PUBLIC)
  .AddDataMember(type_894, Reflex::Literal("fHB"), OffsetOf(__shadow__::__reco__JetID, fHB), ::Reflex::PUBLIC)
  .AddDataMember(type_894, Reflex::Literal("fHE"), OffsetOf(__shadow__::__reco__JetID, fHE), ::Reflex::PUBLIC)
  .AddDataMember(type_894, Reflex::Literal("fHO"), OffsetOf(__shadow__::__reco__JetID, fHO), ::Reflex::PUBLIC)
  .AddDataMember(type_894, Reflex::Literal("fLong"), OffsetOf(__shadow__::__reco__JetID, fLong), ::Reflex::PUBLIC)
  .AddDataMember(type_894, Reflex::Literal("fShort"), OffsetOf(__shadow__::__reco__JetID, fShort), ::Reflex::PUBLIC)
  .AddDataMember(type_894, Reflex::Literal("fLS"), OffsetOf(__shadow__::__reco__JetID, fLS), ::Reflex::PUBLIC)
  .AddDataMember(type_894, Reflex::Literal("fHFOOT"), OffsetOf(__shadow__::__reco__JetID, fHFOOT), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class JetID -------------------
void __reco__JetID_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class vector<reco::JetID,std::allocator<reco::JetID> > -------------------------------
static void constructor_14616( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::JetID>();
  else ::new(mem) ::std::vector<reco::JetID>();
}

static void constructor_14617( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::JetID>(*(const ::std::allocator<reco::JetID>*)arg[0]);
  else ::new(mem) ::std::vector<reco::JetID>(*(const ::std::allocator<reco::JetID>*)arg[0]);
}

static void constructor_14618( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::JetID>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<reco::JetID>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::JetID>(*(::std::size_t*)arg[0],
      *(const ::reco::JetID*)arg[1]);
  else ::new(mem) ::std::vector<reco::JetID>(*(::std::size_t*)arg[0],
      *(const ::reco::JetID*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::JetID>(*(::std::size_t*)arg[0],
      *(const ::reco::JetID*)arg[1],
      *(const ::std::allocator<reco::JetID>*)arg[2]);
  else ::new(mem) ::std::vector<reco::JetID>(*(::std::size_t*)arg[0],
      *(const ::reco::JetID*)arg[1],
      *(const ::std::allocator<reco::JetID>*)arg[2]);
  }
}

static void constructor_14619( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::JetID>(*(const ::std::vector<reco::JetID>*)arg[0]);
  else ::new(mem) ::std::vector<reco::JetID>(*(const ::std::vector<reco::JetID>*)arg[0]);
}

static void destructor_14620(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<reco::JetID>*)o)->::std::vector<reco::JetID>::~vector)();
}
static  void operator_14621( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::JetID>*)o)->operator=)(*(const ::std::vector<reco::JetID>*)arg[0]);
  else   (((::std::vector<reco::JetID>*)o)->operator=)(*(const ::std::vector<reco::JetID>*)arg[0]);
}

static  void method_14622( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::JetID>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::reco::JetID*)arg[1]);
}

static  void method_14623( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::JetID*,std::vector<reco::JetID> >)((((::std::vector<reco::JetID>*)o)->begin)());
  else   (((::std::vector<reco::JetID>*)o)->begin)();
}

static  void method_14624( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const reco::JetID*,std::vector<reco::JetID> >)((((const ::std::vector<reco::JetID>*)o)->begin)());
  else   (((const ::std::vector<reco::JetID>*)o)->begin)();
}

static  void method_14625( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::JetID*,std::vector<reco::JetID> >)((((::std::vector<reco::JetID>*)o)->end)());
  else   (((::std::vector<reco::JetID>*)o)->end)();
}

static  void method_14626( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const reco::JetID*,std::vector<reco::JetID> >)((((const ::std::vector<reco::JetID>*)o)->end)());
  else   (((const ::std::vector<reco::JetID>*)o)->end)();
}

static  void method_14631( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<reco::JetID>*)o)->size)());
  else   (((const ::std::vector<reco::JetID>*)o)->size)();
}

static  void method_14632( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<reco::JetID>*)o)->max_size)());
  else   (((const ::std::vector<reco::JetID>*)o)->max_size)();
}

static  void method_14633( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<reco::JetID>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<reco::JetID>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::reco::JetID*)arg[1]);
  }
}

static  void method_14634( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<reco::JetID>*)o)->capacity)());
  else   (((const ::std::vector<reco::JetID>*)o)->capacity)();
}

static  void method_14635( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<reco::JetID>*)o)->empty)());
  else   (((const ::std::vector<reco::JetID>*)o)->empty)();
}

static  void method_14636( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::JetID>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_14637( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::JetID>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<reco::JetID>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_14638( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::JetID>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<reco::JetID>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_14640( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::JetID>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<reco::JetID>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_14641( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::JetID>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<reco::JetID>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_14642( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::JetID>*)o)->front)();
  else   (((::std::vector<reco::JetID>*)o)->front)();
}

static  void method_14643( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::JetID>*)o)->front)();
  else   (((const ::std::vector<reco::JetID>*)o)->front)();
}

static  void method_14644( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::JetID>*)o)->back)();
  else   (((::std::vector<reco::JetID>*)o)->back)();
}

static  void method_14645( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::JetID>*)o)->back)();
  else   (((const ::std::vector<reco::JetID>*)o)->back)();
}

static  void method_14646( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<reco::JetID>*)o)->data)());
  else   (((::std::vector<reco::JetID>*)o)->data)();
}

static  void method_14647( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<reco::JetID>*)o)->data)());
  else   (((const ::std::vector<reco::JetID>*)o)->data)();
}

static  void method_14648( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::JetID>*)o)->push_back)(*(const ::reco::JetID*)arg[0]);
}

static  void method_14649( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<reco::JetID>*)o)->pop_back)();
}

static  void method_14650( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::JetID*,std::vector<reco::JetID> >)((((::std::vector<reco::JetID>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<reco::JetID*,std::vector<reco::JetID> >*)arg[0],
    *(const ::reco::JetID*)arg[1]));
  else   (((::std::vector<reco::JetID>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<reco::JetID*,std::vector<reco::JetID> >*)arg[0],
    *(const ::reco::JetID*)arg[1]);
}

static  void method_14651( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::JetID>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<reco::JetID*,std::vector<reco::JetID> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::reco::JetID*)arg[2]);
}

static  void method_14652( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::JetID*,std::vector<reco::JetID> >)((((::std::vector<reco::JetID>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::JetID*,std::vector<reco::JetID> >*)arg[0]));
  else   (((::std::vector<reco::JetID>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::JetID*,std::vector<reco::JetID> >*)arg[0]);
}

static  void method_14653( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::JetID*,std::vector<reco::JetID> >)((((::std::vector<reco::JetID>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::JetID*,std::vector<reco::JetID> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<reco::JetID*,std::vector<reco::JetID> >*)arg[1]));
  else   (((::std::vector<reco::JetID>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::JetID*,std::vector<reco::JetID> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<reco::JetID*,std::vector<reco::JetID> >*)arg[1]);
}

static  void method_14654( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::JetID>*)o)->swap)(*(::std::vector<reco::JetID>*)arg[0]);
}

static  void method_14655( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<reco::JetID>*)o)->clear)();
}

static void method_newdel_3000( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<reco::JetID> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<reco::JetID> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<reco::JetID> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<reco::JetID> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<reco::JetID> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x34( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<reco::JetID,std::allocator<reco::JetID> >")), ::Reflex::BaseOffset< ::std::vector<reco::JetID>,::std::_Vector_base<reco::JetID,std::allocator<reco::JetID> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x35( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<reco::JetID> >::Generate();
  else ::Reflex::Proxy< ::std::vector<reco::JetID> >::Generate();
}

//------Dictionary for class vector<reco::JetID,std::allocator<reco::JetID> > -------------------------------
void __std__vector_reco__JetID__db_datamem(Reflex::Class*);
void __std__vector_reco__JetID__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_reco__JetID__datamem_bld(&__std__vector_reco__JetID__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_reco__JetID__funcmem_bld(&__std__vector_reco__JetID__db_funcmem);
void __std__vector_reco__JetID__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<reco::JetID>"), typeid(::std::vector<reco::JetID>), sizeof(::std::vector<reco::JetID>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2497, ::Reflex::BaseOffset< ::std::vector<reco::JetID>, ::std::_Vector_base<reco::JetID,std::allocator<reco::JetID> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_7841, Reflex::Literal("std::vector<reco::JetID>::_Alloc_value_type"))
  .AddTypedef(type_2497, Reflex::Literal("std::vector<reco::JetID>::_Base"))
  .AddTypedef(type_3307, Reflex::Literal("std::vector<reco::JetID>::_Tp_alloc_type"))
  .AddTypedef(type_8477, Reflex::Literal("std::vector<reco::JetID>::_Alloc_traits"))
  .AddTypedef(type_7841, Reflex::Literal("std::vector<reco::JetID>::value_type"))
  .AddTypedef(type_9590, Reflex::Literal("std::vector<reco::JetID>::pointer"))
  .AddTypedef(type_14603, Reflex::Literal("std::vector<reco::JetID>::const_pointer"))
  .AddTypedef(type_14605, Reflex::Literal("std::vector<reco::JetID>::reference"))
  .AddTypedef(type_14607, Reflex::Literal("std::vector<reco::JetID>::const_reference"))
  .AddTypedef(type_8321, Reflex::Literal("std::vector<reco::JetID>::iterator"))
  .AddTypedef(type_8322, Reflex::Literal("std::vector<reco::JetID>::const_iterator"))
  .AddTypedef(type_3533, Reflex::Literal("std::vector<reco::JetID>::const_reverse_iterator"))
  .AddTypedef(type_3534, Reflex::Literal("std::vector<reco::JetID>::reverse_iterator"))
  .AddTypedef(type_3254, Reflex::Literal("std::vector<reco::JetID>::size_type"))
  .AddTypedef(type_3138, Reflex::Literal("std::vector<reco::JetID>::difference_type"))
  .AddTypedef(type_3307, Reflex::Literal("std::vector<reco::JetID>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_14616, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_34701), Reflex::Literal("vector"), constructor_14617, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3254, type_14607, type_34701), Reflex::Literal("vector"), constructor_14618, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20870), Reflex::Literal("vector"), constructor_14619, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_14620, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3000, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x34, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x35, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_reco__JetID__funcmem_bld);
}

//------Delayed data member builder for class vector<reco::JetID,std::allocator<reco::JetID> > -------------------
void __std__vector_reco__JetID__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<reco::JetID,std::allocator<reco::JetID> > -------------------
void __std__vector_reco__JetID__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_36071, type_20870), Reflex::Literal("operator="), operator_14621, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_3254, type_14607), Reflex::Literal("assign"), method_14622, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8321), Reflex::Literal("begin"), method_14623, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8322), Reflex::Literal("begin"), method_14624, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8321), Reflex::Literal("end"), method_14625, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8322), Reflex::Literal("end"), method_14626, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3254), Reflex::Literal("size"), method_14631, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3254), Reflex::Literal("max_size"), method_14632, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_3254, type_7841), Reflex::Literal("resize"), method_14633, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3254), Reflex::Literal("capacity"), method_14634, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("empty"), method_14635, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_3254), Reflex::Literal("reserve"), method_14636, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14605, type_3254), Reflex::Literal("operator[]"), operator_14637, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14607, type_3254), Reflex::Literal("operator[]"), operator_14638, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14605, type_3254), Reflex::Literal("at"), method_14640, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14607, type_3254), Reflex::Literal("at"), method_14641, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14605), Reflex::Literal("front"), method_14642, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14607), Reflex::Literal("front"), method_14643, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14605), Reflex::Literal("back"), method_14644, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14607), Reflex::Literal("back"), method_14645, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9590), Reflex::Literal("data"), method_14646, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14603), Reflex::Literal("data"), method_14647, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_14607), Reflex::Literal("push_back"), method_14648, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694), Reflex::Literal("pop_back"), method_14649, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8321, type_8321, type_14607), Reflex::Literal("insert"), method_14650, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_8321, type_3254, type_14607), Reflex::Literal("insert"), method_14651, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8321, type_8321), Reflex::Literal("erase"), method_14652, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8321, type_8321, type_8321), Reflex::Literal("erase"), method_14653, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_36071), Reflex::Literal("swap"), method_14654, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694), Reflex::Literal("clear"), method_14655, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class PtrVector<reco::CastorJetID> -------------------------------
static void constructor_22398( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::PtrVector<reco::CastorJetID>();
  else ::new(mem) ::edm::PtrVector<reco::CastorJetID>();
}

static void constructor_22399( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::PtrVector<reco::CastorJetID>(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::PtrVector<reco::CastorJetID>(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_22400( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::PtrVector<reco::CastorJetID>(*(const ::edm::PtrVector<reco::CastorJetID>*)arg[0]);
  else ::new(mem) ::edm::PtrVector<reco::CastorJetID>(*(const ::edm::PtrVector<reco::CastorJetID>*)arg[0]);
}

static  void operator_22401( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::CastorJetID>)((((const ::edm::PtrVector<reco::CastorJetID>*)o)->operator[])(*(const unsigned long*)arg[0]));
  else   (((const ::edm::PtrVector<reco::CastorJetID>*)o)->operator[])(*(const unsigned long*)arg[0]);
}

static  void method_22402( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::PtrVectorItr<reco::CastorJetID>)((((const ::edm::PtrVector<reco::CastorJetID>*)o)->begin)());
  else   (((const ::edm::PtrVector<reco::CastorJetID>*)o)->begin)();
}

static  void method_22403( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::PtrVectorItr<reco::CastorJetID>)((((const ::edm::PtrVector<reco::CastorJetID>*)o)->end)());
  else   (((const ::edm::PtrVector<reco::CastorJetID>*)o)->end)();
}

static  void method_22404( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::PtrVector<reco::CastorJetID>*)o)->push_back)(*(const ::edm::Ptr<reco::CastorJetID>*)arg[0]);
}

static  void method_22405( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::PtrVector<reco::CastorJetID>*)o)->swap)(*(::edm::PtrVector<reco::CastorJetID>*)arg[0]);
}

static  void operator_22406( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::PtrVector<reco::CastorJetID>*)o)->operator=)(*(const ::edm::PtrVector<reco::CastorJetID>*)arg[0]);
  else   (((::edm::PtrVector<reco::CastorJetID>*)o)->operator=)(*(const ::edm::PtrVector<reco::CastorJetID>*)arg[0]);
}

static  void method_22407( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::PtrVector<reco::CastorJetID>*)o)->fillView)(*(::std::vector<const void*>*)arg[0]);
}

static  void method_22408( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::PtrVector<reco::CastorJetID>*)o)->Class_Version)());
  else   (((::edm::PtrVector<reco::CastorJetID>*)o)->Class_Version)();
}

static void destructor_22411(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::PtrVector<reco::CastorJetID>*)o)->::edm::PtrVector<reco::CastorJetID>::~PtrVector)();
}
static void method_newdel_4636( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::PtrVector<reco::CastorJetID> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::PtrVector<reco::CastorJetID> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::PtrVector<reco::CastorJetID> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::PtrVector<reco::CastorJetID> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::PtrVector<reco::CastorJetID> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x37( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::PtrVectorBase")), ::Reflex::BaseOffset< ::edm::PtrVector<reco::CastorJetID>,::edm::PtrVectorBase >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PtrVector<reco::CastorJetID> -------------------------------
void __edm__PtrVector_reco__CastorJetID__db_datamem(Reflex::Class*);
void __edm__PtrVector_reco__CastorJetID__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__PtrVector_reco__CastorJetID__datamem_bld(&__edm__PtrVector_reco__CastorJetID__db_datamem);
Reflex::GenreflexMemberBuilder __edm__PtrVector_reco__CastorJetID__funcmem_bld(&__edm__PtrVector_reco__CastorJetID__db_funcmem);
void __edm__PtrVector_reco__CastorJetID__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::PtrVector<reco::CastorJetID>"), typeid(::edm::PtrVector<reco::CastorJetID>), sizeof(::edm::PtrVector<reco::CastorJetID>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::PtrVector<reco::CastorJetID>::Class_Version())
  .AddBase(type_4894, ::Reflex::BaseOffset< ::edm::PtrVector<reco::CastorJetID>, ::edm::PtrVectorBase >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_4798, Reflex::Literal("edm::PtrVector<reco::CastorJetID>::const_iterator"))
  .AddTypedef(type_4798, Reflex::Literal("edm::PtrVector<reco::CastorJetID>::iterator"))
  .AddTypedef(type_4988, Reflex::Literal("edm::PtrVector<reco::CastorJetID>::value_type"))
  .AddTypedef(type_694, Reflex::Literal("edm::PtrVector<reco::CastorJetID>::collection_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PtrVector"), constructor_22398, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20599), Reflex::Literal("PtrVector"), constructor_22399, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39234), Reflex::Literal("PtrVector"), constructor_22400, 0, "iOther", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PtrVector"), destructor_22411, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4636, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x37, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__edm__PtrVector_reco__CastorJetID__funcmem_bld);
}

//------Delayed data member builder for class PtrVector<reco::CastorJetID> -------------------
void __edm__PtrVector_reco__CastorJetID__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class PtrVector<reco::CastorJetID> -------------------
void __edm__PtrVector_reco__CastorJetID__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4988, type_358c), Reflex::Literal("operator[]"), operator_22401, 0, "iIndex", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4798), Reflex::Literal("begin"), method_22402, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4798), Reflex::Literal("end"), method_22403, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_39235), Reflex::Literal("push_back"), method_22404, 0, "iPtr", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_39236), Reflex::Literal("swap"), method_22405, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39236, type_39234), Reflex::Literal("operator="), operator_22406, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20679), Reflex::Literal("fillView"), method_22407, 0, "pointers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_237), Reflex::Literal("Class_Version"), method_22408, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class PtrVector<reco::JetID> -------------------------------
static void constructor_22416( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::PtrVector<reco::JetID>();
  else ::new(mem) ::edm::PtrVector<reco::JetID>();
}

static void constructor_22417( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::PtrVector<reco::JetID>(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::PtrVector<reco::JetID>(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_22418( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::PtrVector<reco::JetID>(*(const ::edm::PtrVector<reco::JetID>*)arg[0]);
  else ::new(mem) ::edm::PtrVector<reco::JetID>(*(const ::edm::PtrVector<reco::JetID>*)arg[0]);
}

static  void operator_22419( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::JetID>)((((const ::edm::PtrVector<reco::JetID>*)o)->operator[])(*(const unsigned long*)arg[0]));
  else   (((const ::edm::PtrVector<reco::JetID>*)o)->operator[])(*(const unsigned long*)arg[0]);
}

static  void method_22420( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::PtrVectorItr<reco::JetID>)((((const ::edm::PtrVector<reco::JetID>*)o)->begin)());
  else   (((const ::edm::PtrVector<reco::JetID>*)o)->begin)();
}

static  void method_22421( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::PtrVectorItr<reco::JetID>)((((const ::edm::PtrVector<reco::JetID>*)o)->end)());
  else   (((const ::edm::PtrVector<reco::JetID>*)o)->end)();
}

static  void method_22422( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::PtrVector<reco::JetID>*)o)->push_back)(*(const ::edm::Ptr<reco::JetID>*)arg[0]);
}

static  void method_22423( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::PtrVector<reco::JetID>*)o)->swap)(*(::edm::PtrVector<reco::JetID>*)arg[0]);
}

static  void operator_22424( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::PtrVector<reco::JetID>*)o)->operator=)(*(const ::edm::PtrVector<reco::JetID>*)arg[0]);
  else   (((::edm::PtrVector<reco::JetID>*)o)->operator=)(*(const ::edm::PtrVector<reco::JetID>*)arg[0]);
}

static  void method_22425( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::PtrVector<reco::JetID>*)o)->fillView)(*(::std::vector<const void*>*)arg[0]);
}

static  void method_22426( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::PtrVector<reco::JetID>*)o)->Class_Version)());
  else   (((::edm::PtrVector<reco::JetID>*)o)->Class_Version)();
}

static void destructor_22429(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::PtrVector<reco::JetID>*)o)->::edm::PtrVector<reco::JetID>::~PtrVector)();
}
static void method_newdel_4637( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::PtrVector<reco::JetID> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::PtrVector<reco::JetID> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::PtrVector<reco::JetID> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::PtrVector<reco::JetID> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::PtrVector<reco::JetID> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x39( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::PtrVectorBase")), ::Reflex::BaseOffset< ::edm::PtrVector<reco::JetID>,::edm::PtrVectorBase >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PtrVector<reco::JetID> -------------------------------
void __edm__PtrVector_reco__JetID__db_datamem(Reflex::Class*);
void __edm__PtrVector_reco__JetID__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__PtrVector_reco__JetID__datamem_bld(&__edm__PtrVector_reco__JetID__db_datamem);
Reflex::GenreflexMemberBuilder __edm__PtrVector_reco__JetID__funcmem_bld(&__edm__PtrVector_reco__JetID__db_funcmem);
void __edm__PtrVector_reco__JetID__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::PtrVector<reco::JetID>"), typeid(::edm::PtrVector<reco::JetID>), sizeof(::edm::PtrVector<reco::JetID>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::PtrVector<reco::JetID>::Class_Version())
  .AddBase(type_4894, ::Reflex::BaseOffset< ::edm::PtrVector<reco::JetID>, ::edm::PtrVectorBase >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_4799, Reflex::Literal("edm::PtrVector<reco::JetID>::const_iterator"))
  .AddTypedef(type_4799, Reflex::Literal("edm::PtrVector<reco::JetID>::iterator"))
  .AddTypedef(type_4989, Reflex::Literal("edm::PtrVector<reco::JetID>::value_type"))
  .AddTypedef(type_694, Reflex::Literal("edm::PtrVector<reco::JetID>::collection_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PtrVector"), constructor_22416, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20599), Reflex::Literal("PtrVector"), constructor_22417, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39237), Reflex::Literal("PtrVector"), constructor_22418, 0, "iOther", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PtrVector"), destructor_22429, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4637, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x39, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__edm__PtrVector_reco__JetID__funcmem_bld);
}

//------Delayed data member builder for class PtrVector<reco::JetID> -------------------
void __edm__PtrVector_reco__JetID__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class PtrVector<reco::JetID> -------------------
void __edm__PtrVector_reco__JetID__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4989, type_358c), Reflex::Literal("operator[]"), operator_22419, 0, "iIndex", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4799), Reflex::Literal("begin"), method_22420, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4799), Reflex::Literal("end"), method_22421, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_39238), Reflex::Literal("push_back"), method_22422, 0, "iPtr", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_39239), Reflex::Literal("swap"), method_22423, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39239, type_39237), Reflex::Literal("operator="), operator_22424, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20679), Reflex::Literal("fillView"), method_22425, 0, "pointers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_237), Reflex::Literal("Class_Version"), method_22426, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class PtrVector<reco::PFClusterJet> -------------------------------
static void constructor_22434( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::PtrVector<reco::PFClusterJet>();
  else ::new(mem) ::edm::PtrVector<reco::PFClusterJet>();
}

static void constructor_22435( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::PtrVector<reco::PFClusterJet>(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::PtrVector<reco::PFClusterJet>(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_22436( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::PtrVector<reco::PFClusterJet>(*(const ::edm::PtrVector<reco::PFClusterJet>*)arg[0]);
  else ::new(mem) ::edm::PtrVector<reco::PFClusterJet>(*(const ::edm::PtrVector<reco::PFClusterJet>*)arg[0]);
}

static  void operator_22437( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::PFClusterJet>)((((const ::edm::PtrVector<reco::PFClusterJet>*)o)->operator[])(*(const unsigned long*)arg[0]));
  else   (((const ::edm::PtrVector<reco::PFClusterJet>*)o)->operator[])(*(const unsigned long*)arg[0]);
}

static  void method_22438( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::PtrVectorItr<reco::PFClusterJet>)((((const ::edm::PtrVector<reco::PFClusterJet>*)o)->begin)());
  else   (((const ::edm::PtrVector<reco::PFClusterJet>*)o)->begin)();
}

static  void method_22439( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::PtrVectorItr<reco::PFClusterJet>)((((const ::edm::PtrVector<reco::PFClusterJet>*)o)->end)());
  else   (((const ::edm::PtrVector<reco::PFClusterJet>*)o)->end)();
}

static  void method_22440( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::PtrVector<reco::PFClusterJet>*)o)->push_back)(*(const ::edm::Ptr<reco::PFClusterJet>*)arg[0]);
}

static  void method_22441( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::PtrVector<reco::PFClusterJet>*)o)->swap)(*(::edm::PtrVector<reco::PFClusterJet>*)arg[0]);
}

static  void operator_22442( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::PtrVector<reco::PFClusterJet>*)o)->operator=)(*(const ::edm::PtrVector<reco::PFClusterJet>*)arg[0]);
  else   (((::edm::PtrVector<reco::PFClusterJet>*)o)->operator=)(*(const ::edm::PtrVector<reco::PFClusterJet>*)arg[0]);
}

static  void method_22443( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::PtrVector<reco::PFClusterJet>*)o)->fillView)(*(::std::vector<const void*>*)arg[0]);
}

static  void method_22444( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::PtrVector<reco::PFClusterJet>*)o)->Class_Version)());
  else   (((::edm::PtrVector<reco::PFClusterJet>*)o)->Class_Version)();
}

static void destructor_22447(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::PtrVector<reco::PFClusterJet>*)o)->::edm::PtrVector<reco::PFClusterJet>::~PtrVector)();
}
static void method_newdel_4638( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::PtrVector<reco::PFClusterJet> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::PtrVector<reco::PFClusterJet> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::PtrVector<reco::PFClusterJet> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::PtrVector<reco::PFClusterJet> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::PtrVector<reco::PFClusterJet> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x41( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::PtrVectorBase")), ::Reflex::BaseOffset< ::edm::PtrVector<reco::PFClusterJet>,::edm::PtrVectorBase >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PtrVector<reco::PFClusterJet> -------------------------------
void __edm__PtrVector_reco__PFClusterJet__db_datamem(Reflex::Class*);
void __edm__PtrVector_reco__PFClusterJet__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__PtrVector_reco__PFClusterJet__datamem_bld(&__edm__PtrVector_reco__PFClusterJet__db_datamem);
Reflex::GenreflexMemberBuilder __edm__PtrVector_reco__PFClusterJet__funcmem_bld(&__edm__PtrVector_reco__PFClusterJet__db_funcmem);
void __edm__PtrVector_reco__PFClusterJet__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::PtrVector<reco::PFClusterJet>"), typeid(::edm::PtrVector<reco::PFClusterJet>), sizeof(::edm::PtrVector<reco::PFClusterJet>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::PtrVector<reco::PFClusterJet>::Class_Version())
  .AddBase(type_4894, ::Reflex::BaseOffset< ::edm::PtrVector<reco::PFClusterJet>, ::edm::PtrVectorBase >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_4800, Reflex::Literal("edm::PtrVector<reco::PFClusterJet>::const_iterator"))
  .AddTypedef(type_4800, Reflex::Literal("edm::PtrVector<reco::PFClusterJet>::iterator"))
  .AddTypedef(type_4991, Reflex::Literal("edm::PtrVector<reco::PFClusterJet>::value_type"))
  .AddTypedef(type_694, Reflex::Literal("edm::PtrVector<reco::PFClusterJet>::collection_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PtrVector"), constructor_22434, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20599), Reflex::Literal("PtrVector"), constructor_22435, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39240), Reflex::Literal("PtrVector"), constructor_22436, 0, "iOther", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PtrVector"), destructor_22447, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4638, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x41, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__edm__PtrVector_reco__PFClusterJet__funcmem_bld);
}

//------Delayed data member builder for class PtrVector<reco::PFClusterJet> -------------------
void __edm__PtrVector_reco__PFClusterJet__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class PtrVector<reco::PFClusterJet> -------------------
void __edm__PtrVector_reco__PFClusterJet__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4991, type_358c), Reflex::Literal("operator[]"), operator_22437, 0, "iIndex", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4800), Reflex::Literal("begin"), method_22438, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4800), Reflex::Literal("end"), method_22439, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_39241), Reflex::Literal("push_back"), method_22440, 0, "iPtr", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_39242), Reflex::Literal("swap"), method_22441, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39242, type_39240), Reflex::Literal("operator="), operator_22442, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20679), Reflex::Literal("fillView"), method_22443, 0, "pointers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_237), Reflex::Literal("Class_Version"), method_22444, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class PtrVector<reco::TrackJet> -------------------------------
static void constructor_22452( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::PtrVector<reco::TrackJet>();
  else ::new(mem) ::edm::PtrVector<reco::TrackJet>();
}

static void constructor_22453( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::PtrVector<reco::TrackJet>(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::PtrVector<reco::TrackJet>(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_22454( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::PtrVector<reco::TrackJet>(*(const ::edm::PtrVector<reco::TrackJet>*)arg[0]);
  else ::new(mem) ::edm::PtrVector<reco::TrackJet>(*(const ::edm::PtrVector<reco::TrackJet>*)arg[0]);
}

static  void operator_22455( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::TrackJet>)((((const ::edm::PtrVector<reco::TrackJet>*)o)->operator[])(*(const unsigned long*)arg[0]));
  else   (((const ::edm::PtrVector<reco::TrackJet>*)o)->operator[])(*(const unsigned long*)arg[0]);
}

static  void method_22456( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::PtrVectorItr<reco::TrackJet>)((((const ::edm::PtrVector<reco::TrackJet>*)o)->begin)());
  else   (((const ::edm::PtrVector<reco::TrackJet>*)o)->begin)();
}

static  void method_22457( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::PtrVectorItr<reco::TrackJet>)((((const ::edm::PtrVector<reco::TrackJet>*)o)->end)());
  else   (((const ::edm::PtrVector<reco::TrackJet>*)o)->end)();
}

static  void method_22458( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::PtrVector<reco::TrackJet>*)o)->push_back)(*(const ::edm::Ptr<reco::TrackJet>*)arg[0]);
}

static  void method_22459( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::PtrVector<reco::TrackJet>*)o)->swap)(*(::edm::PtrVector<reco::TrackJet>*)arg[0]);
}

static  void operator_22460( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::PtrVector<reco::TrackJet>*)o)->operator=)(*(const ::edm::PtrVector<reco::TrackJet>*)arg[0]);
  else   (((::edm::PtrVector<reco::TrackJet>*)o)->operator=)(*(const ::edm::PtrVector<reco::TrackJet>*)arg[0]);
}

static  void method_22461( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::PtrVector<reco::TrackJet>*)o)->fillView)(*(::std::vector<const void*>*)arg[0]);
}

static  void method_22462( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::PtrVector<reco::TrackJet>*)o)->Class_Version)());
  else   (((::edm::PtrVector<reco::TrackJet>*)o)->Class_Version)();
}

static void destructor_22465(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::PtrVector<reco::TrackJet>*)o)->::edm::PtrVector<reco::TrackJet>::~PtrVector)();
}
static void method_newdel_4639( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::PtrVector<reco::TrackJet> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::PtrVector<reco::TrackJet> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::PtrVector<reco::TrackJet> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::PtrVector<reco::TrackJet> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::PtrVector<reco::TrackJet> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x43( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::PtrVectorBase")), ::Reflex::BaseOffset< ::edm::PtrVector<reco::TrackJet>,::edm::PtrVectorBase >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PtrVector<reco::TrackJet> -------------------------------
void __edm__PtrVector_reco__TrackJet__db_datamem(Reflex::Class*);
void __edm__PtrVector_reco__TrackJet__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__PtrVector_reco__TrackJet__datamem_bld(&__edm__PtrVector_reco__TrackJet__db_datamem);
Reflex::GenreflexMemberBuilder __edm__PtrVector_reco__TrackJet__funcmem_bld(&__edm__PtrVector_reco__TrackJet__db_funcmem);
void __edm__PtrVector_reco__TrackJet__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::PtrVector<reco::TrackJet>"), typeid(::edm::PtrVector<reco::TrackJet>), sizeof(::edm::PtrVector<reco::TrackJet>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::PtrVector<reco::TrackJet>::Class_Version())
  .AddBase(type_4894, ::Reflex::BaseOffset< ::edm::PtrVector<reco::TrackJet>, ::edm::PtrVectorBase >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_4801, Reflex::Literal("edm::PtrVector<reco::TrackJet>::const_iterator"))
  .AddTypedef(type_4801, Reflex::Literal("edm::PtrVector<reco::TrackJet>::iterator"))
  .AddTypedef(type_4992, Reflex::Literal("edm::PtrVector<reco::TrackJet>::value_type"))
  .AddTypedef(type_694, Reflex::Literal("edm::PtrVector<reco::TrackJet>::collection_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PtrVector"), constructor_22452, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20599), Reflex::Literal("PtrVector"), constructor_22453, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39243), Reflex::Literal("PtrVector"), constructor_22454, 0, "iOther", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PtrVector"), destructor_22465, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4639, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x43, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__edm__PtrVector_reco__TrackJet__funcmem_bld);
}

//------Delayed data member builder for class PtrVector<reco::TrackJet> -------------------
void __edm__PtrVector_reco__TrackJet__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class PtrVector<reco::TrackJet> -------------------
void __edm__PtrVector_reco__TrackJet__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4992, type_358c), Reflex::Literal("operator[]"), operator_22455, 0, "iIndex", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4801), Reflex::Literal("begin"), method_22456, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4801), Reflex::Literal("end"), method_22457, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_39244), Reflex::Literal("push_back"), method_22458, 0, "iPtr", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_39245), Reflex::Literal("swap"), method_22459, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39245, type_39243), Reflex::Literal("operator="), operator_22460, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20679), Reflex::Literal("fillView"), method_22461, 0, "pointers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_237), Reflex::Literal("Class_Version"), method_22462, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class PtrVector<reco::GenJet> -------------------------------
static void constructor_22470( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::PtrVector<reco::GenJet>();
  else ::new(mem) ::edm::PtrVector<reco::GenJet>();
}

static void constructor_22471( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::PtrVector<reco::GenJet>(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::PtrVector<reco::GenJet>(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_22472( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::PtrVector<reco::GenJet>(*(const ::edm::PtrVector<reco::GenJet>*)arg[0]);
  else ::new(mem) ::edm::PtrVector<reco::GenJet>(*(const ::edm::PtrVector<reco::GenJet>*)arg[0]);
}

static  void operator_22473( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::GenJet>)((((const ::edm::PtrVector<reco::GenJet>*)o)->operator[])(*(const unsigned long*)arg[0]));
  else   (((const ::edm::PtrVector<reco::GenJet>*)o)->operator[])(*(const unsigned long*)arg[0]);
}

static  void method_22474( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::PtrVectorItr<reco::GenJet>)((((const ::edm::PtrVector<reco::GenJet>*)o)->begin)());
  else   (((const ::edm::PtrVector<reco::GenJet>*)o)->begin)();
}

static  void method_22475( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::PtrVectorItr<reco::GenJet>)((((const ::edm::PtrVector<reco::GenJet>*)o)->end)());
  else   (((const ::edm::PtrVector<reco::GenJet>*)o)->end)();
}

static  void method_22476( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::PtrVector<reco::GenJet>*)o)->push_back)(*(const ::edm::Ptr<reco::GenJet>*)arg[0]);
}

static  void method_22477( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::PtrVector<reco::GenJet>*)o)->swap)(*(::edm::PtrVector<reco::GenJet>*)arg[0]);
}

static  void operator_22478( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::PtrVector<reco::GenJet>*)o)->operator=)(*(const ::edm::PtrVector<reco::GenJet>*)arg[0]);
  else   (((::edm::PtrVector<reco::GenJet>*)o)->operator=)(*(const ::edm::PtrVector<reco::GenJet>*)arg[0]);
}

static  void method_22479( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::PtrVector<reco::GenJet>*)o)->fillView)(*(::std::vector<const void*>*)arg[0]);
}

static  void method_22480( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::PtrVector<reco::GenJet>*)o)->Class_Version)());
  else   (((::edm::PtrVector<reco::GenJet>*)o)->Class_Version)();
}

static void destructor_22483(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::PtrVector<reco::GenJet>*)o)->::edm::PtrVector<reco::GenJet>::~PtrVector)();
}
static void method_newdel_4640( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::PtrVector<reco::GenJet> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::PtrVector<reco::GenJet> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::PtrVector<reco::GenJet> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::PtrVector<reco::GenJet> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::PtrVector<reco::GenJet> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x45( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::PtrVectorBase")), ::Reflex::BaseOffset< ::edm::PtrVector<reco::GenJet>,::edm::PtrVectorBase >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PtrVector<reco::GenJet> -------------------------------
void __edm__PtrVector_reco__GenJet__db_datamem(Reflex::Class*);
void __edm__PtrVector_reco__GenJet__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__PtrVector_reco__GenJet__datamem_bld(&__edm__PtrVector_reco__GenJet__db_datamem);
Reflex::GenreflexMemberBuilder __edm__PtrVector_reco__GenJet__funcmem_bld(&__edm__PtrVector_reco__GenJet__db_funcmem);
void __edm__PtrVector_reco__GenJet__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::PtrVector<reco::GenJet>"), typeid(::edm::PtrVector<reco::GenJet>), sizeof(::edm::PtrVector<reco::GenJet>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::PtrVector<reco::GenJet>::Class_Version())
  .AddBase(type_4894, ::Reflex::BaseOffset< ::edm::PtrVector<reco::GenJet>, ::edm::PtrVectorBase >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_4802, Reflex::Literal("edm::PtrVector<reco::GenJet>::const_iterator"))
  .AddTypedef(type_4802, Reflex::Literal("edm::PtrVector<reco::GenJet>::iterator"))
  .AddTypedef(type_4993, Reflex::Literal("edm::PtrVector<reco::GenJet>::value_type"))
  .AddTypedef(type_694, Reflex::Literal("edm::PtrVector<reco::GenJet>::collection_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PtrVector"), constructor_22470, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20599), Reflex::Literal("PtrVector"), constructor_22471, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39246), Reflex::Literal("PtrVector"), constructor_22472, 0, "iOther", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PtrVector"), destructor_22483, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4640, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x45, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__edm__PtrVector_reco__GenJet__funcmem_bld);
}

//------Delayed data member builder for class PtrVector<reco::GenJet> -------------------
void __edm__PtrVector_reco__GenJet__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class PtrVector<reco::GenJet> -------------------
void __edm__PtrVector_reco__GenJet__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4993, type_358c), Reflex::Literal("operator[]"), operator_22473, 0, "iIndex", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4802), Reflex::Literal("begin"), method_22474, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4802), Reflex::Literal("end"), method_22475, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_39247), Reflex::Literal("push_back"), method_22476, 0, "iPtr", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_39248), Reflex::Literal("swap"), method_22477, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39248, type_39246), Reflex::Literal("operator="), operator_22478, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20679), Reflex::Literal("fillView"), method_22479, 0, "pointers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_237), Reflex::Literal("Class_Version"), method_22480, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class PtrVector<reco::BasicJet> -------------------------------
static void constructor_22488( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::PtrVector<reco::BasicJet>();
  else ::new(mem) ::edm::PtrVector<reco::BasicJet>();
}

static void constructor_22489( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::PtrVector<reco::BasicJet>(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::PtrVector<reco::BasicJet>(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_22490( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::PtrVector<reco::BasicJet>(*(const ::edm::PtrVector<reco::BasicJet>*)arg[0]);
  else ::new(mem) ::edm::PtrVector<reco::BasicJet>(*(const ::edm::PtrVector<reco::BasicJet>*)arg[0]);
}

static  void operator_22491( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::BasicJet>)((((const ::edm::PtrVector<reco::BasicJet>*)o)->operator[])(*(const unsigned long*)arg[0]));
  else   (((const ::edm::PtrVector<reco::BasicJet>*)o)->operator[])(*(const unsigned long*)arg[0]);
}

static  void method_22492( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::PtrVectorItr<reco::BasicJet>)((((const ::edm::PtrVector<reco::BasicJet>*)o)->begin)());
  else   (((const ::edm::PtrVector<reco::BasicJet>*)o)->begin)();
}

static  void method_22493( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::PtrVectorItr<reco::BasicJet>)((((const ::edm::PtrVector<reco::BasicJet>*)o)->end)());
  else   (((const ::edm::PtrVector<reco::BasicJet>*)o)->end)();
}

static  void method_22494( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::PtrVector<reco::BasicJet>*)o)->push_back)(*(const ::edm::Ptr<reco::BasicJet>*)arg[0]);
}

static  void method_22495( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::PtrVector<reco::BasicJet>*)o)->swap)(*(::edm::PtrVector<reco::BasicJet>*)arg[0]);
}

static  void operator_22496( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::PtrVector<reco::BasicJet>*)o)->operator=)(*(const ::edm::PtrVector<reco::BasicJet>*)arg[0]);
  else   (((::edm::PtrVector<reco::BasicJet>*)o)->operator=)(*(const ::edm::PtrVector<reco::BasicJet>*)arg[0]);
}

static  void method_22497( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::PtrVector<reco::BasicJet>*)o)->fillView)(*(::std::vector<const void*>*)arg[0]);
}

static  void method_22498( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::PtrVector<reco::BasicJet>*)o)->Class_Version)());
  else   (((::edm::PtrVector<reco::BasicJet>*)o)->Class_Version)();
}

static void destructor_22501(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::PtrVector<reco::BasicJet>*)o)->::edm::PtrVector<reco::BasicJet>::~PtrVector)();
}
static void method_newdel_4641( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::PtrVector<reco::BasicJet> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::PtrVector<reco::BasicJet> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::PtrVector<reco::BasicJet> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::PtrVector<reco::BasicJet> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::PtrVector<reco::BasicJet> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x47( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::PtrVectorBase")), ::Reflex::BaseOffset< ::edm::PtrVector<reco::BasicJet>,::edm::PtrVectorBase >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PtrVector<reco::BasicJet> -------------------------------
void __edm__PtrVector_reco__BasicJet__db_datamem(Reflex::Class*);
void __edm__PtrVector_reco__BasicJet__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__PtrVector_reco__BasicJet__datamem_bld(&__edm__PtrVector_reco__BasicJet__db_datamem);
Reflex::GenreflexMemberBuilder __edm__PtrVector_reco__BasicJet__funcmem_bld(&__edm__PtrVector_reco__BasicJet__db_funcmem);
void __edm__PtrVector_reco__BasicJet__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::PtrVector<reco::BasicJet>"), typeid(::edm::PtrVector<reco::BasicJet>), sizeof(::edm::PtrVector<reco::BasicJet>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::PtrVector<reco::BasicJet>::Class_Version())
  .AddBase(type_4894, ::Reflex::BaseOffset< ::edm::PtrVector<reco::BasicJet>, ::edm::PtrVectorBase >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_4803, Reflex::Literal("edm::PtrVector<reco::BasicJet>::const_iterator"))
  .AddTypedef(type_4803, Reflex::Literal("edm::PtrVector<reco::BasicJet>::iterator"))
  .AddTypedef(type_4994, Reflex::Literal("edm::PtrVector<reco::BasicJet>::value_type"))
  .AddTypedef(type_694, Reflex::Literal("edm::PtrVector<reco::BasicJet>::collection_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PtrVector"), constructor_22488, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20599), Reflex::Literal("PtrVector"), constructor_22489, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39249), Reflex::Literal("PtrVector"), constructor_22490, 0, "iOther", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PtrVector"), destructor_22501, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4641, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x47, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__edm__PtrVector_reco__BasicJet__funcmem_bld);
}

//------Delayed data member builder for class PtrVector<reco::BasicJet> -------------------
void __edm__PtrVector_reco__BasicJet__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class PtrVector<reco::BasicJet> -------------------
void __edm__PtrVector_reco__BasicJet__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4994, type_358c), Reflex::Literal("operator[]"), operator_22491, 0, "iIndex", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4803), Reflex::Literal("begin"), method_22492, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4803), Reflex::Literal("end"), method_22493, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_39250), Reflex::Literal("push_back"), method_22494, 0, "iPtr", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_39251), Reflex::Literal("swap"), method_22495, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39251, type_39249), Reflex::Literal("operator="), operator_22496, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20679), Reflex::Literal("fillView"), method_22497, 0, "pointers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_237), Reflex::Literal("Class_Version"), method_22498, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class PtrVector<reco::PFJet> -------------------------------
static void constructor_22506( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::PtrVector<reco::PFJet>();
  else ::new(mem) ::edm::PtrVector<reco::PFJet>();
}

static void constructor_22507( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::PtrVector<reco::PFJet>(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::PtrVector<reco::PFJet>(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_22508( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::PtrVector<reco::PFJet>(*(const ::edm::PtrVector<reco::PFJet>*)arg[0]);
  else ::new(mem) ::edm::PtrVector<reco::PFJet>(*(const ::edm::PtrVector<reco::PFJet>*)arg[0]);
}

static  void operator_22509( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::PFJet>)((((const ::edm::PtrVector<reco::PFJet>*)o)->operator[])(*(const unsigned long*)arg[0]));
  else   (((const ::edm::PtrVector<reco::PFJet>*)o)->operator[])(*(const unsigned long*)arg[0]);
}

static  void method_22510( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::PtrVectorItr<reco::PFJet>)((((const ::edm::PtrVector<reco::PFJet>*)o)->begin)());
  else   (((const ::edm::PtrVector<reco::PFJet>*)o)->begin)();
}

static  void method_22511( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::PtrVectorItr<reco::PFJet>)((((const ::edm::PtrVector<reco::PFJet>*)o)->end)());
  else   (((const ::edm::PtrVector<reco::PFJet>*)o)->end)();
}

static  void method_22512( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::PtrVector<reco::PFJet>*)o)->push_back)(*(const ::edm::Ptr<reco::PFJet>*)arg[0]);
}

static  void method_22513( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::PtrVector<reco::PFJet>*)o)->swap)(*(::edm::PtrVector<reco::PFJet>*)arg[0]);
}

static  void operator_22514( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::PtrVector<reco::PFJet>*)o)->operator=)(*(const ::edm::PtrVector<reco::PFJet>*)arg[0]);
  else   (((::edm::PtrVector<reco::PFJet>*)o)->operator=)(*(const ::edm::PtrVector<reco::PFJet>*)arg[0]);
}

static  void method_22515( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::PtrVector<reco::PFJet>*)o)->fillView)(*(::std::vector<const void*>*)arg[0]);
}

static  void method_22516( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::PtrVector<reco::PFJet>*)o)->Class_Version)());
  else   (((::edm::PtrVector<reco::PFJet>*)o)->Class_Version)();
}

static void destructor_22519(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::PtrVector<reco::PFJet>*)o)->::edm::PtrVector<reco::PFJet>::~PtrVector)();
}
static void method_newdel_4642( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::PtrVector<reco::PFJet> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::PtrVector<reco::PFJet> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::PtrVector<reco::PFJet> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::PtrVector<reco::PFJet> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::PtrVector<reco::PFJet> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x49( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::PtrVectorBase")), ::Reflex::BaseOffset< ::edm::PtrVector<reco::PFJet>,::edm::PtrVectorBase >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PtrVector<reco::PFJet> -------------------------------
void __edm__PtrVector_reco__PFJet__db_datamem(Reflex::Class*);
void __edm__PtrVector_reco__PFJet__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__PtrVector_reco__PFJet__datamem_bld(&__edm__PtrVector_reco__PFJet__db_datamem);
Reflex::GenreflexMemberBuilder __edm__PtrVector_reco__PFJet__funcmem_bld(&__edm__PtrVector_reco__PFJet__db_funcmem);
void __edm__PtrVector_reco__PFJet__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::PtrVector<reco::PFJet>"), typeid(::edm::PtrVector<reco::PFJet>), sizeof(::edm::PtrVector<reco::PFJet>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::PtrVector<reco::PFJet>::Class_Version())
  .AddBase(type_4894, ::Reflex::BaseOffset< ::edm::PtrVector<reco::PFJet>, ::edm::PtrVectorBase >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_4804, Reflex::Literal("edm::PtrVector<reco::PFJet>::const_iterator"))
  .AddTypedef(type_4804, Reflex::Literal("edm::PtrVector<reco::PFJet>::iterator"))
  .AddTypedef(type_4995, Reflex::Literal("edm::PtrVector<reco::PFJet>::value_type"))
  .AddTypedef(type_694, Reflex::Literal("edm::PtrVector<reco::PFJet>::collection_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PtrVector"), constructor_22506, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20599), Reflex::Literal("PtrVector"), constructor_22507, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39252), Reflex::Literal("PtrVector"), constructor_22508, 0, "iOther", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PtrVector"), destructor_22519, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4642, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x49, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__edm__PtrVector_reco__PFJet__funcmem_bld);
}

//------Delayed data member builder for class PtrVector<reco::PFJet> -------------------
void __edm__PtrVector_reco__PFJet__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class PtrVector<reco::PFJet> -------------------
void __edm__PtrVector_reco__PFJet__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4995, type_358c), Reflex::Literal("operator[]"), operator_22509, 0, "iIndex", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4804), Reflex::Literal("begin"), method_22510, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4804), Reflex::Literal("end"), method_22511, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_39253), Reflex::Literal("push_back"), method_22512, 0, "iPtr", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_39254), Reflex::Literal("swap"), method_22513, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39254, type_39252), Reflex::Literal("operator="), operator_22514, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20679), Reflex::Literal("fillView"), method_22515, 0, "pointers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_237), Reflex::Literal("Class_Version"), method_22516, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class PtrVector<reco::CaloJet> -------------------------------
static void constructor_22542( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::PtrVector<reco::CaloJet>();
  else ::new(mem) ::edm::PtrVector<reco::CaloJet>();
}

static void constructor_22543( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::PtrVector<reco::CaloJet>(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::PtrVector<reco::CaloJet>(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_22544( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::PtrVector<reco::CaloJet>(*(const ::edm::PtrVector<reco::CaloJet>*)arg[0]);
  else ::new(mem) ::edm::PtrVector<reco::CaloJet>(*(const ::edm::PtrVector<reco::CaloJet>*)arg[0]);
}

static  void operator_22545( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::CaloJet>)((((const ::edm::PtrVector<reco::CaloJet>*)o)->operator[])(*(const unsigned long*)arg[0]));
  else   (((const ::edm::PtrVector<reco::CaloJet>*)o)->operator[])(*(const unsigned long*)arg[0]);
}

static  void method_22546( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::PtrVectorItr<reco::CaloJet>)((((const ::edm::PtrVector<reco::CaloJet>*)o)->begin)());
  else   (((const ::edm::PtrVector<reco::CaloJet>*)o)->begin)();
}

static  void method_22547( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::PtrVectorItr<reco::CaloJet>)((((const ::edm::PtrVector<reco::CaloJet>*)o)->end)());
  else   (((const ::edm::PtrVector<reco::CaloJet>*)o)->end)();
}

static  void method_22548( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::PtrVector<reco::CaloJet>*)o)->push_back)(*(const ::edm::Ptr<reco::CaloJet>*)arg[0]);
}

static  void method_22549( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::PtrVector<reco::CaloJet>*)o)->swap)(*(::edm::PtrVector<reco::CaloJet>*)arg[0]);
}

static  void operator_22550( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::PtrVector<reco::CaloJet>*)o)->operator=)(*(const ::edm::PtrVector<reco::CaloJet>*)arg[0]);
  else   (((::edm::PtrVector<reco::CaloJet>*)o)->operator=)(*(const ::edm::PtrVector<reco::CaloJet>*)arg[0]);
}

static  void method_22551( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::PtrVector<reco::CaloJet>*)o)->fillView)(*(::std::vector<const void*>*)arg[0]);
}

static  void method_22552( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::PtrVector<reco::CaloJet>*)o)->Class_Version)());
  else   (((::edm::PtrVector<reco::CaloJet>*)o)->Class_Version)();
}

static void destructor_22555(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::PtrVector<reco::CaloJet>*)o)->::edm::PtrVector<reco::CaloJet>::~PtrVector)();
}
static void method_newdel_4644( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::PtrVector<reco::CaloJet> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::PtrVector<reco::CaloJet> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::PtrVector<reco::CaloJet> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::PtrVector<reco::CaloJet> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::PtrVector<reco::CaloJet> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x51( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::PtrVectorBase")), ::Reflex::BaseOffset< ::edm::PtrVector<reco::CaloJet>,::edm::PtrVectorBase >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PtrVector<reco::CaloJet> -------------------------------
void __edm__PtrVector_reco__CaloJet__db_datamem(Reflex::Class*);
void __edm__PtrVector_reco__CaloJet__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__PtrVector_reco__CaloJet__datamem_bld(&__edm__PtrVector_reco__CaloJet__db_datamem);
Reflex::GenreflexMemberBuilder __edm__PtrVector_reco__CaloJet__funcmem_bld(&__edm__PtrVector_reco__CaloJet__db_funcmem);
void __edm__PtrVector_reco__CaloJet__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::PtrVector<reco::CaloJet>"), typeid(::edm::PtrVector<reco::CaloJet>), sizeof(::edm::PtrVector<reco::CaloJet>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::PtrVector<reco::CaloJet>::Class_Version())
  .AddBase(type_4894, ::Reflex::BaseOffset< ::edm::PtrVector<reco::CaloJet>, ::edm::PtrVectorBase >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_4806, Reflex::Literal("edm::PtrVector<reco::CaloJet>::const_iterator"))
  .AddTypedef(type_4806, Reflex::Literal("edm::PtrVector<reco::CaloJet>::iterator"))
  .AddTypedef(type_4997, Reflex::Literal("edm::PtrVector<reco::CaloJet>::value_type"))
  .AddTypedef(type_694, Reflex::Literal("edm::PtrVector<reco::CaloJet>::collection_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PtrVector"), constructor_22542, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20599), Reflex::Literal("PtrVector"), constructor_22543, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39258), Reflex::Literal("PtrVector"), constructor_22544, 0, "iOther", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PtrVector"), destructor_22555, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4644, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x51, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__edm__PtrVector_reco__CaloJet__funcmem_bld);
}

//------Delayed data member builder for class PtrVector<reco::CaloJet> -------------------
void __edm__PtrVector_reco__CaloJet__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class PtrVector<reco::CaloJet> -------------------
void __edm__PtrVector_reco__CaloJet__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4997, type_358c), Reflex::Literal("operator[]"), operator_22545, 0, "iIndex", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4806), Reflex::Literal("begin"), method_22546, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4806), Reflex::Literal("end"), method_22547, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_39259), Reflex::Literal("push_back"), method_22548, 0, "iPtr", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_39260), Reflex::Literal("swap"), method_22549, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39260, type_39258), Reflex::Literal("operator="), operator_22550, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20679), Reflex::Literal("fillView"), method_22551, 0, "pointers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_237), Reflex::Literal("Class_Version"), method_22552, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class PtrVector<reco::Jet> -------------------------------
static void constructor_22560( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::PtrVector<reco::Jet>();
  else ::new(mem) ::edm::PtrVector<reco::Jet>();
}

static void constructor_22561( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::PtrVector<reco::Jet>(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::PtrVector<reco::Jet>(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_22562( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::PtrVector<reco::Jet>(*(const ::edm::PtrVector<reco::Jet>*)arg[0]);
  else ::new(mem) ::edm::PtrVector<reco::Jet>(*(const ::edm::PtrVector<reco::Jet>*)arg[0]);
}

static  void operator_22563( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Jet>)((((const ::edm::PtrVector<reco::Jet>*)o)->operator[])(*(const unsigned long*)arg[0]));
  else   (((const ::edm::PtrVector<reco::Jet>*)o)->operator[])(*(const unsigned long*)arg[0]);
}

static  void method_22564( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::PtrVectorItr<reco::Jet>)((((const ::edm::PtrVector<reco::Jet>*)o)->begin)());
  else   (((const ::edm::PtrVector<reco::Jet>*)o)->begin)();
}

static  void method_22565( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::PtrVectorItr<reco::Jet>)((((const ::edm::PtrVector<reco::Jet>*)o)->end)());
  else   (((const ::edm::PtrVector<reco::Jet>*)o)->end)();
}

static  void method_22566( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::PtrVector<reco::Jet>*)o)->push_back)(*(const ::edm::Ptr<reco::Jet>*)arg[0]);
}

static  void method_22567( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::PtrVector<reco::Jet>*)o)->swap)(*(::edm::PtrVector<reco::Jet>*)arg[0]);
}

static  void operator_22568( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::PtrVector<reco::Jet>*)o)->operator=)(*(const ::edm::PtrVector<reco::Jet>*)arg[0]);
  else   (((::edm::PtrVector<reco::Jet>*)o)->operator=)(*(const ::edm::PtrVector<reco::Jet>*)arg[0]);
}

static  void method_22569( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::PtrVector<reco::Jet>*)o)->fillView)(*(::std::vector<const void*>*)arg[0]);
}

static  void method_22570( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::PtrVector<reco::Jet>*)o)->Class_Version)());
  else   (((::edm::PtrVector<reco::Jet>*)o)->Class_Version)();
}

static void destructor_22573(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::PtrVector<reco::Jet>*)o)->::edm::PtrVector<reco::Jet>::~PtrVector)();
}
static void method_newdel_4645( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::PtrVector<reco::Jet> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::PtrVector<reco::Jet> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::PtrVector<reco::Jet> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::PtrVector<reco::Jet> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::PtrVector<reco::Jet> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x53( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::PtrVectorBase")), ::Reflex::BaseOffset< ::edm::PtrVector<reco::Jet>,::edm::PtrVectorBase >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PtrVector<reco::Jet> -------------------------------
void __edm__PtrVector_reco__Jet__db_datamem(Reflex::Class*);
void __edm__PtrVector_reco__Jet__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__PtrVector_reco__Jet__datamem_bld(&__edm__PtrVector_reco__Jet__db_datamem);
Reflex::GenreflexMemberBuilder __edm__PtrVector_reco__Jet__funcmem_bld(&__edm__PtrVector_reco__Jet__db_funcmem);
void __edm__PtrVector_reco__Jet__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::PtrVector<reco::Jet>"), typeid(::edm::PtrVector<reco::Jet>), sizeof(::edm::PtrVector<reco::Jet>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::PtrVector<reco::Jet>::Class_Version())
  .AddBase(type_4894, ::Reflex::BaseOffset< ::edm::PtrVector<reco::Jet>, ::edm::PtrVectorBase >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_4807, Reflex::Literal("edm::PtrVector<reco::Jet>::const_iterator"))
  .AddTypedef(type_4807, Reflex::Literal("edm::PtrVector<reco::Jet>::iterator"))
  .AddTypedef(type_4998, Reflex::Literal("edm::PtrVector<reco::Jet>::value_type"))
  .AddTypedef(type_694, Reflex::Literal("edm::PtrVector<reco::Jet>::collection_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PtrVector"), constructor_22560, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20599), Reflex::Literal("PtrVector"), constructor_22561, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39261), Reflex::Literal("PtrVector"), constructor_22562, 0, "iOther", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PtrVector"), destructor_22573, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4645, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x53, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__edm__PtrVector_reco__Jet__funcmem_bld);
}

//------Delayed data member builder for class PtrVector<reco::Jet> -------------------
void __edm__PtrVector_reco__Jet__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class PtrVector<reco::Jet> -------------------
void __edm__PtrVector_reco__Jet__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4998, type_358c), Reflex::Literal("operator[]"), operator_22563, 0, "iIndex", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4807), Reflex::Literal("begin"), method_22564, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4807), Reflex::Literal("end"), method_22565, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_39262), Reflex::Literal("push_back"), method_22566, 0, "iPtr", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_39263), Reflex::Literal("swap"), method_22567, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39263, type_39261), Reflex::Literal("operator="), operator_22568, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20679), Reflex::Literal("fillView"), method_22569, 0, "pointers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_237), Reflex::Literal("Class_Version"), method_22570, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefVector<std::vector<reco::TrackExtrapolation, std::allocator<reco::TrackExtrapolation> >,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation, std::allocator<reco::TrackExtrapolation> >, reco::TrackExtrapolation> > -------------------------------
static void destructor_22830(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->::edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >::~RefVector)();
}
static void constructor_22831( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >();
  else ::new(mem) ::edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >();
}

static void constructor_22832( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >(*(const ::edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)arg[0]);
  else ::new(mem) ::edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >(*(const ::edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)arg[0]);
}

static void constructor_22833( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >(*(const ::edm::ProductID*)arg[0]);
}

static  void method_22834( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->push_back)(*(const ::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)arg[0]);
}

static  void operator_22835( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >)((((const ::edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->operator[])(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_22836( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >)((((const ::edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->at)(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_22837( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->refVector)();
  else   (((const ::edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->refVector)();
}

static  void method_22838( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->empty)());
  else   (((const ::edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->empty)();
}

static  void method_22839( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->size)());
  else   (((const ::edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->size)();
}

static  void method_22840( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->capacity)());
  else   (((const ::edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->capacity)();
}

static  void method_22841( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void method_22842( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >)((((const ::edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->begin)());
  else   (((const ::edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->begin)();
}

static  void method_22843( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >)((((const ::edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->end)());
  else   (((const ::edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->end)();
}

static  void method_22844( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->id)());
  else   (((const ::edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->id)();
}

static  void method_22845( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->productGetter)());
  else   (((const ::edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->productGetter)();
}

static  void method_22846( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->isNull)());
  else   (((const ::edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->isNull)();
}

static  void method_22847( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->isNonnull)());
  else   (((const ::edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->isNonnull)();
}

static  void operator_22848( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->operator!)());
  else   (((const ::edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->operator!)();
}

static  void method_22849( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->product)());
  else   (((const ::edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->product)();
}

static  void method_22850( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->isAvailable)());
  else   (((const ::edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->isAvailable)();
}

static  void method_22851( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->isTransient)());
  else   (((const ::edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->isTransient)();
}

static  void method_22852( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >)((((::edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->erase)(*(const ::edm::RefVectorIterator<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)arg[0]));
  else   (((::edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->erase)(*(const ::edm::RefVectorIterator<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)arg[0]);
}

static  void method_22853( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->clear)();
}

static  void method_22854( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->swap)(*(::edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)arg[0]);
}

static  void operator_22855( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->operator=)(*(const ::edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)arg[0]);
  else   (((::edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->operator=)(*(const ::edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)arg[0]);
}

static  void method_22856( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->hasProductCache)());
  else   (((const ::edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->hasProductCache)();
}

static  void method_22857( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::edm::helper_vector*)arg[2]);
}

static  void method_22858( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->Class_Version)());
  else   (((::edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->Class_Version)();
}

static void method_newdel_4681( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefVector<std::vector<reco::TrackExtrapolation, std::allocator<reco::TrackExtrapolation> >,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation, std::allocator<reco::TrackExtrapolation> >, reco::TrackExtrapolation> > -------------------------------
void __edm__RefVector_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_edm__refhelper__FindUsingAdvance_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_s__db_datamem(Reflex::Class*);
void __edm__RefVector_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_edm__refhelper__FindUsingAdvance_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefVector_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_edm__refhelper__FindUsingAdvance_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_s__datamem_bld(&__edm__RefVector_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_edm__refhelper__FindUsingAdvance_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefVector_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_edm__refhelper__FindUsingAdvance_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_s__funcmem_bld(&__edm__RefVector_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_edm__refhelper__FindUsingAdvance_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_s__db_funcmem);
void __edm__RefVector_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_edm__refhelper__FindUsingAdvance_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >"), typeid(::edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >), sizeof(::edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >::Class_Version())
  .AddTypedef(type_2993, Reflex::Literal("edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >::collection_type"))
  .AddTypedef(type_7787, Reflex::Literal("edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >::member_type"))
  .AddTypedef(type_20841, Reflex::Literal("edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >::finder_type"))
  .AddTypedef(type_4615, Reflex::Literal("edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >::iterator"))
  .AddTypedef(type_4615, Reflex::Literal("edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >::const_iterator"))
  .AddTypedef(type_5022, Reflex::Literal("edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >::value_type"))
  .AddTypedef(type_5022c, Reflex::Literal("edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >::const_reference"))
  .AddTypedef(type_5022c, Reflex::Literal("edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >::reference"))
  .AddTypedef(type_366, Reflex::Literal("edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >::key_type"))
  .AddTypedef(type_2972, Reflex::Literal("edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >::KeyVec"))
  .AddTypedef(type_3254, Reflex::Literal("edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >::size_type"))
  .AddTypedef(type_4039, Reflex::Literal("edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >::contents_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefVector"), destructor_22830, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefVector"), constructor_22831, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39289), Reflex::Literal("RefVector"), constructor_22832, 0, "rh", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20599), Reflex::Literal("RefVector"), constructor_22833, 0, "iId", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4681, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefVector_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_edm__refhelper__FindUsingAdvance_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefVector_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_edm__refhelper__FindUsingAdvance_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_s__funcmem_bld);
}

//------Delayed data member builder for class RefVector<std::vector<reco::TrackExtrapolation, std::allocator<reco::TrackExtrapolation> >,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation, std::allocator<reco::TrackExtrapolation> >, reco::TrackExtrapolation> > -------------------
void __edm__RefVector_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_edm__refhelper__FindUsingAdvance_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4039, Reflex::Literal("refVector_"), OffsetOf(__shadow__::__edm__RefVector_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_edm__refhelper__FindUsingAdvance_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_s_, refVector_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefVector<std::vector<reco::TrackExtrapolation, std::allocator<reco::TrackExtrapolation> >,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation, std::allocator<reco::TrackExtrapolation> >, reco::TrackExtrapolation> > -------------------
void __edm__RefVector_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_edm__refhelper__FindUsingAdvance_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_39290), Reflex::Literal("push_back"), method_22834, 0, "ref", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5022c, type_3254), Reflex::Literal("operator[]"), operator_22835, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5022c, type_3254), Reflex::Literal("at"), method_22836, 0, "idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20674), Reflex::Literal("refVector"), method_22837, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("empty"), method_22838, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3254), Reflex::Literal("size"), method_22839, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3254), Reflex::Literal("capacity"), method_22840, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_3254), Reflex::Literal("reserve"), method_22841, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4615), Reflex::Literal("begin"), method_22842, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4615), Reflex::Literal("end"), method_22843, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4933), Reflex::Literal("id"), method_22844, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20675), Reflex::Literal("productGetter"), method_22845, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isNull"), method_22846, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isNonnull"), method_22847, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("operator!"), operator_22848, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39291), Reflex::Literal("product"), method_22849, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isAvailable"), method_22850, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isTransient"), method_22851, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4615, type_39292), Reflex::Literal("erase"), method_22852, 0, "pos", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694), Reflex::Literal("clear"), method_22853, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_39293), Reflex::Literal("swap"), method_22854, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39293, type_39289), Reflex::Literal("operator="), operator_22855, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("hasProductCache"), method_22856, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20599, type_20679, type_20680), Reflex::Literal("fillView"), method_22857, 0, ";pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_237), Reflex::Literal("Class_Version"), method_22858, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefVector<std::vector<reco::CastorJetID, std::allocator<reco::CastorJetID> >,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID, std::allocator<reco::CastorJetID> >, reco::CastorJetID> > -------------------------------
static void destructor_22872(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->::edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >::~RefVector)();
}
static void constructor_22873( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >();
  else ::new(mem) ::edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >();
}

static void constructor_22874( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >(*(const ::edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)arg[0]);
  else ::new(mem) ::edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >(*(const ::edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)arg[0]);
}

static void constructor_22875( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >(*(const ::edm::ProductID*)arg[0]);
}

static  void method_22876( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->push_back)(*(const ::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)arg[0]);
}

static  void operator_22877( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >)((((const ::edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->operator[])(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_22878( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >)((((const ::edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->at)(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_22879( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->refVector)();
  else   (((const ::edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->refVector)();
}

static  void method_22880( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->empty)());
  else   (((const ::edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->empty)();
}

static  void method_22881( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->size)());
  else   (((const ::edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->size)();
}

static  void method_22882( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->capacity)());
  else   (((const ::edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->capacity)();
}

static  void method_22883( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void method_22884( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >)((((const ::edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->begin)());
  else   (((const ::edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->begin)();
}

static  void method_22885( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >)((((const ::edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->end)());
  else   (((const ::edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->end)();
}

static  void method_22886( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->id)());
  else   (((const ::edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->id)();
}

static  void method_22887( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->productGetter)());
  else   (((const ::edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->productGetter)();
}

static  void method_22888( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->isNull)());
  else   (((const ::edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->isNull)();
}

static  void method_22889( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->isNonnull)());
  else   (((const ::edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->isNonnull)();
}

static  void operator_22890( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->operator!)());
  else   (((const ::edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->operator!)();
}

static  void method_22891( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->product)());
  else   (((const ::edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->product)();
}

static  void method_22892( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->isAvailable)());
  else   (((const ::edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->isAvailable)();
}

static  void method_22893( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->isTransient)());
  else   (((const ::edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->isTransient)();
}

static  void method_22894( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >)((((::edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->erase)(*(const ::edm::RefVectorIterator<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)arg[0]));
  else   (((::edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->erase)(*(const ::edm::RefVectorIterator<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)arg[0]);
}

static  void method_22895( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->clear)();
}

static  void method_22896( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->swap)(*(::edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)arg[0]);
}

static  void operator_22897( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->operator=)(*(const ::edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)arg[0]);
  else   (((::edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->operator=)(*(const ::edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)arg[0]);
}

static  void method_22898( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->hasProductCache)());
  else   (((const ::edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->hasProductCache)();
}

static  void method_22899( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::edm::helper_vector*)arg[2]);
}

static  void method_22900( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->Class_Version)());
  else   (((::edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->Class_Version)();
}

static void method_newdel_4686( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefVector<std::vector<reco::CastorJetID, std::allocator<reco::CastorJetID> >,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID, std::allocator<reco::CastorJetID> >, reco::CastorJetID> > -------------------------------
void __edm__RefVector_std__vector_reco__CastorJetID__reco__CastorJetID_edm__refhelper__FindUsingAdvance_std__vector_reco__CastorJetID__reco__CastorJetID_s__db_datamem(Reflex::Class*);
void __edm__RefVector_std__vector_reco__CastorJetID__reco__CastorJetID_edm__refhelper__FindUsingAdvance_std__vector_reco__CastorJetID__reco__CastorJetID_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefVector_std__vector_reco__CastorJetID__reco__CastorJetID_edm__refhelper__FindUsingAdvance_std__vector_reco__CastorJetID__reco__CastorJetID_s__datamem_bld(&__edm__RefVector_std__vector_reco__CastorJetID__reco__CastorJetID_edm__refhelper__FindUsingAdvance_std__vector_reco__CastorJetID__reco__CastorJetID_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefVector_std__vector_reco__CastorJetID__reco__CastorJetID_edm__refhelper__FindUsingAdvance_std__vector_reco__CastorJetID__reco__CastorJetID_s__funcmem_bld(&__edm__RefVector_std__vector_reco__CastorJetID__reco__CastorJetID_edm__refhelper__FindUsingAdvance_std__vector_reco__CastorJetID__reco__CastorJetID_s__db_funcmem);
void __edm__RefVector_std__vector_reco__CastorJetID__reco__CastorJetID_edm__refhelper__FindUsingAdvance_std__vector_reco__CastorJetID__reco__CastorJetID_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >"), typeid(::edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >), sizeof(::edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >::Class_Version())
  .AddTypedef(type_2999, Reflex::Literal("edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >::collection_type"))
  .AddTypedef(type_7846, Reflex::Literal("edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >::member_type"))
  .AddTypedef(type_20853, Reflex::Literal("edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >::finder_type"))
  .AddTypedef(type_4616, Reflex::Literal("edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >::iterator"))
  .AddTypedef(type_4616, Reflex::Literal("edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >::const_iterator"))
  .AddTypedef(type_5025, Reflex::Literal("edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >::value_type"))
  .AddTypedef(type_5025c, Reflex::Literal("edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >::const_reference"))
  .AddTypedef(type_5025c, Reflex::Literal("edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >::reference"))
  .AddTypedef(type_366, Reflex::Literal("edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >::key_type"))
  .AddTypedef(type_2972, Reflex::Literal("edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >::KeyVec"))
  .AddTypedef(type_3254, Reflex::Literal("edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >::size_type"))
  .AddTypedef(type_4039, Reflex::Literal("edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >::contents_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefVector"), destructor_22872, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefVector"), constructor_22873, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39295), Reflex::Literal("RefVector"), constructor_22874, 0, "rh", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20599), Reflex::Literal("RefVector"), constructor_22875, 0, "iId", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4686, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefVector_std__vector_reco__CastorJetID__reco__CastorJetID_edm__refhelper__FindUsingAdvance_std__vector_reco__CastorJetID__reco__CastorJetID_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefVector_std__vector_reco__CastorJetID__reco__CastorJetID_edm__refhelper__FindUsingAdvance_std__vector_reco__CastorJetID__reco__CastorJetID_s__funcmem_bld);
}

//------Delayed data member builder for class RefVector<std::vector<reco::CastorJetID, std::allocator<reco::CastorJetID> >,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID, std::allocator<reco::CastorJetID> >, reco::CastorJetID> > -------------------
void __edm__RefVector_std__vector_reco__CastorJetID__reco__CastorJetID_edm__refhelper__FindUsingAdvance_std__vector_reco__CastorJetID__reco__CastorJetID_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4039, Reflex::Literal("refVector_"), OffsetOf(__shadow__::__edm__RefVector_std__vector_reco__CastorJetID__reco__CastorJetID_edm__refhelper__FindUsingAdvance_std__vector_reco__CastorJetID__reco__CastorJetID_s_, refVector_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefVector<std::vector<reco::CastorJetID, std::allocator<reco::CastorJetID> >,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID, std::allocator<reco::CastorJetID> >, reco::CastorJetID> > -------------------
void __edm__RefVector_std__vector_reco__CastorJetID__reco__CastorJetID_edm__refhelper__FindUsingAdvance_std__vector_reco__CastorJetID__reco__CastorJetID_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_39296), Reflex::Literal("push_back"), method_22876, 0, "ref", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5025c, type_3254), Reflex::Literal("operator[]"), operator_22877, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5025c, type_3254), Reflex::Literal("at"), method_22878, 0, "idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20674), Reflex::Literal("refVector"), method_22879, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("empty"), method_22880, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3254), Reflex::Literal("size"), method_22881, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3254), Reflex::Literal("capacity"), method_22882, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_3254), Reflex::Literal("reserve"), method_22883, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4616), Reflex::Literal("begin"), method_22884, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4616), Reflex::Literal("end"), method_22885, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4933), Reflex::Literal("id"), method_22886, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20675), Reflex::Literal("productGetter"), method_22887, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isNull"), method_22888, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isNonnull"), method_22889, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("operator!"), operator_22890, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39297), Reflex::Literal("product"), method_22891, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isAvailable"), method_22892, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isTransient"), method_22893, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4616, type_39298), Reflex::Literal("erase"), method_22894, 0, "pos", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694), Reflex::Literal("clear"), method_22895, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_39299), Reflex::Literal("swap"), method_22896, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39299, type_39295), Reflex::Literal("operator="), operator_22897, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("hasProductCache"), method_22898, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20599, type_20679, type_20680), Reflex::Literal("fillView"), method_22899, 0, ";pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_237), Reflex::Literal("Class_Version"), method_22900, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefVector<std::vector<reco::JetID, std::allocator<reco::JetID> >,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID, std::allocator<reco::JetID> >, reco::JetID> > -------------------------------
static void destructor_22914(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->::edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >::~RefVector)();
}
static void constructor_22915( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >();
  else ::new(mem) ::edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >();
}

static void constructor_22916( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >(*(const ::edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)arg[0]);
  else ::new(mem) ::edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >(*(const ::edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)arg[0]);
}

static void constructor_22917( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >(*(const ::edm::ProductID*)arg[0]);
}

static  void method_22918( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->push_back)(*(const ::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)arg[0]);
}

static  void operator_22919( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >)((((const ::edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->operator[])(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_22920( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >)((((const ::edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->at)(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_22921( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->refVector)();
  else   (((const ::edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->refVector)();
}

static  void method_22922( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->empty)());
  else   (((const ::edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->empty)();
}

static  void method_22923( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->size)());
  else   (((const ::edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->size)();
}

static  void method_22924( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->capacity)());
  else   (((const ::edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->capacity)();
}

static  void method_22925( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void method_22926( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >)((((const ::edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->begin)());
  else   (((const ::edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->begin)();
}

static  void method_22927( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >)((((const ::edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->end)());
  else   (((const ::edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->end)();
}

static  void method_22928( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->id)());
  else   (((const ::edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->id)();
}

static  void method_22929( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->productGetter)());
  else   (((const ::edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->productGetter)();
}

static  void method_22930( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->isNull)());
  else   (((const ::edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->isNull)();
}

static  void method_22931( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->isNonnull)());
  else   (((const ::edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->isNonnull)();
}

static  void operator_22932( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->operator!)());
  else   (((const ::edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->operator!)();
}

static  void method_22933( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->product)());
  else   (((const ::edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->product)();
}

static  void method_22934( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->isAvailable)());
  else   (((const ::edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->isAvailable)();
}

static  void method_22935( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->isTransient)());
  else   (((const ::edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->isTransient)();
}

static  void method_22936( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >)((((::edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->erase)(*(const ::edm::RefVectorIterator<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)arg[0]));
  else   (((::edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->erase)(*(const ::edm::RefVectorIterator<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)arg[0]);
}

static  void method_22937( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->clear)();
}

static  void method_22938( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->swap)(*(::edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)arg[0]);
}

static  void operator_22939( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->operator=)(*(const ::edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)arg[0]);
  else   (((::edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->operator=)(*(const ::edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)arg[0]);
}

static  void method_22940( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->hasProductCache)());
  else   (((const ::edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->hasProductCache)();
}

static  void method_22941( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::edm::helper_vector*)arg[2]);
}

static  void method_22942( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->Class_Version)());
  else   (((::edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->Class_Version)();
}

static void method_newdel_4691( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefVector<std::vector<reco::JetID, std::allocator<reco::JetID> >,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID, std::allocator<reco::JetID> >, reco::JetID> > -------------------------------
void __edm__RefVector_std__vector_reco__JetID__reco__JetID_edm__refhelper__FindUsingAdvance_std__vector_reco__JetID__reco__JetID_s__db_datamem(Reflex::Class*);
void __edm__RefVector_std__vector_reco__JetID__reco__JetID_edm__refhelper__FindUsingAdvance_std__vector_reco__JetID__reco__JetID_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefVector_std__vector_reco__JetID__reco__JetID_edm__refhelper__FindUsingAdvance_std__vector_reco__JetID__reco__JetID_s__datamem_bld(&__edm__RefVector_std__vector_reco__JetID__reco__JetID_edm__refhelper__FindUsingAdvance_std__vector_reco__JetID__reco__JetID_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefVector_std__vector_reco__JetID__reco__JetID_edm__refhelper__FindUsingAdvance_std__vector_reco__JetID__reco__JetID_s__funcmem_bld(&__edm__RefVector_std__vector_reco__JetID__reco__JetID_edm__refhelper__FindUsingAdvance_std__vector_reco__JetID__reco__JetID_s__db_funcmem);
void __edm__RefVector_std__vector_reco__JetID__reco__JetID_edm__refhelper__FindUsingAdvance_std__vector_reco__JetID__reco__JetID_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >"), typeid(::edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >), sizeof(::edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >::Class_Version())
  .AddTypedef(type_3000, Reflex::Literal("edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >::collection_type"))
  .AddTypedef(type_7841, Reflex::Literal("edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >::member_type"))
  .AddTypedef(type_20865, Reflex::Literal("edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >::finder_type"))
  .AddTypedef(type_4617, Reflex::Literal("edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >::iterator"))
  .AddTypedef(type_4617, Reflex::Literal("edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >::const_iterator"))
  .AddTypedef(type_5026, Reflex::Literal("edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >::value_type"))
  .AddTypedef(type_5026c, Reflex::Literal("edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >::const_reference"))
  .AddTypedef(type_5026c, Reflex::Literal("edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >::reference"))
  .AddTypedef(type_366, Reflex::Literal("edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >::key_type"))
  .AddTypedef(type_2972, Reflex::Literal("edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >::KeyVec"))
  .AddTypedef(type_3254, Reflex::Literal("edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >::size_type"))
  .AddTypedef(type_4039, Reflex::Literal("edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >::contents_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefVector"), destructor_22914, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefVector"), constructor_22915, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39301), Reflex::Literal("RefVector"), constructor_22916, 0, "rh", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20599), Reflex::Literal("RefVector"), constructor_22917, 0, "iId", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4691, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefVector_std__vector_reco__JetID__reco__JetID_edm__refhelper__FindUsingAdvance_std__vector_reco__JetID__reco__JetID_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefVector_std__vector_reco__JetID__reco__JetID_edm__refhelper__FindUsingAdvance_std__vector_reco__JetID__reco__JetID_s__funcmem_bld);
}

//------Delayed data member builder for class RefVector<std::vector<reco::JetID, std::allocator<reco::JetID> >,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID, std::allocator<reco::JetID> >, reco::JetID> > -------------------
void __edm__RefVector_std__vector_reco__JetID__reco__JetID_edm__refhelper__FindUsingAdvance_std__vector_reco__JetID__reco__JetID_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4039, Reflex::Literal("refVector_"), OffsetOf(__shadow__::__edm__RefVector_std__vector_reco__JetID__reco__JetID_edm__refhelper__FindUsingAdvance_std__vector_reco__JetID__reco__JetID_s_, refVector_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefVector<std::vector<reco::JetID, std::allocator<reco::JetID> >,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID, std::allocator<reco::JetID> >, reco::JetID> > -------------------
void __edm__RefVector_std__vector_reco__JetID__reco__JetID_edm__refhelper__FindUsingAdvance_std__vector_reco__JetID__reco__JetID_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_39302), Reflex::Literal("push_back"), method_22918, 0, "ref", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5026c, type_3254), Reflex::Literal("operator[]"), operator_22919, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5026c, type_3254), Reflex::Literal("at"), method_22920, 0, "idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20674), Reflex::Literal("refVector"), method_22921, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("empty"), method_22922, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3254), Reflex::Literal("size"), method_22923, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3254), Reflex::Literal("capacity"), method_22924, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_3254), Reflex::Literal("reserve"), method_22925, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4617), Reflex::Literal("begin"), method_22926, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4617), Reflex::Literal("end"), method_22927, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4933), Reflex::Literal("id"), method_22928, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20675), Reflex::Literal("productGetter"), method_22929, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isNull"), method_22930, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isNonnull"), method_22931, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("operator!"), operator_22932, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39303), Reflex::Literal("product"), method_22933, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isAvailable"), method_22934, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isTransient"), method_22935, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4617, type_39304), Reflex::Literal("erase"), method_22936, 0, "pos", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694), Reflex::Literal("clear"), method_22937, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_39305), Reflex::Literal("swap"), method_22938, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39305, type_39301), Reflex::Literal("operator="), operator_22939, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("hasProductCache"), method_22940, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20599, type_20679, type_20680), Reflex::Literal("fillView"), method_22941, 0, ";pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_237), Reflex::Literal("Class_Version"), method_22942, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class FFTJetProducerSummary -------------------------------
static void destructor_28592(void*, void * o, const std::vector<void*>&, void *) {
(((::reco::FFTJetProducerSummary*)o)->::reco::FFTJetProducerSummary::~FFTJetProducerSummary)();
}
static  void operator_28593( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::reco::FFTJetProducerSummary*)o)->operator=)(*(const ::reco::FFTJetProducerSummary*)arg[0]);
  else   (((::reco::FFTJetProducerSummary*)o)->operator=)(*(const ::reco::FFTJetProducerSummary*)arg[0]);
}

static void constructor_28594( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::FFTJetProducerSummary(*(const ::reco::FFTJetProducerSummary*)arg[0]);
  else ::new(mem) ::reco::FFTJetProducerSummary(*(const ::reco::FFTJetProducerSummary*)arg[0]);
}

static void constructor_28595( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::FFTJetProducerSummary();
  else ::new(mem) ::reco::FFTJetProducerSummary();
}

static void constructor_28596( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::FFTJetProducerSummary(*(const ::std::vector<double>*)arg[0],
      *(const ::std::vector<unsigned int>*)arg[1],
      *(const ::math::XYZTLorentzVector*)arg[2],
      *(const ::std::vector<edm::Ptr<reco::Candidate> >*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(unsigned int*)arg[8],
      *(unsigned int*)arg[9],
      *(bool*)arg[10]);
  else ::new(mem) ::reco::FFTJetProducerSummary(*(const ::std::vector<double>*)arg[0],
      *(const ::std::vector<unsigned int>*)arg[1],
      *(const ::math::XYZTLorentzVector*)arg[2],
      *(const ::std::vector<edm::Ptr<reco::Candidate> >*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(unsigned int*)arg[8],
      *(unsigned int*)arg[9],
      *(bool*)arg[10]);
}

static  void method_28597( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::reco::FFTJetProducerSummary*)o)->thresholds)();
  else   (((const ::reco::FFTJetProducerSummary*)o)->thresholds)();
}

static  void method_28598( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::reco::FFTJetProducerSummary*)o)->levelOccupancy)();
  else   (((const ::reco::FFTJetProducerSummary*)o)->levelOccupancy)();
}

static  void method_28599( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::reco::FFTJetProducerSummary*)o)->unclustered)();
  else   (((const ::reco::FFTJetProducerSummary*)o)->unclustered)();
}

static  void method_28600( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::reco::FFTJetProducerSummary*)o)->unclusteredConstituents)();
  else   (((const ::reco::FFTJetProducerSummary*)o)->unclusteredConstituents)();
}

static  void method_28601( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::reco::FFTJetProducerSummary*)o)->unusedEt)());
  else   (((const ::reco::FFTJetProducerSummary*)o)->unusedEt)();
}

static  void method_28602( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::reco::FFTJetProducerSummary*)o)->minScale)());
  else   (((const ::reco::FFTJetProducerSummary*)o)->minScale)();
}

static  void method_28603( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::reco::FFTJetProducerSummary*)o)->maxScale)());
  else   (((const ::reco::FFTJetProducerSummary*)o)->maxScale)();
}

static  void method_28604( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::reco::FFTJetProducerSummary*)o)->scaleUsed)());
  else   (((const ::reco::FFTJetProducerSummary*)o)->scaleUsed)();
}

static  void method_28605( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::reco::FFTJetProducerSummary*)o)->preclustersFound)());
  else   (((const ::reco::FFTJetProducerSummary*)o)->preclustersFound)();
}

static  void method_28606( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::reco::FFTJetProducerSummary*)o)->iterationsPerformed)());
  else   (((const ::reco::FFTJetProducerSummary*)o)->iterationsPerformed)();
}

static  void method_28607( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::reco::FFTJetProducerSummary*)o)->iterationsConverged)());
  else   (((const ::reco::FFTJetProducerSummary*)o)->iterationsConverged)();
}

static void method_newdel_7921( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::reco::FFTJetProducerSummary >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::reco::FFTJetProducerSummary >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::reco::FFTJetProducerSummary >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::reco::FFTJetProducerSummary >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::reco::FFTJetProducerSummary >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class FFTJetProducerSummary -------------------------------
void __reco__FFTJetProducerSummary_db_datamem(Reflex::Class*);
void __reco__FFTJetProducerSummary_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __reco__FFTJetProducerSummary_datamem_bld(&__reco__FFTJetProducerSummary_db_datamem);
Reflex::GenreflexMemberBuilder __reco__FFTJetProducerSummary_funcmem_bld(&__reco__FFTJetProducerSummary_db_funcmem);
void __reco__FFTJetProducerSummary_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("reco::FFTJetProducerSummary"), typeid(::reco::FFTJetProducerSummary), sizeof(::reco::FFTJetProducerSummary), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~FFTJetProducerSummary"), destructor_28592, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_40916, type_40917), Reflex::Literal("operator="), operator_28593, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_40917), Reflex::Literal("FFTJetProducerSummary"), constructor_28594, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("FFTJetProducerSummary"), constructor_28595, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35970, type_35943, type_26316, type_36086, type_101, type_101, type_101, type_101, type_366, type_366, type_1566), Reflex::Literal("FFTJetProducerSummary"), constructor_28596, 0, "thresholds;levelOccupancy;unclustered;constituents;unused;minScale;maxScale;scaleUsed;preclustersFound;iterationsPerformed;converged", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_7921, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__reco__FFTJetProducerSummary_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__reco__FFTJetProducerSummary_funcmem_bld);
}

//------Delayed data member builder for class FFTJetProducerSummary -------------------
void __reco__FFTJetProducerSummary_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2991, Reflex::Literal("thresholds_"), OffsetOf(__shadow__::__reco__FFTJetProducerSummary, thresholds_), ::Reflex::PRIVATE)
  .AddDataMember(type_2972, Reflex::Literal("levelOccupancy_"), OffsetOf(__shadow__::__reco__FFTJetProducerSummary, levelOccupancy_), ::Reflex::PRIVATE)
  .AddDataMember(type_6815, Reflex::Literal("unclustered_"), OffsetOf(__shadow__::__reco__FFTJetProducerSummary, unclustered_), ::Reflex::PRIVATE)
  .AddDataMember(type_3006, Reflex::Literal("unclusConstituents_"), OffsetOf(__shadow__::__reco__FFTJetProducerSummary, unclusConstituents_), ::Reflex::PRIVATE)
  .AddDataMember(type_894, Reflex::Literal("unused_"), OffsetOf(__shadow__::__reco__FFTJetProducerSummary, unused_), ::Reflex::PRIVATE)
  .AddDataMember(type_894, Reflex::Literal("minScale_"), OffsetOf(__shadow__::__reco__FFTJetProducerSummary, minScale_), ::Reflex::PRIVATE)
  .AddDataMember(type_894, Reflex::Literal("maxScale_"), OffsetOf(__shadow__::__reco__FFTJetProducerSummary, maxScale_), ::Reflex::PRIVATE)
  .AddDataMember(type_894, Reflex::Literal("scaleUsed_"), OffsetOf(__shadow__::__reco__FFTJetProducerSummary, scaleUsed_), ::Reflex::PRIVATE)
  .AddDataMember(type_366, Reflex::Literal("preclustersFound_"), OffsetOf(__shadow__::__reco__FFTJetProducerSummary, preclustersFound_), ::Reflex::PRIVATE)
  .AddDataMember(type_366, Reflex::Literal("iterationsPerformed_"), OffsetOf(__shadow__::__reco__FFTJetProducerSummary, iterationsPerformed_), ::Reflex::PRIVATE)
  .AddDataMember(type_1566, Reflex::Literal("converged_"), OffsetOf(__shadow__::__reco__FFTJetProducerSummary, converged_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class FFTJetProducerSummary -------------------
void __reco__FFTJetProducerSummary_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35976), Reflex::Literal("thresholds"), method_28597, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35943), Reflex::Literal("levelOccupancy"), method_28598, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26316), Reflex::Literal("unclustered"), method_28599, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_36086), Reflex::Literal("unclusteredConstituents"), method_28600, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_894), Reflex::Literal("unusedEt"), method_28601, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_894), Reflex::Literal("minScale"), method_28602, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_894), Reflex::Literal("maxScale"), method_28603, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_894), Reflex::Literal("scaleUsed"), method_28604, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_366), Reflex::Literal("preclustersFound"), method_28605, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_366), Reflex::Literal("iterationsPerformed"), method_28606, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("iterationsConverged"), method_28607, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<reco::FFTJetProducerSummary> -------------------------------
static void constructor_23346( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<reco::FFTJetProducerSummary>();
  else ::new(mem) ::edm::Wrapper<reco::FFTJetProducerSummary>();
}

static void constructor_23347( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<reco::FFTJetProducerSummary>(*(::std::auto_ptr<reco::FFTJetProducerSummary>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<reco::FFTJetProducerSummary>(*(::std::auto_ptr<reco::FFTJetProducerSummary>*)arg[0]);
}

static void destructor_23348(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<reco::FFTJetProducerSummary>*)o)->::edm::Wrapper<reco::FFTJetProducerSummary>::~Wrapper)();
}
static  void method_23349( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<reco::FFTJetProducerSummary>*)o)->product)());
  else   (((const ::edm::Wrapper<reco::FFTJetProducerSummary>*)o)->product)();
}

static  void operator_23350( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<reco::FFTJetProducerSummary>*)o)->operator->)());
  else   (((const ::edm::Wrapper<reco::FFTJetProducerSummary>*)o)->operator->)();
}

static  void method_23351( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<reco::FFTJetProducerSummary>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<reco::FFTJetProducerSummary>*)o)->productTypeInfo)();
}

static  void method_23352( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<reco::FFTJetProducerSummary>*)o)->typeInfo)();
  else   (((::edm::Wrapper<reco::FFTJetProducerSummary>*)o)->typeInfo)();
}

static void constructor_23353( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<reco::FFTJetProducerSummary>((::reco::FFTJetProducerSummary*)arg[0]);
  else ::new(mem) ::edm::Wrapper<reco::FFTJetProducerSummary>((::reco::FFTJetProducerSummary*)arg[0]);
}

static  void method_23354( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<reco::FFTJetProducerSummary>*)o)->getInterface)());
  else   (((::edm::Wrapper<reco::FFTJetProducerSummary>*)o)->getInterface)();
}

static  void method_23355( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<reco::FFTJetProducerSummary>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_23356( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<reco::FFTJetProducerSummary>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_23357( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<reco::FFTJetProducerSummary>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_23358( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<reco::FFTJetProducerSummary>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<reco::FFTJetProducerSummary>*)o)->dynamicTypeInfo)();
}

static  void method_23359( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<reco::FFTJetProducerSummary>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<reco::FFTJetProducerSummary>*)o)->isPresent)();
}

static  void method_23360( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<reco::FFTJetProducerSummary>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<reco::FFTJetProducerSummary>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4750( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::FFTJetProducerSummary> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::FFTJetProducerSummary> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::FFTJetProducerSummary> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::FFTJetProducerSummary> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::FFTJetProducerSummary> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<reco::FFTJetProducerSummary> -------------------------------
void __edm__Wrapper_reco__FFTJetProducerSummary__db_datamem(Reflex::Class*);
void __edm__Wrapper_reco__FFTJetProducerSummary__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_reco__FFTJetProducerSummary__datamem_bld(&__edm__Wrapper_reco__FFTJetProducerSummary__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_reco__FFTJetProducerSummary__funcmem_bld(&__edm__Wrapper_reco__FFTJetProducerSummary__db_funcmem);
void __edm__Wrapper_reco__FFTJetProducerSummary__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<reco::FFTJetProducerSummary>"), typeid(::edm::Wrapper<reco::FFTJetProducerSummary>), sizeof(::edm::Wrapper<reco::FFTJetProducerSummary>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_7921, Reflex::Literal("edm::Wrapper<reco::FFTJetProducerSummary>::value_type"))
  .AddTypedef(type_7921, Reflex::Literal("edm::Wrapper<reco::FFTJetProducerSummary>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_23346, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2787), Reflex::Literal("Wrapper"), constructor_23347, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_23348, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39383), Reflex::Literal("Wrapper"), constructor_23353, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4750, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_reco__FFTJetProducerSummary__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_reco__FFTJetProducerSummary__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<reco::FFTJetProducerSummary> -------------------
void __edm__Wrapper_reco__FFTJetProducerSummary__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1566, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_reco__FFTJetProducerSummary_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_7921, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_reco__FFTJetProducerSummary_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<reco::FFTJetProducerSummary> -------------------
void __edm__Wrapper_reco__FFTJetProducerSummary__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39382), Reflex::Literal("product"), method_23349, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39382), Reflex::Literal("operator->"), operator_23350, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("productTypeInfo"), method_23351, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("typeInfo"), method_23352, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39384), Reflex::Literal("getInterface"), method_23354, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20599, type_20679, type_38738), Reflex::Literal("fillView"), method_23355, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20732, type_358, type_11036), Reflex::Literal("setPtr"), method_23356, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20732, type_26144, type_20679), Reflex::Literal("fillPtrVector"), method_23357, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("dynamicTypeInfo"), method_23358, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isPresent"), method_23359, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("dynamicTypeInfo_"), method_23360, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class PattRecoTree<double,reco::PattRecoPeak<double> > -------------------------------
static void destructor_27774(void*, void * o, const std::vector<void*>&, void *) {
(((::reco::PattRecoTree<double,reco::PattRecoPeak<double> >*)o)->::reco::PattRecoTree<double,reco::PattRecoPeak<double> >::~PattRecoTree)();
}
static  void operator_27775( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::reco::PattRecoTree<double,reco::PattRecoPeak<double> >*)o)->operator=)(*(const ::reco::PattRecoTree<double,reco::PattRecoPeak<double> >*)arg[0]);
  else   (((::reco::PattRecoTree<double,reco::PattRecoPeak<double> >*)o)->operator=)(*(const ::reco::PattRecoTree<double,reco::PattRecoPeak<double> >*)arg[0]);
}

static void constructor_27776( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::PattRecoTree<double,reco::PattRecoPeak<double> >(*(const ::reco::PattRecoTree<double,reco::PattRecoPeak<double> >*)arg[0]);
  else ::new(mem) ::reco::PattRecoTree<double,reco::PattRecoPeak<double> >(*(const ::reco::PattRecoTree<double,reco::PattRecoPeak<double> >*)arg[0]);
}

static void constructor_27777( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::PattRecoTree<double,reco::PattRecoPeak<double> >();
  else ::new(mem) ::reco::PattRecoTree<double,reco::PattRecoPeak<double> >();
}

static  void method_27778( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::reco::PattRecoTree<double,reco::PattRecoPeak<double> >*)o)->isSparse)());
  else   (((const ::reco::PattRecoTree<double,reco::PattRecoPeak<double> >*)o)->isSparse)();
}

static  void method_27779( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::reco::PattRecoTree<double,reco::PattRecoPeak<double> >*)o)->getNodes)();
  else   (((const ::reco::PattRecoTree<double,reco::PattRecoPeak<double> >*)o)->getNodes)();
}

static  void method_27780( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::reco::PattRecoTree<double,reco::PattRecoPeak<double> >*)o)->getScales)();
  else   (((const ::reco::PattRecoTree<double,reco::PattRecoPeak<double> >*)o)->getScales)();
}

static  void method_27781( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::reco::PattRecoTree<double,reco::PattRecoPeak<double> >*)o)->setSparse)(*(const bool*)arg[0]);
}

static  void method_27782( void*, void* o, const std::vector<void*>&, void*)
{
  (((::reco::PattRecoTree<double,reco::PattRecoPeak<double> >*)o)->clear)();
}

static  void method_27783( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::reco::PattRecoTree<double,reco::PattRecoPeak<double> >*)o)->reserveNodes)(*(const unsigned int*)arg[0]);
}

static  void method_27784( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::reco::PattRecoTree<double,reco::PattRecoPeak<double> >*)o)->reserveScales)(*(const unsigned int*)arg[0]);
}

static  void method_27785( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::reco::PattRecoTree<double,reco::PattRecoPeak<double> >*)o)->addNode)(*(const ::reco::PattRecoNode<reco::PattRecoPeak<double> >*)arg[0]);
}

static  void method_27786( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::reco::PattRecoTree<double,reco::PattRecoPeak<double> >*)o)->addScale)(*(const double*)arg[0]);
}

static void method_newdel_7832( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::reco::PattRecoTree<double,reco::PattRecoPeak<double> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::reco::PattRecoTree<double,reco::PattRecoPeak<double> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::reco::PattRecoTree<double,reco::PattRecoPeak<double> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::reco::PattRecoTree<double,reco::PattRecoPeak<double> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::reco::PattRecoTree<double,reco::PattRecoPeak<double> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class PattRecoTree<double,reco::PattRecoPeak<double> > -------------------------------
void __reco__PattRecoTree_double_reco__PattRecoPeak_double_s__db_datamem(Reflex::Class*);
void __reco__PattRecoTree_double_reco__PattRecoPeak_double_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __reco__PattRecoTree_double_reco__PattRecoPeak_double_s__datamem_bld(&__reco__PattRecoTree_double_reco__PattRecoPeak_double_s__db_datamem);
Reflex::GenreflexMemberBuilder __reco__PattRecoTree_double_reco__PattRecoPeak_double_s__funcmem_bld(&__reco__PattRecoTree_double_reco__PattRecoPeak_double_s__db_funcmem);
void __reco__PattRecoTree_double_reco__PattRecoPeak_double_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("reco::PattRecoTree<double,reco::PattRecoPeak<double> >"), typeid(::reco::PattRecoTree<double,reco::PattRecoPeak<double> >), sizeof(::reco::PattRecoTree<double,reco::PattRecoPeak<double> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_7891, Reflex::Literal("reco::PattRecoTree<double,reco::PattRecoPeak<double> >::Node"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PattRecoTree"), destructor_27774, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_40763, type_40764), Reflex::Literal("operator="), operator_27775, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_40764), Reflex::Literal("PattRecoTree"), constructor_27776, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PattRecoTree"), constructor_27777, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_7832, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__reco__PattRecoTree_double_reco__PattRecoPeak_double_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__reco__PattRecoTree_double_reco__PattRecoPeak_double_s__funcmem_bld);
}

//------Delayed data member builder for class PattRecoTree<double,reco::PattRecoPeak<double> > -------------------
void __reco__PattRecoTree_double_reco__PattRecoPeak_double_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2990, Reflex::Literal("nodes_"), OffsetOf(__shadow__::__reco__PattRecoTree_double_reco__PattRecoPeak_double_s_, nodes_), ::Reflex::PRIVATE)
  .AddDataMember(type_2989, Reflex::Literal("scales_"), OffsetOf(__shadow__::__reco__PattRecoTree_double_reco__PattRecoPeak_double_s_, scales_), ::Reflex::PRIVATE)
  .AddDataMember(type_1566, Reflex::Literal("sparse_"), OffsetOf(__shadow__::__reco__PattRecoTree_double_reco__PattRecoPeak_double_s_, sparse_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class PattRecoTree<double,reco::PattRecoPeak<double> > -------------------
void __reco__PattRecoTree_double_reco__PattRecoPeak_double_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isSparse"), method_27778, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35973), Reflex::Literal("getNodes"), method_27779, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35970), Reflex::Literal("getScales"), method_27780, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_1566c), Reflex::Literal("setSparse"), method_27781, 0, "b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694), Reflex::Literal("clear"), method_27782, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_366c), Reflex::Literal("reserveNodes"), method_27783, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_366c), Reflex::Literal("reserveScales"), method_27784, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_13953), Reflex::Literal("addNode"), method_27785, 0, "node", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_101c), Reflex::Literal("addScale"), method_27786, 0, "s", ::Reflex::PUBLIC);
}
//------Stub functions for class Wrapper<reco::PattRecoTree<double, reco::PattRecoPeak<double> > > -------------------------------
static void constructor_23367( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<reco::PattRecoTree<double,reco::PattRecoPeak<double> > >();
  else ::new(mem) ::edm::Wrapper<reco::PattRecoTree<double,reco::PattRecoPeak<double> > >();
}

static void constructor_23368( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<reco::PattRecoTree<double,reco::PattRecoPeak<double> > >(*(::std::auto_ptr<reco::PattRecoTree<double,reco::PattRecoPeak<double> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<reco::PattRecoTree<double,reco::PattRecoPeak<double> > >(*(::std::auto_ptr<reco::PattRecoTree<double,reco::PattRecoPeak<double> > >*)arg[0]);
}

static void destructor_23369(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<reco::PattRecoTree<double,reco::PattRecoPeak<double> > >*)o)->::edm::Wrapper<reco::PattRecoTree<double,reco::PattRecoPeak<double> > >::~Wrapper)();
}
static  void method_23370( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<reco::PattRecoTree<double,reco::PattRecoPeak<double> > >*)o)->product)());
  else   (((const ::edm::Wrapper<reco::PattRecoTree<double,reco::PattRecoPeak<double> > >*)o)->product)();
}

static  void operator_23371( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<reco::PattRecoTree<double,reco::PattRecoPeak<double> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<reco::PattRecoTree<double,reco::PattRecoPeak<double> > >*)o)->operator->)();
}

static  void method_23372( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<reco::PattRecoTree<double,reco::PattRecoPeak<double> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<reco::PattRecoTree<double,reco::PattRecoPeak<double> > >*)o)->productTypeInfo)();
}

static  void method_23373( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<reco::PattRecoTree<double,reco::PattRecoPeak<double> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<reco::PattRecoTree<double,reco::PattRecoPeak<double> > >*)o)->typeInfo)();
}

static void constructor_23374( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<reco::PattRecoTree<double,reco::PattRecoPeak<double> > >((::reco::PattRecoTree<double,reco::PattRecoPeak<double> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<reco::PattRecoTree<double,reco::PattRecoPeak<double> > >((::reco::PattRecoTree<double,reco::PattRecoPeak<double> >*)arg[0]);
}

static  void method_23375( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<reco::PattRecoTree<double,reco::PattRecoPeak<double> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<reco::PattRecoTree<double,reco::PattRecoPeak<double> > >*)o)->getInterface)();
}

static  void method_23376( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<reco::PattRecoTree<double,reco::PattRecoPeak<double> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_23377( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<reco::PattRecoTree<double,reco::PattRecoPeak<double> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_23378( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<reco::PattRecoTree<double,reco::PattRecoPeak<double> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_23379( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<reco::PattRecoTree<double,reco::PattRecoPeak<double> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<reco::PattRecoTree<double,reco::PattRecoPeak<double> > >*)o)->dynamicTypeInfo)();
}

static  void method_23380( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<reco::PattRecoTree<double,reco::PattRecoPeak<double> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<reco::PattRecoTree<double,reco::PattRecoPeak<double> > >*)o)->isPresent)();
}

static  void method_23381( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<reco::PattRecoTree<double,reco::PattRecoPeak<double> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<reco::PattRecoTree<double,reco::PattRecoPeak<double> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4751( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::PattRecoTree<double,reco::PattRecoPeak<double> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::PattRecoTree<double,reco::PattRecoPeak<double> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::PattRecoTree<double,reco::PattRecoPeak<double> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::PattRecoTree<double,reco::PattRecoPeak<double> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::PattRecoTree<double,reco::PattRecoPeak<double> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<reco::PattRecoTree<double, reco::PattRecoPeak<double> > > -------------------------------
void __edm__Wrapper_reco__PattRecoTree_double_reco__PattRecoPeak_double_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_reco__PattRecoTree_double_reco__PattRecoPeak_double_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_reco__PattRecoTree_double_reco__PattRecoPeak_double_s_s__datamem_bld(&__edm__Wrapper_reco__PattRecoTree_double_reco__PattRecoPeak_double_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_reco__PattRecoTree_double_reco__PattRecoPeak_double_s_s__funcmem_bld(&__edm__Wrapper_reco__PattRecoTree_double_reco__PattRecoPeak_double_s_s__db_funcmem);
void __edm__Wrapper_reco__PattRecoTree_double_reco__PattRecoPeak_double_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<reco::PattRecoTree<double,reco::PattRecoPeak<double> > >"), typeid(::edm::Wrapper<reco::PattRecoTree<double,reco::PattRecoPeak<double> > >), sizeof(::edm::Wrapper<reco::PattRecoTree<double,reco::PattRecoPeak<double> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_7832, Reflex::Literal("edm::Wrapper<reco::PattRecoTree<double,reco::PattRecoPeak<double> > >::value_type"))
  .AddTypedef(type_7832, Reflex::Literal("edm::Wrapper<reco::PattRecoTree<double,reco::PattRecoPeak<double> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_23367, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2788), Reflex::Literal("Wrapper"), constructor_23368, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_23369, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39388), Reflex::Literal("Wrapper"), constructor_23374, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4751, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_reco__PattRecoTree_double_reco__PattRecoPeak_double_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_reco__PattRecoTree_double_reco__PattRecoPeak_double_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<reco::PattRecoTree<double, reco::PattRecoPeak<double> > > -------------------
void __edm__Wrapper_reco__PattRecoTree_double_reco__PattRecoPeak_double_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1566, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_reco__PattRecoTree_double_reco__PattRecoPeak_double_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_7832, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_reco__PattRecoTree_double_reco__PattRecoPeak_double_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<reco::PattRecoTree<double, reco::PattRecoPeak<double> > > -------------------
void __edm__Wrapper_reco__PattRecoTree_double_reco__PattRecoPeak_double_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39387), Reflex::Literal("product"), method_23370, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39387), Reflex::Literal("operator->"), operator_23371, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("productTypeInfo"), method_23372, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("typeInfo"), method_23373, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39389), Reflex::Literal("getInterface"), method_23375, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20599, type_20679, type_38738), Reflex::Literal("fillView"), method_23376, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20732, type_358, type_11036), Reflex::Literal("setPtr"), method_23377, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20732, type_26144, type_20679), Reflex::Literal("fillPtrVector"), method_23378, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("dynamicTypeInfo"), method_23379, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isPresent"), method_23380, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("dynamicTypeInfo_"), method_23381, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class PattRecoTree<float,reco::PattRecoPeak<float> > -------------------------------
static void destructor_27791(void*, void * o, const std::vector<void*>&, void *) {
(((::reco::PattRecoTree<float,reco::PattRecoPeak<float> >*)o)->::reco::PattRecoTree<float,reco::PattRecoPeak<float> >::~PattRecoTree)();
}
static  void operator_27792( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::reco::PattRecoTree<float,reco::PattRecoPeak<float> >*)o)->operator=)(*(const ::reco::PattRecoTree<float,reco::PattRecoPeak<float> >*)arg[0]);
  else   (((::reco::PattRecoTree<float,reco::PattRecoPeak<float> >*)o)->operator=)(*(const ::reco::PattRecoTree<float,reco::PattRecoPeak<float> >*)arg[0]);
}

static void constructor_27793( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::PattRecoTree<float,reco::PattRecoPeak<float> >(*(const ::reco::PattRecoTree<float,reco::PattRecoPeak<float> >*)arg[0]);
  else ::new(mem) ::reco::PattRecoTree<float,reco::PattRecoPeak<float> >(*(const ::reco::PattRecoTree<float,reco::PattRecoPeak<float> >*)arg[0]);
}

static void constructor_27794( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::PattRecoTree<float,reco::PattRecoPeak<float> >();
  else ::new(mem) ::reco::PattRecoTree<float,reco::PattRecoPeak<float> >();
}

static  void method_27795( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::reco::PattRecoTree<float,reco::PattRecoPeak<float> >*)o)->isSparse)());
  else   (((const ::reco::PattRecoTree<float,reco::PattRecoPeak<float> >*)o)->isSparse)();
}

static  void method_27796( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::reco::PattRecoTree<float,reco::PattRecoPeak<float> >*)o)->getNodes)();
  else   (((const ::reco::PattRecoTree<float,reco::PattRecoPeak<float> >*)o)->getNodes)();
}

static  void method_27797( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::reco::PattRecoTree<float,reco::PattRecoPeak<float> >*)o)->getScales)();
  else   (((const ::reco::PattRecoTree<float,reco::PattRecoPeak<float> >*)o)->getScales)();
}

static  void method_27798( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::reco::PattRecoTree<float,reco::PattRecoPeak<float> >*)o)->setSparse)(*(const bool*)arg[0]);
}

static  void method_27799( void*, void* o, const std::vector<void*>&, void*)
{
  (((::reco::PattRecoTree<float,reco::PattRecoPeak<float> >*)o)->clear)();
}

static  void method_27800( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::reco::PattRecoTree<float,reco::PattRecoPeak<float> >*)o)->reserveNodes)(*(const unsigned int*)arg[0]);
}

static  void method_27801( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::reco::PattRecoTree<float,reco::PattRecoPeak<float> >*)o)->reserveScales)(*(const unsigned int*)arg[0]);
}

static  void method_27802( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::reco::PattRecoTree<float,reco::PattRecoPeak<float> >*)o)->addNode)(*(const ::reco::PattRecoNode<reco::PattRecoPeak<float> >*)arg[0]);
}

static  void method_27803( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::reco::PattRecoTree<float,reco::PattRecoPeak<float> >*)o)->addScale)(*(const double*)arg[0]);
}

static void method_newdel_7833( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::reco::PattRecoTree<float,reco::PattRecoPeak<float> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::reco::PattRecoTree<float,reco::PattRecoPeak<float> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::reco::PattRecoTree<float,reco::PattRecoPeak<float> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::reco::PattRecoTree<float,reco::PattRecoPeak<float> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::reco::PattRecoTree<float,reco::PattRecoPeak<float> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class PattRecoTree<float,reco::PattRecoPeak<float> > -------------------------------
void __reco__PattRecoTree_float_reco__PattRecoPeak_float_s__db_datamem(Reflex::Class*);
void __reco__PattRecoTree_float_reco__PattRecoPeak_float_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __reco__PattRecoTree_float_reco__PattRecoPeak_float_s__datamem_bld(&__reco__PattRecoTree_float_reco__PattRecoPeak_float_s__db_datamem);
Reflex::GenreflexMemberBuilder __reco__PattRecoTree_float_reco__PattRecoPeak_float_s__funcmem_bld(&__reco__PattRecoTree_float_reco__PattRecoPeak_float_s__db_funcmem);
void __reco__PattRecoTree_float_reco__PattRecoPeak_float_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("reco::PattRecoTree<float,reco::PattRecoPeak<float> >"), typeid(::reco::PattRecoTree<float,reco::PattRecoPeak<float> >), sizeof(::reco::PattRecoTree<float,reco::PattRecoPeak<float> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_7892, Reflex::Literal("reco::PattRecoTree<float,reco::PattRecoPeak<float> >::Node"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PattRecoTree"), destructor_27791, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_40765, type_40766), Reflex::Literal("operator="), operator_27792, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_40766), Reflex::Literal("PattRecoTree"), constructor_27793, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PattRecoTree"), constructor_27794, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_7833, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__reco__PattRecoTree_float_reco__PattRecoPeak_float_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__reco__PattRecoTree_float_reco__PattRecoPeak_float_s__funcmem_bld);
}

//------Delayed data member builder for class PattRecoTree<float,reco::PattRecoPeak<float> > -------------------
void __reco__PattRecoTree_float_reco__PattRecoPeak_float_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2992, Reflex::Literal("nodes_"), OffsetOf(__shadow__::__reco__PattRecoTree_float_reco__PattRecoPeak_float_s_, nodes_), ::Reflex::PRIVATE)
  .AddDataMember(type_2991, Reflex::Literal("scales_"), OffsetOf(__shadow__::__reco__PattRecoTree_float_reco__PattRecoPeak_float_s_, scales_), ::Reflex::PRIVATE)
  .AddDataMember(type_1566, Reflex::Literal("sparse_"), OffsetOf(__shadow__::__reco__PattRecoTree_float_reco__PattRecoPeak_float_s_, sparse_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class PattRecoTree<float,reco::PattRecoPeak<float> > -------------------
void __reco__PattRecoTree_float_reco__PattRecoPeak_float_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isSparse"), method_27795, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35979), Reflex::Literal("getNodes"), method_27796, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35976), Reflex::Literal("getScales"), method_27797, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_1566c), Reflex::Literal("setSparse"), method_27798, 0, "b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694), Reflex::Literal("clear"), method_27799, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_366c), Reflex::Literal("reserveNodes"), method_27800, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_366c), Reflex::Literal("reserveScales"), method_27801, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_14083), Reflex::Literal("addNode"), method_27802, 0, "node", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_101c), Reflex::Literal("addScale"), method_27803, 0, "s", ::Reflex::PUBLIC);
}
//------Stub functions for class Wrapper<reco::PattRecoTree<float, reco::PattRecoPeak<float> > > -------------------------------
static void constructor_23388( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<reco::PattRecoTree<float,reco::PattRecoPeak<float> > >();
  else ::new(mem) ::edm::Wrapper<reco::PattRecoTree<float,reco::PattRecoPeak<float> > >();
}

static void constructor_23389( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<reco::PattRecoTree<float,reco::PattRecoPeak<float> > >(*(::std::auto_ptr<reco::PattRecoTree<float,reco::PattRecoPeak<float> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<reco::PattRecoTree<float,reco::PattRecoPeak<float> > >(*(::std::auto_ptr<reco::PattRecoTree<float,reco::PattRecoPeak<float> > >*)arg[0]);
}

static void destructor_23390(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<reco::PattRecoTree<float,reco::PattRecoPeak<float> > >*)o)->::edm::Wrapper<reco::PattRecoTree<float,reco::PattRecoPeak<float> > >::~Wrapper)();
}
static  void method_23391( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<reco::PattRecoTree<float,reco::PattRecoPeak<float> > >*)o)->product)());
  else   (((const ::edm::Wrapper<reco::PattRecoTree<float,reco::PattRecoPeak<float> > >*)o)->product)();
}

static  void operator_23392( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<reco::PattRecoTree<float,reco::PattRecoPeak<float> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<reco::PattRecoTree<float,reco::PattRecoPeak<float> > >*)o)->operator->)();
}

static  void method_23393( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<reco::PattRecoTree<float,reco::PattRecoPeak<float> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<reco::PattRecoTree<float,reco::PattRecoPeak<float> > >*)o)->productTypeInfo)();
}

static  void method_23394( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<reco::PattRecoTree<float,reco::PattRecoPeak<float> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<reco::PattRecoTree<float,reco::PattRecoPeak<float> > >*)o)->typeInfo)();
}

static void constructor_23395( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<reco::PattRecoTree<float,reco::PattRecoPeak<float> > >((::reco::PattRecoTree<float,reco::PattRecoPeak<float> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<reco::PattRecoTree<float,reco::PattRecoPeak<float> > >((::reco::PattRecoTree<float,reco::PattRecoPeak<float> >*)arg[0]);
}

static  void method_23396( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<reco::PattRecoTree<float,reco::PattRecoPeak<float> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<reco::PattRecoTree<float,reco::PattRecoPeak<float> > >*)o)->getInterface)();
}

static  void method_23397( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<reco::PattRecoTree<float,reco::PattRecoPeak<float> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_23398( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<reco::PattRecoTree<float,reco::PattRecoPeak<float> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_23399( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<reco::PattRecoTree<float,reco::PattRecoPeak<float> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_23400( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<reco::PattRecoTree<float,reco::PattRecoPeak<float> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<reco::PattRecoTree<float,reco::PattRecoPeak<float> > >*)o)->dynamicTypeInfo)();
}

static  void method_23401( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<reco::PattRecoTree<float,reco::PattRecoPeak<float> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<reco::PattRecoTree<float,reco::PattRecoPeak<float> > >*)o)->isPresent)();
}

static  void method_23402( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<reco::PattRecoTree<float,reco::PattRecoPeak<float> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<reco::PattRecoTree<float,reco::PattRecoPeak<float> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4752( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::PattRecoTree<float,reco::PattRecoPeak<float> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::PattRecoTree<float,reco::PattRecoPeak<float> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::PattRecoTree<float,reco::PattRecoPeak<float> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::PattRecoTree<float,reco::PattRecoPeak<float> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::PattRecoTree<float,reco::PattRecoPeak<float> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<reco::PattRecoTree<float, reco::PattRecoPeak<float> > > -------------------------------
void __edm__Wrapper_reco__PattRecoTree_float_reco__PattRecoPeak_float_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_reco__PattRecoTree_float_reco__PattRecoPeak_float_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_reco__PattRecoTree_float_reco__PattRecoPeak_float_s_s__datamem_bld(&__edm__Wrapper_reco__PattRecoTree_float_reco__PattRecoPeak_float_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_reco__PattRecoTree_float_reco__PattRecoPeak_float_s_s__funcmem_bld(&__edm__Wrapper_reco__PattRecoTree_float_reco__PattRecoPeak_float_s_s__db_funcmem);
void __edm__Wrapper_reco__PattRecoTree_float_reco__PattRecoPeak_float_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<reco::PattRecoTree<float,reco::PattRecoPeak<float> > >"), typeid(::edm::Wrapper<reco::PattRecoTree<float,reco::PattRecoPeak<float> > >), sizeof(::edm::Wrapper<reco::PattRecoTree<float,reco::PattRecoPeak<float> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_7833, Reflex::Literal("edm::Wrapper<reco::PattRecoTree<float,reco::PattRecoPeak<float> > >::value_type"))
  .AddTypedef(type_7833, Reflex::Literal("edm::Wrapper<reco::PattRecoTree<float,reco::PattRecoPeak<float> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_23388, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2789), Reflex::Literal("Wrapper"), constructor_23389, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_23390, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39393), Reflex::Literal("Wrapper"), constructor_23395, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4752, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_reco__PattRecoTree_float_reco__PattRecoPeak_float_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_reco__PattRecoTree_float_reco__PattRecoPeak_float_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<reco::PattRecoTree<float, reco::PattRecoPeak<float> > > -------------------
void __edm__Wrapper_reco__PattRecoTree_float_reco__PattRecoPeak_float_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1566, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_reco__PattRecoTree_float_reco__PattRecoPeak_float_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_7833, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_reco__PattRecoTree_float_reco__PattRecoPeak_float_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<reco::PattRecoTree<float, reco::PattRecoPeak<float> > > -------------------
void __edm__Wrapper_reco__PattRecoTree_float_reco__PattRecoPeak_float_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39392), Reflex::Literal("product"), method_23391, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39392), Reflex::Literal("operator->"), operator_23392, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("productTypeInfo"), method_23393, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("typeInfo"), method_23394, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39394), Reflex::Literal("getInterface"), method_23396, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20599, type_20679, type_38738), Reflex::Literal("fillView"), method_23397, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20732, type_358, type_11036), Reflex::Literal("setPtr"), method_23398, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20732, type_26144, type_20679), Reflex::Literal("fillPtrVector"), method_23399, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("dynamicTypeInfo"), method_23400, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isPresent"), method_23401, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("dynamicTypeInfo_"), method_23402, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class RefProd<std::vector<reco::TrackExtrapolation, std::allocator<reco::TrackExtrapolation> > > -------------------------------
static  void operator_24443( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefProd<std::vector<reco::TrackExtrapolation> >*)o)->operator=)(*(const ::edm::RefProd<std::vector<reco::TrackExtrapolation> >*)arg[0]);
  else   (((::edm::RefProd<std::vector<reco::TrackExtrapolation> >*)o)->operator=)(*(const ::edm::RefProd<std::vector<reco::TrackExtrapolation> >*)arg[0]);
}

static void constructor_24444( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::TrackExtrapolation> >(*(const ::edm::RefProd<std::vector<reco::TrackExtrapolation> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<reco::TrackExtrapolation> >(*(const ::edm::RefProd<std::vector<reco::TrackExtrapolation> >*)arg[0]);
}

static void constructor_24445( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::TrackExtrapolation> >();
  else ::new(mem) ::edm::RefProd<std::vector<reco::TrackExtrapolation> >();
}

static void constructor_24446( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::TrackExtrapolation> >(*(const ::edm::Handle<std::vector<reco::TrackExtrapolation> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<reco::TrackExtrapolation> >(*(const ::edm::Handle<std::vector<reco::TrackExtrapolation> >*)arg[0]);
}

static void constructor_24447( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::TrackExtrapolation> >(*(const ::edm::OrphanHandle<std::vector<reco::TrackExtrapolation> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<reco::TrackExtrapolation> >(*(const ::edm::OrphanHandle<std::vector<reco::TrackExtrapolation> >*)arg[0]);
}

static void constructor_24448( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::TrackExtrapolation> >((const ::std::vector<reco::TrackExtrapolation>*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<reco::TrackExtrapolation> >((const ::std::vector<reco::TrackExtrapolation>*)arg[0]);
}

static void constructor_24449( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::TrackExtrapolation> >(*(const ::edm::TestHandle<std::vector<reco::TrackExtrapolation> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<reco::TrackExtrapolation> >(*(const ::edm::TestHandle<std::vector<reco::TrackExtrapolation> >*)arg[0]);
}

static void constructor_24450( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::TrackExtrapolation> >(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
  else ::new(mem) ::edm::RefProd<std::vector<reco::TrackExtrapolation> >(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
}

static void destructor_24451(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefProd<std::vector<reco::TrackExtrapolation> >*)o)->::edm::RefProd<std::vector<reco::TrackExtrapolation> >::~RefProd)();
}
static  void operator_24452( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<std::vector<reco::TrackExtrapolation> >*)o)->operator*)();
  else   (((const ::edm::RefProd<std::vector<reco::TrackExtrapolation> >*)o)->operator*)();
}

static  void operator_24453( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<reco::TrackExtrapolation> >*)o)->operator->)());
  else   (((const ::edm::RefProd<std::vector<reco::TrackExtrapolation> >*)o)->operator->)();
}

static  void method_24454( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<reco::TrackExtrapolation> >*)o)->get)());
  else   (((const ::edm::RefProd<std::vector<reco::TrackExtrapolation> >*)o)->get)();
}

static  void method_24455( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<reco::TrackExtrapolation> >*)o)->product)());
  else   (((const ::edm::RefProd<std::vector<reco::TrackExtrapolation> >*)o)->product)();
}

static  void method_24456( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<std::vector<reco::TrackExtrapolation> >*)o)->refCore)();
  else   (((const ::edm::RefProd<std::vector<reco::TrackExtrapolation> >*)o)->refCore)();
}

static  void method_24457( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::TrackExtrapolation> >*)o)->isNull)());
  else   (((const ::edm::RefProd<std::vector<reco::TrackExtrapolation> >*)o)->isNull)();
}

static  void method_24458( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::TrackExtrapolation> >*)o)->isNonnull)());
  else   (((const ::edm::RefProd<std::vector<reco::TrackExtrapolation> >*)o)->isNonnull)();
}

static  void operator_24459( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::TrackExtrapolation> >*)o)->operator!)());
  else   (((const ::edm::RefProd<std::vector<reco::TrackExtrapolation> >*)o)->operator!)();
}

static  void method_24460( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefProd<std::vector<reco::TrackExtrapolation> >*)o)->id)());
  else   (((const ::edm::RefProd<std::vector<reco::TrackExtrapolation> >*)o)->id)();
}

static  void method_24461( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<reco::TrackExtrapolation> >*)o)->productGetter)());
  else   (((const ::edm::RefProd<std::vector<reco::TrackExtrapolation> >*)o)->productGetter)();
}

static  void method_24462( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::TrackExtrapolation> >*)o)->hasCache)());
  else   (((const ::edm::RefProd<std::vector<reco::TrackExtrapolation> >*)o)->hasCache)();
}

static  void method_24463( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::TrackExtrapolation> >*)o)->hasProductCache)());
  else   (((const ::edm::RefProd<std::vector<reco::TrackExtrapolation> >*)o)->hasProductCache)();
}

static  void method_24464( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::TrackExtrapolation> >*)o)->isAvailable)());
  else   (((const ::edm::RefProd<std::vector<reco::TrackExtrapolation> >*)o)->isAvailable)();
}

static  void method_24465( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::TrackExtrapolation> >*)o)->isTransient)());
  else   (((const ::edm::RefProd<std::vector<reco::TrackExtrapolation> >*)o)->isTransient)();
}

static  void method_24466( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefProd<std::vector<reco::TrackExtrapolation> >*)o)->swap)(*(::edm::RefProd<std::vector<reco::TrackExtrapolation> >*)arg[0]);
}

static  void method_24467( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefProd<std::vector<reco::TrackExtrapolation> >*)o)->Class_Version)());
  else   (((::edm::RefProd<std::vector<reco::TrackExtrapolation> >*)o)->Class_Version)();
}

static void method_newdel_4956( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<reco::TrackExtrapolation> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<reco::TrackExtrapolation> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<reco::TrackExtrapolation> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<reco::TrackExtrapolation> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<reco::TrackExtrapolation> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefProd<std::vector<reco::TrackExtrapolation, std::allocator<reco::TrackExtrapolation> > > -------------------------------
void __edm__RefProd_std__vector_reco__TrackExtrapolation_s__db_datamem(Reflex::Class*);
void __edm__RefProd_std__vector_reco__TrackExtrapolation_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefProd_std__vector_reco__TrackExtrapolation_s__datamem_bld(&__edm__RefProd_std__vector_reco__TrackExtrapolation_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefProd_std__vector_reco__TrackExtrapolation_s__funcmem_bld(&__edm__RefProd_std__vector_reco__TrackExtrapolation_s__db_funcmem);
void __edm__RefProd_std__vector_reco__TrackExtrapolation_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefProd<std::vector<reco::TrackExtrapolation> >"), typeid(::edm::RefProd<std::vector<reco::TrackExtrapolation> >), sizeof(::edm::RefProd<std::vector<reco::TrackExtrapolation> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefProd<std::vector<reco::TrackExtrapolation> >::Class_Version())
  .AddTypedef(type_2993, Reflex::Literal("edm::RefProd<std::vector<reco::TrackExtrapolation> >::product_type"))
  .AddTypedef(type_2993, Reflex::Literal("edm::RefProd<std::vector<reco::TrackExtrapolation> >::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39845, type_39846), Reflex::Literal("operator="), operator_24443, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39846), Reflex::Literal("RefProd"), constructor_24444, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefProd"), constructor_24445, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39847), Reflex::Literal("RefProd"), constructor_24446, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39848), Reflex::Literal("RefProd"), constructor_24447, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39291), Reflex::Literal("RefProd"), constructor_24448, 0, "iProduct", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39849), Reflex::Literal("RefProd"), constructor_24449, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20599, type_20675), Reflex::Literal("RefProd"), constructor_24450, 0, "productID;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefProd"), destructor_24451, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4956, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefProd_std__vector_reco__TrackExtrapolation_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefProd_std__vector_reco__TrackExtrapolation_s__funcmem_bld);
}

//------Delayed data member builder for class RefProd<std::vector<reco::TrackExtrapolation, std::allocator<reco::TrackExtrapolation> > > -------------------
void __edm__RefProd_std__vector_reco__TrackExtrapolation_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4935, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__RefProd_std__vector_reco__TrackExtrapolation_s_, product_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefProd<std::vector<reco::TrackExtrapolation, std::allocator<reco::TrackExtrapolation> > > -------------------
void __edm__RefProd_std__vector_reco__TrackExtrapolation_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20846), Reflex::Literal("operator*"), operator_24452, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39291), Reflex::Literal("operator->"), operator_24453, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39291), Reflex::Literal("get"), method_24454, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39291), Reflex::Literal("product"), method_24455, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23940), Reflex::Literal("refCore"), method_24456, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isNull"), method_24457, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isNonnull"), method_24458, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("operator!"), operator_24459, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4933), Reflex::Literal("id"), method_24460, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20675), Reflex::Literal("productGetter"), method_24461, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("hasCache"), method_24462, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("hasProductCache"), method_24463, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isAvailable"), method_24464, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isTransient"), method_24465, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_39845), Reflex::Literal("swap"), method_24466, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_237), Reflex::Literal("Class_Version"), method_24467, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Wrapper<edm::RefProd<std::vector<reco::TrackExtrapolation, std::allocator<reco::TrackExtrapolation> > > > -------------------------------
static void constructor_23409( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefProd<std::vector<reco::TrackExtrapolation> > >();
  else ::new(mem) ::edm::Wrapper<edm::RefProd<std::vector<reco::TrackExtrapolation> > >();
}

static void constructor_23410( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefProd<std::vector<reco::TrackExtrapolation> > >(*(::std::auto_ptr<edm::RefProd<std::vector<reco::TrackExtrapolation> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::RefProd<std::vector<reco::TrackExtrapolation> > >(*(::std::auto_ptr<edm::RefProd<std::vector<reco::TrackExtrapolation> > >*)arg[0]);
}

static void destructor_23411(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<edm::RefProd<std::vector<reco::TrackExtrapolation> > >*)o)->::edm::Wrapper<edm::RefProd<std::vector<reco::TrackExtrapolation> > >::~Wrapper)();
}
static  void method_23412( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::RefProd<std::vector<reco::TrackExtrapolation> > >*)o)->product)());
  else   (((const ::edm::Wrapper<edm::RefProd<std::vector<reco::TrackExtrapolation> > >*)o)->product)();
}

static  void operator_23413( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::RefProd<std::vector<reco::TrackExtrapolation> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<edm::RefProd<std::vector<reco::TrackExtrapolation> > >*)o)->operator->)();
}

static  void method_23414( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::RefProd<std::vector<reco::TrackExtrapolation> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<edm::RefProd<std::vector<reco::TrackExtrapolation> > >*)o)->productTypeInfo)();
}

static  void method_23415( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::RefProd<std::vector<reco::TrackExtrapolation> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<edm::RefProd<std::vector<reco::TrackExtrapolation> > >*)o)->typeInfo)();
}

static void constructor_23416( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefProd<std::vector<reco::TrackExtrapolation> > >((::edm::RefProd<std::vector<reco::TrackExtrapolation> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::RefProd<std::vector<reco::TrackExtrapolation> > >((::edm::RefProd<std::vector<reco::TrackExtrapolation> >*)arg[0]);
}

static  void method_23417( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<edm::RefProd<std::vector<reco::TrackExtrapolation> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<edm::RefProd<std::vector<reco::TrackExtrapolation> > >*)o)->getInterface)();
}

static  void method_23418( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefProd<std::vector<reco::TrackExtrapolation> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_23419( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefProd<std::vector<reco::TrackExtrapolation> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_23420( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefProd<std::vector<reco::TrackExtrapolation> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_23421( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::RefProd<std::vector<reco::TrackExtrapolation> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<edm::RefProd<std::vector<reco::TrackExtrapolation> > >*)o)->dynamicTypeInfo)();
}

static  void method_23422( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<edm::RefProd<std::vector<reco::TrackExtrapolation> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<edm::RefProd<std::vector<reco::TrackExtrapolation> > >*)o)->isPresent)();
}

static  void method_23423( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::RefProd<std::vector<reco::TrackExtrapolation> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<edm::RefProd<std::vector<reco::TrackExtrapolation> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4753( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefProd<std::vector<reco::TrackExtrapolation> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefProd<std::vector<reco::TrackExtrapolation> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefProd<std::vector<reco::TrackExtrapolation> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefProd<std::vector<reco::TrackExtrapolation> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefProd<std::vector<reco::TrackExtrapolation> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<edm::RefProd<std::vector<reco::TrackExtrapolation, std::allocator<reco::TrackExtrapolation> > > > -------------------------------
void __edm__Wrapper_edm__RefProd_std__vector_reco__TrackExtrapolation_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_edm__RefProd_std__vector_reco__TrackExtrapolation_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__RefProd_std__vector_reco__TrackExtrapolation_s_s__datamem_bld(&__edm__Wrapper_edm__RefProd_std__vector_reco__TrackExtrapolation_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__RefProd_std__vector_reco__TrackExtrapolation_s_s__funcmem_bld(&__edm__Wrapper_edm__RefProd_std__vector_reco__TrackExtrapolation_s_s__db_funcmem);
void __edm__Wrapper_edm__RefProd_std__vector_reco__TrackExtrapolation_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<edm::RefProd<std::vector<reco::TrackExtrapolation> > >"), typeid(::edm::Wrapper<edm::RefProd<std::vector<reco::TrackExtrapolation> > >), sizeof(::edm::Wrapper<edm::RefProd<std::vector<reco::TrackExtrapolation> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_4956, Reflex::Literal("edm::Wrapper<edm::RefProd<std::vector<reco::TrackExtrapolation> > >::value_type"))
  .AddTypedef(type_4956, Reflex::Literal("edm::Wrapper<edm::RefProd<std::vector<reco::TrackExtrapolation> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_23409, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2790), Reflex::Literal("Wrapper"), constructor_23410, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_23411, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39398), Reflex::Literal("Wrapper"), constructor_23416, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4753, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_edm__RefProd_std__vector_reco__TrackExtrapolation_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_edm__RefProd_std__vector_reco__TrackExtrapolation_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<edm::RefProd<std::vector<reco::TrackExtrapolation, std::allocator<reco::TrackExtrapolation> > > > -------------------
void __edm__Wrapper_edm__RefProd_std__vector_reco__TrackExtrapolation_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1566, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_edm__RefProd_std__vector_reco__TrackExtrapolation_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_4956, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_edm__RefProd_std__vector_reco__TrackExtrapolation_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<edm::RefProd<std::vector<reco::TrackExtrapolation, std::allocator<reco::TrackExtrapolation> > > > -------------------
void __edm__Wrapper_edm__RefProd_std__vector_reco__TrackExtrapolation_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39397), Reflex::Literal("product"), method_23412, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39397), Reflex::Literal("operator->"), operator_23413, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("productTypeInfo"), method_23414, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("typeInfo"), method_23415, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39399), Reflex::Literal("getInterface"), method_23417, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20599, type_20679, type_38738), Reflex::Literal("fillView"), method_23418, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20732, type_358, type_11036), Reflex::Literal("setPtr"), method_23419, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20732, type_26144, type_20679), Reflex::Literal("fillPtrVector"), method_23420, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("dynamicTypeInfo"), method_23421, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isPresent"), method_23422, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("dynamicTypeInfo_"), method_23423, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<edm::RefVector<std::vector<reco::TrackExtrapolation, std::allocator<reco::TrackExtrapolation> >, reco::TrackExtrapolation, edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation, std::allocator<reco::TrackExtrapolation> >, reco::TrackExtrapolation> > > -------------------------------
static void constructor_23430( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >();
  else ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >();
}

static void constructor_23431( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >(*(::std::auto_ptr<edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >(*(::std::auto_ptr<edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >*)arg[0]);
}

static void destructor_23432(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >*)o)->::edm::Wrapper<edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >::~Wrapper)();
}
static  void method_23433( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >*)o)->product)());
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >*)o)->product)();
}

static  void operator_23434( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >*)o)->operator->)();
}

static  void method_23435( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >*)o)->productTypeInfo)();
}

static  void method_23436( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >*)o)->typeInfo)();
}

static void constructor_23437( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >((::edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >((::edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)arg[0]);
}

static  void method_23438( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >*)o)->getInterface)();
}

static  void method_23439( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_23440( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_23441( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_23442( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >*)o)->dynamicTypeInfo)();
}

static  void method_23443( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >*)o)->isPresent)();
}

static  void method_23444( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4754( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<edm::RefVector<std::vector<reco::TrackExtrapolation, std::allocator<reco::TrackExtrapolation> >, reco::TrackExtrapolation, edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation, std::allocator<reco::TrackExtrapolation> >, reco::TrackExtrapolation> > > -------------------------------
void __edm__Wrapper_edm__RefVector_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_edm__refhelper__FindUsingAdvance_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_edm__RefVector_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_edm__refhelper__FindUsingAdvance_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__RefVector_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_edm__refhelper__FindUsingAdvance_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_s_s__datamem_bld(&__edm__Wrapper_edm__RefVector_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_edm__refhelper__FindUsingAdvance_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__RefVector_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_edm__refhelper__FindUsingAdvance_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_s_s__funcmem_bld(&__edm__Wrapper_edm__RefVector_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_edm__refhelper__FindUsingAdvance_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_s_s__db_funcmem);
void __edm__Wrapper_edm__RefVector_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_edm__refhelper__FindUsingAdvance_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >"), typeid(::edm::Wrapper<edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >), sizeof(::edm::Wrapper<edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_4681, Reflex::Literal("edm::Wrapper<edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >::value_type"))
  .AddTypedef(type_4681, Reflex::Literal("edm::Wrapper<edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_23430, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2791), Reflex::Literal("Wrapper"), constructor_23431, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_23432, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39403), Reflex::Literal("Wrapper"), constructor_23437, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4754, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_edm__RefVector_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_edm__refhelper__FindUsingAdvance_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_edm__RefVector_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_edm__refhelper__FindUsingAdvance_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<edm::RefVector<std::vector<reco::TrackExtrapolation, std::allocator<reco::TrackExtrapolation> >, reco::TrackExtrapolation, edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation, std::allocator<reco::TrackExtrapolation> >, reco::TrackExtrapolation> > > -------------------
void __edm__Wrapper_edm__RefVector_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_edm__refhelper__FindUsingAdvance_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1566, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_edm__RefVector_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_edm__refhelper__FindUsingAdvance_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_4681, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_edm__RefVector_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_edm__refhelper__FindUsingAdvance_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<edm::RefVector<std::vector<reco::TrackExtrapolation, std::allocator<reco::TrackExtrapolation> >, reco::TrackExtrapolation, edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation, std::allocator<reco::TrackExtrapolation> >, reco::TrackExtrapolation> > > -------------------
void __edm__Wrapper_edm__RefVector_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_edm__refhelper__FindUsingAdvance_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39402), Reflex::Literal("product"), method_23433, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39402), Reflex::Literal("operator->"), operator_23434, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("productTypeInfo"), method_23435, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("typeInfo"), method_23436, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39404), Reflex::Literal("getInterface"), method_23438, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20599, type_20679, type_38738), Reflex::Literal("fillView"), method_23439, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20732, type_358, type_11036), Reflex::Literal("setPtr"), method_23440, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20732, type_26144, type_20679), Reflex::Literal("fillPtrVector"), method_23441, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("dynamicTypeInfo"), method_23442, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isPresent"), method_23443, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("dynamicTypeInfo_"), method_23444, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Ref<std::vector<reco::TrackExtrapolation, std::allocator<reco::TrackExtrapolation> >,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation, std::allocator<reco::TrackExtrapolation> >, reco::TrackExtrapolation> > -------------------------------
static  void operator_25454( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->operator=)(*(const ::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)arg[0]);
  else   (((::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->operator=)(*(const ::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)arg[0]);
}

static void constructor_25455( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >(*(const ::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)arg[0]);
  else ::new(mem) ::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >(*(const ::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)arg[0]);
}

static void constructor_25456( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >();
  else ::new(mem) ::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >();
}

static void constructor_25457( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >(*(const ::edm::Handle<std::vector<reco::TrackExtrapolation> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >(*(const ::edm::Handle<std::vector<reco::TrackExtrapolation> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >(*(const ::edm::Handle<std::vector<reco::TrackExtrapolation> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >(*(const ::edm::Handle<std::vector<reco::TrackExtrapolation> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_25458( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >(*(const ::edm::OrphanHandle<std::vector<reco::TrackExtrapolation> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >(*(const ::edm::OrphanHandle<std::vector<reco::TrackExtrapolation> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >(*(const ::edm::OrphanHandle<std::vector<reco::TrackExtrapolation> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >(*(const ::edm::OrphanHandle<std::vector<reco::TrackExtrapolation> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_25459( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >(*(const ::edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >(*(const ::edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >(*(const ::edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >(*(const ::edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_25460( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >((const ::std::vector<reco::TrackExtrapolation>*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >((const ::std::vector<reco::TrackExtrapolation>*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >((const ::std::vector<reco::TrackExtrapolation>*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >((const ::std::vector<reco::TrackExtrapolation>*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_25461( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >(*(const ::edm::TestHandle<std::vector<reco::TrackExtrapolation> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >(*(const ::edm::TestHandle<std::vector<reco::TrackExtrapolation> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >(*(const ::edm::TestHandle<std::vector<reco::TrackExtrapolation> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >(*(const ::edm::TestHandle<std::vector<reco::TrackExtrapolation> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_25462( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >(*(const ::edm::ProductID*)arg[0],
      *(unsigned int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >(*(const ::edm::ProductID*)arg[0],
      *(unsigned int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
}

static void constructor_25463( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >(*(const ::edm::ProductID*)arg[0],
      (const ::reco::TrackExtrapolation*)arg[1],
      *(unsigned int*)arg[2],
      (const ::std::vector<reco::TrackExtrapolation>*)arg[3]);
  else ::new(mem) ::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >(*(const ::edm::ProductID*)arg[0],
      (const ::reco::TrackExtrapolation*)arg[1],
      *(unsigned int*)arg[2],
      (const ::std::vector<reco::TrackExtrapolation>*)arg[3]);
}

static void constructor_25464( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_25465( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >(*(const ::edm::RefProd<std::vector<reco::TrackExtrapolation> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >(*(const ::edm::RefProd<std::vector<reco::TrackExtrapolation> >*)arg[0],
      *(unsigned int*)arg[1]);
}

static void destructor_25466(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >::~Ref)();
}
static  void operator_25467( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->operator*)();
  else   (((const ::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->operator*)();
}

static  void operator_25468( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->operator->)());
  else   (((const ::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->operator->)();
}

static  void method_25469( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->get)());
  else   (((const ::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->get)();
}

static  void method_25470( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->isNull)());
  else   (((const ::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->isNull)();
}

static  void method_25471( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->isNonnull)());
  else   (((const ::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->isNonnull)();
}

static  void operator_25472( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->operator!)());
  else   (((const ::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->operator!)();
}

static  void method_25473( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->id)());
  else   (((const ::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->id)();
}

static  void method_25474( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->productGetter)());
  else   (((const ::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->productGetter)();
}

static  void method_25475( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->product)());
  else   (((const ::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->product)();
}

static  void method_25476( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->key)());
  else   (((const ::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->key)();
}

static  void method_25477( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->index)());
  else   (((const ::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->index)();
}

static  void method_25478( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->hasProductCache)());
  else   (((const ::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->hasProductCache)();
}

static  void method_25479( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->isAvailable)());
  else   (((const ::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->isAvailable)();
}

static  void method_25480( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->isTransient)());
  else   (((const ::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->isTransient)();
}

static  void method_25481( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->refCore)();
  else   (((const ::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->refCore)();
}

static  void method_25482( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->Class_Version)());
  else   (((::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)o)->Class_Version)();
}

static void constructor_25483( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >(*(const ::edm::RefCore*)arg[0],
      *(const unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >(*(const ::edm::RefCore*)arg[0],
      *(const unsigned int*)arg[1]);
}

static void method_newdel_5022( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Ref<std::vector<reco::TrackExtrapolation, std::allocator<reco::TrackExtrapolation> >,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation, std::allocator<reco::TrackExtrapolation> >, reco::TrackExtrapolation> > -------------------------------
void __edm__Ref_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_edm__refhelper__FindUsingAdvance_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_s__db_datamem(Reflex::Class*);
void __edm__Ref_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_edm__refhelper__FindUsingAdvance_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Ref_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_edm__refhelper__FindUsingAdvance_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_s__datamem_bld(&__edm__Ref_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_edm__refhelper__FindUsingAdvance_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Ref_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_edm__refhelper__FindUsingAdvance_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_s__funcmem_bld(&__edm__Ref_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_edm__refhelper__FindUsingAdvance_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_s__db_funcmem);
void __edm__Ref_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_edm__refhelper__FindUsingAdvance_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >"), typeid(::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >), sizeof(::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >::Class_Version())
  .AddTypedef(type_7787, Reflex::Literal("edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >::T"))
  .AddTypedef(type_20841, Reflex::Literal("edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >::F"))
  .AddTypedef(type_22257, Reflex::Literal("edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >::VF"))
  .AddTypedef(type_22256, Reflex::Literal("edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >::VBF"))
  .AddTypedef(type_2993, Reflex::Literal("edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >::product_type"))
  .AddTypedef(type_7787, Reflex::Literal("edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >::value_type"))
  .AddTypedef(type_7787c, Reflex::Literal("edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >::element_type"))
  .AddTypedef(type_20841, Reflex::Literal("edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >::finder_type"))
  .AddTypedef(type_366, Reflex::Literal("edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >::argument_type"))
  .AddTypedef(type_366, Reflex::Literal("edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >::key_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39930, type_39290), Reflex::Literal("operator="), operator_25454, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39290), Reflex::Literal("Ref"), constructor_25455, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Ref"), constructor_25456, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39847, type_366, type_1566), Reflex::Literal("Ref"), constructor_25457, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39848, type_366, type_1566), Reflex::Literal("Ref"), constructor_25458, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39289, type_366, type_1566), Reflex::Literal("Ref"), constructor_25459, 0, "refvector;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39291, type_366, type_1566), Reflex::Literal("Ref"), constructor_25460, 0, "iProduct;iItemKey;iSetNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39849, type_366, type_1566), Reflex::Literal("Ref"), constructor_25461, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20599, type_366, type_20675), Reflex::Literal("Ref"), constructor_25462, 0, "productID;itemKey;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20599, type_14144, type_366, type_39291), Reflex::Literal("Ref"), constructor_25463, 0, "iProductID;;iItemKey;iProduct", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20599), Reflex::Literal("Ref"), constructor_25464, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39846, type_366), Reflex::Literal("Ref"), constructor_25465, 0, "refProd;itemKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Ref"), destructor_25466, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23940, type_10985), Reflex::Literal("Ref"), constructor_25483, 0, "iRefCore;iKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_5022, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Ref_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_edm__refhelper__FindUsingAdvance_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Ref_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_edm__refhelper__FindUsingAdvance_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_s__funcmem_bld);
}

//------Delayed data member builder for class Ref<std::vector<reco::TrackExtrapolation, std::allocator<reco::TrackExtrapolation> >,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation, std::allocator<reco::TrackExtrapolation> >, reco::TrackExtrapolation> > -------------------
void __edm__Ref_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_edm__refhelper__FindUsingAdvance_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4624, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__Ref_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_edm__refhelper__FindUsingAdvance_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_s_, product_), ::Reflex::PRIVATE | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class Ref<std::vector<reco::TrackExtrapolation, std::allocator<reco::TrackExtrapolation> >,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation, std::allocator<reco::TrackExtrapolation> >, reco::TrackExtrapolation> > -------------------
void __edm__Ref_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_edm__refhelper__FindUsingAdvance_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14148), Reflex::Literal("operator*"), operator_25467, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14144), Reflex::Literal("operator->"), operator_25468, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14144), Reflex::Literal("get"), method_25469, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isNull"), method_25470, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isNonnull"), method_25471, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("operator!"), operator_25472, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4933), Reflex::Literal("id"), method_25473, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20675), Reflex::Literal("productGetter"), method_25474, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39291), Reflex::Literal("product"), method_25475, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_366), Reflex::Literal("key"), method_25476, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_366), Reflex::Literal("index"), method_25477, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("hasProductCache"), method_25478, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isAvailable"), method_25479, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isTransient"), method_25480, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23940), Reflex::Literal("refCore"), method_25481, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_237), Reflex::Literal("Class_Version"), method_25482, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Wrapper<edm::Ref<std::vector<reco::TrackExtrapolation, std::allocator<reco::TrackExtrapolation> >, reco::TrackExtrapolation, edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation, std::allocator<reco::TrackExtrapolation> >, reco::TrackExtrapolation> > > -------------------------------
static void constructor_23451( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >();
  else ::new(mem) ::edm::Wrapper<edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >();
}

static void constructor_23452( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >(*(::std::auto_ptr<edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >(*(::std::auto_ptr<edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >*)arg[0]);
}

static void destructor_23453(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >*)o)->::edm::Wrapper<edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >::~Wrapper)();
}
static  void method_23454( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >*)o)->product)());
  else   (((const ::edm::Wrapper<edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >*)o)->product)();
}

static  void operator_23455( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >*)o)->operator->)();
}

static  void method_23456( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >*)o)->productTypeInfo)();
}

static  void method_23457( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >*)o)->typeInfo)();
}

static void constructor_23458( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >((::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >((::edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> >*)arg[0]);
}

static  void method_23459( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >*)o)->getInterface)();
}

static  void method_23460( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_23461( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_23462( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_23463( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >*)o)->dynamicTypeInfo)();
}

static  void method_23464( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >*)o)->isPresent)();
}

static  void method_23465( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4755( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<edm::Ref<std::vector<reco::TrackExtrapolation, std::allocator<reco::TrackExtrapolation> >, reco::TrackExtrapolation, edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation, std::allocator<reco::TrackExtrapolation> >, reco::TrackExtrapolation> > > -------------------------------
void __edm__Wrapper_edm__Ref_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_edm__refhelper__FindUsingAdvance_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_edm__Ref_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_edm__refhelper__FindUsingAdvance_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__Ref_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_edm__refhelper__FindUsingAdvance_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_s_s__datamem_bld(&__edm__Wrapper_edm__Ref_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_edm__refhelper__FindUsingAdvance_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__Ref_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_edm__refhelper__FindUsingAdvance_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_s_s__funcmem_bld(&__edm__Wrapper_edm__Ref_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_edm__refhelper__FindUsingAdvance_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_s_s__db_funcmem);
void __edm__Wrapper_edm__Ref_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_edm__refhelper__FindUsingAdvance_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >"), typeid(::edm::Wrapper<edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >), sizeof(::edm::Wrapper<edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_5022, Reflex::Literal("edm::Wrapper<edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >::value_type"))
  .AddTypedef(type_5022, Reflex::Literal("edm::Wrapper<edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_23451, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2792), Reflex::Literal("Wrapper"), constructor_23452, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_23453, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39408), Reflex::Literal("Wrapper"), constructor_23458, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4755, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_edm__Ref_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_edm__refhelper__FindUsingAdvance_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_edm__Ref_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_edm__refhelper__FindUsingAdvance_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<edm::Ref<std::vector<reco::TrackExtrapolation, std::allocator<reco::TrackExtrapolation> >, reco::TrackExtrapolation, edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation, std::allocator<reco::TrackExtrapolation> >, reco::TrackExtrapolation> > > -------------------
void __edm__Wrapper_edm__Ref_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_edm__refhelper__FindUsingAdvance_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1566, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_edm__Ref_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_edm__refhelper__FindUsingAdvance_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_5022, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_edm__Ref_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_edm__refhelper__FindUsingAdvance_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<edm::Ref<std::vector<reco::TrackExtrapolation, std::allocator<reco::TrackExtrapolation> >, reco::TrackExtrapolation, edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation, std::allocator<reco::TrackExtrapolation> >, reco::TrackExtrapolation> > > -------------------
void __edm__Wrapper_edm__Ref_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_edm__refhelper__FindUsingAdvance_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39407), Reflex::Literal("product"), method_23454, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39407), Reflex::Literal("operator->"), operator_23455, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("productTypeInfo"), method_23456, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("typeInfo"), method_23457, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39409), Reflex::Literal("getInterface"), method_23459, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20599, type_20679, type_38738), Reflex::Literal("fillView"), method_23460, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20732, type_358, type_11036), Reflex::Literal("setPtr"), method_23461, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20732, type_26144, type_20679), Reflex::Literal("fillPtrVector"), method_23462, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("dynamicTypeInfo"), method_23463, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isPresent"), method_23464, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("dynamicTypeInfo_"), method_23465, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<reco::TrackExtrapolation, std::allocator<reco::TrackExtrapolation> > > -------------------------------
static void constructor_23472( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<reco::TrackExtrapolation> >();
  else ::new(mem) ::edm::Wrapper<std::vector<reco::TrackExtrapolation> >();
}

static void constructor_23473( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<reco::TrackExtrapolation> >(*(::std::auto_ptr<std::vector<reco::TrackExtrapolation> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<reco::TrackExtrapolation> >(*(::std::auto_ptr<std::vector<reco::TrackExtrapolation> >*)arg[0]);
}

static void destructor_23474(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<reco::TrackExtrapolation> >*)o)->::edm::Wrapper<std::vector<reco::TrackExtrapolation> >::~Wrapper)();
}
static  void method_23475( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<reco::TrackExtrapolation> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<reco::TrackExtrapolation> >*)o)->product)();
}

static  void operator_23476( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<reco::TrackExtrapolation> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<reco::TrackExtrapolation> >*)o)->operator->)();
}

static  void method_23477( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<reco::TrackExtrapolation> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<reco::TrackExtrapolation> >*)o)->productTypeInfo)();
}

static  void method_23478( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<reco::TrackExtrapolation> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<reco::TrackExtrapolation> >*)o)->typeInfo)();
}

static void constructor_23479( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<reco::TrackExtrapolation> >((::std::vector<reco::TrackExtrapolation>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<reco::TrackExtrapolation> >((::std::vector<reco::TrackExtrapolation>*)arg[0]);
}

static  void method_23480( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<reco::TrackExtrapolation> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<reco::TrackExtrapolation> >*)o)->getInterface)();
}

static  void method_23481( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<reco::TrackExtrapolation> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_23482( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<reco::TrackExtrapolation> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_23483( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<reco::TrackExtrapolation> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_23484( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<reco::TrackExtrapolation> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<reco::TrackExtrapolation> >*)o)->dynamicTypeInfo)();
}

static  void method_23485( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<reco::TrackExtrapolation> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<reco::TrackExtrapolation> >*)o)->isPresent)();
}

static  void method_23486( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<reco::TrackExtrapolation> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<reco::TrackExtrapolation> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4756( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::TrackExtrapolation> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::TrackExtrapolation> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::TrackExtrapolation> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::TrackExtrapolation> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::TrackExtrapolation> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<reco::TrackExtrapolation, std::allocator<reco::TrackExtrapolation> > > -------------------------------
void __edm__Wrapper_std__vector_reco__TrackExtrapolation_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_reco__TrackExtrapolation_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_reco__TrackExtrapolation_s__datamem_bld(&__edm__Wrapper_std__vector_reco__TrackExtrapolation_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_reco__TrackExtrapolation_s__funcmem_bld(&__edm__Wrapper_std__vector_reco__TrackExtrapolation_s__db_funcmem);
void __edm__Wrapper_std__vector_reco__TrackExtrapolation_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<reco::TrackExtrapolation> >"), typeid(::edm::Wrapper<std::vector<reco::TrackExtrapolation> >), sizeof(::edm::Wrapper<std::vector<reco::TrackExtrapolation> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2993, Reflex::Literal("edm::Wrapper<std::vector<reco::TrackExtrapolation> >::value_type"))
  .AddTypedef(type_2993, Reflex::Literal("edm::Wrapper<std::vector<reco::TrackExtrapolation> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_23472, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2793), Reflex::Literal("Wrapper"), constructor_23473, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_23474, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39412), Reflex::Literal("Wrapper"), constructor_23479, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4756, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_reco__TrackExtrapolation_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_reco__TrackExtrapolation_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<reco::TrackExtrapolation, std::allocator<reco::TrackExtrapolation> > > -------------------
void __edm__Wrapper_std__vector_reco__TrackExtrapolation_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1566, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_reco__TrackExtrapolation_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2993, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_reco__TrackExtrapolation_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<reco::TrackExtrapolation, std::allocator<reco::TrackExtrapolation> > > -------------------
void __edm__Wrapper_std__vector_reco__TrackExtrapolation_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39291), Reflex::Literal("product"), method_23475, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39291), Reflex::Literal("operator->"), operator_23476, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("productTypeInfo"), method_23477, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("typeInfo"), method_23478, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39413), Reflex::Literal("getInterface"), method_23480, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20599, type_20679, type_38738), Reflex::Literal("fillView"), method_23481, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20732, type_358, type_11036), Reflex::Literal("setPtr"), method_23482, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20732, type_26144, type_20679), Reflex::Literal("fillPtrVector"), method_23483, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("dynamicTypeInfo"), method_23484, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isPresent"), method_23485, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("dynamicTypeInfo_"), method_23486, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<reco::TrackExtrapolation> -------------------------------
static void constructor_23493( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<reco::TrackExtrapolation>();
  else ::new(mem) ::edm::Wrapper<reco::TrackExtrapolation>();
}

static void constructor_23494( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<reco::TrackExtrapolation>(*(::std::auto_ptr<reco::TrackExtrapolation>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<reco::TrackExtrapolation>(*(::std::auto_ptr<reco::TrackExtrapolation>*)arg[0]);
}

static void destructor_23495(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<reco::TrackExtrapolation>*)o)->::edm::Wrapper<reco::TrackExtrapolation>::~Wrapper)();
}
static  void method_23496( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<reco::TrackExtrapolation>*)o)->product)());
  else   (((const ::edm::Wrapper<reco::TrackExtrapolation>*)o)->product)();
}

static  void operator_23497( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<reco::TrackExtrapolation>*)o)->operator->)());
  else   (((const ::edm::Wrapper<reco::TrackExtrapolation>*)o)->operator->)();
}

static  void method_23498( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<reco::TrackExtrapolation>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<reco::TrackExtrapolation>*)o)->productTypeInfo)();
}

static  void method_23499( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<reco::TrackExtrapolation>*)o)->typeInfo)();
  else   (((::edm::Wrapper<reco::TrackExtrapolation>*)o)->typeInfo)();
}

static void constructor_23500( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<reco::TrackExtrapolation>((::reco::TrackExtrapolation*)arg[0]);
  else ::new(mem) ::edm::Wrapper<reco::TrackExtrapolation>((::reco::TrackExtrapolation*)arg[0]);
}

static  void method_23501( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<reco::TrackExtrapolation>*)o)->getInterface)());
  else   (((::edm::Wrapper<reco::TrackExtrapolation>*)o)->getInterface)();
}

static  void method_23502( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<reco::TrackExtrapolation>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_23503( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<reco::TrackExtrapolation>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_23504( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<reco::TrackExtrapolation>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_23505( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<reco::TrackExtrapolation>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<reco::TrackExtrapolation>*)o)->dynamicTypeInfo)();
}

static  void method_23506( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<reco::TrackExtrapolation>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<reco::TrackExtrapolation>*)o)->isPresent)();
}

static  void method_23507( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<reco::TrackExtrapolation>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<reco::TrackExtrapolation>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4757( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::TrackExtrapolation> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::TrackExtrapolation> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::TrackExtrapolation> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::TrackExtrapolation> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::TrackExtrapolation> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<reco::TrackExtrapolation> -------------------------------
void __edm__Wrapper_reco__TrackExtrapolation__db_datamem(Reflex::Class*);
void __edm__Wrapper_reco__TrackExtrapolation__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_reco__TrackExtrapolation__datamem_bld(&__edm__Wrapper_reco__TrackExtrapolation__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_reco__TrackExtrapolation__funcmem_bld(&__edm__Wrapper_reco__TrackExtrapolation__db_funcmem);
void __edm__Wrapper_reco__TrackExtrapolation__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<reco::TrackExtrapolation>"), typeid(::edm::Wrapper<reco::TrackExtrapolation>), sizeof(::edm::Wrapper<reco::TrackExtrapolation>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_7787, Reflex::Literal("edm::Wrapper<reco::TrackExtrapolation>::value_type"))
  .AddTypedef(type_7787, Reflex::Literal("edm::Wrapper<reco::TrackExtrapolation>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_23493, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2794), Reflex::Literal("Wrapper"), constructor_23494, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_23495, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9457), Reflex::Literal("Wrapper"), constructor_23500, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4757, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_reco__TrackExtrapolation__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_reco__TrackExtrapolation__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<reco::TrackExtrapolation> -------------------
void __edm__Wrapper_reco__TrackExtrapolation__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1566, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_reco__TrackExtrapolation_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_7787, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_reco__TrackExtrapolation_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<reco::TrackExtrapolation> -------------------
void __edm__Wrapper_reco__TrackExtrapolation__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14144), Reflex::Literal("product"), method_23496, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14144), Reflex::Literal("operator->"), operator_23497, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("productTypeInfo"), method_23498, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("typeInfo"), method_23499, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39416), Reflex::Literal("getInterface"), method_23501, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20599, type_20679, type_38738), Reflex::Literal("fillView"), method_23502, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20732, type_358, type_11036), Reflex::Literal("setPtr"), method_23503, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20732, type_26144, type_20679), Reflex::Literal("fillPtrVector"), method_23504, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("dynamicTypeInfo"), method_23505, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isPresent"), method_23506, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("dynamicTypeInfo_"), method_23507, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class ValueMap<reco::CastorJetID> -------------------------------
static void destructor_25876(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::ValueMap<reco::CastorJetID>*)o)->::edm::ValueMap<reco::CastorJetID>::~ValueMap)();
}
static void constructor_25877( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::ValueMap<reco::CastorJetID>(*(const ::edm::ValueMap<reco::CastorJetID>*)arg[0]);
  else ::new(mem) ::edm::ValueMap<reco::CastorJetID>(*(const ::edm::ValueMap<reco::CastorJetID>*)arg[0]);
}

static void constructor_25878( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::ValueMap<reco::CastorJetID>();
  else ::new(mem) ::edm::ValueMap<reco::CastorJetID>();
}

static  void method_25879( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::ValueMap<reco::CastorJetID>*)o)->swap)(*(::edm::ValueMap<reco::CastorJetID>*)arg[0]);
}

static  void operator_25880( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::ValueMap<reco::CastorJetID>*)o)->operator=)(*(const ::edm::ValueMap<reco::CastorJetID>*)arg[0]);
  else   (((::edm::ValueMap<reco::CastorJetID>*)o)->operator=)(*(const ::edm::ValueMap<reco::CastorJetID>*)arg[0]);
}

static  void method_25881( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::ValueMap<reco::CastorJetID>*)o)->rawIndexOf)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]));
  else   (((const ::edm::ValueMap<reco::CastorJetID>*)o)->rawIndexOf)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]);
}

static  void method_25882( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::ValueMap<reco::CastorJetID>*)o)->get)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]);
  else   (((const ::edm::ValueMap<reco::CastorJetID>*)o)->get)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]);
}

static  void method_25883( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::ValueMap<reco::CastorJetID>*)o)->get)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]);
  else   (((::edm::ValueMap<reco::CastorJetID>*)o)->get)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]);
}

static  void operator_25884( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::ValueMap<reco::CastorJetID>*)o)->operator+=)(*(const ::edm::ValueMap<reco::CastorJetID>*)arg[0]);
  else   (((::edm::ValueMap<reco::CastorJetID>*)o)->operator+=)(*(const ::edm::ValueMap<reco::CastorJetID>*)arg[0]);
}

static  void method_25885( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::ValueMap<reco::CastorJetID>*)o)->contains)(*(::edm::ProductID*)arg[0]));
  else   (((const ::edm::ValueMap<reco::CastorJetID>*)o)->contains)(*(::edm::ProductID*)arg[0]);
}

static  void method_25886( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::ValueMap<reco::CastorJetID>*)o)->size)());
  else   (((const ::edm::ValueMap<reco::CastorJetID>*)o)->size)();
}

static  void method_25887( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::ValueMap<reco::CastorJetID>*)o)->idSize)());
  else   (((const ::edm::ValueMap<reco::CastorJetID>*)o)->idSize)();
}

static  void method_25888( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::ValueMap<reco::CastorJetID>*)o)->empty)());
  else   (((const ::edm::ValueMap<reco::CastorJetID>*)o)->empty)();
}

static  void method_25889( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::ValueMap<reco::CastorJetID>*)o)->clear)();
}

static  void method_25890( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ValueMap<reco::CastorJetID>::const_iterator)((((const ::edm::ValueMap<reco::CastorJetID>*)o)->begin)());
  else   (((const ::edm::ValueMap<reco::CastorJetID>*)o)->begin)();
}

static  void method_25891( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ValueMap<reco::CastorJetID>::const_iterator)((((const ::edm::ValueMap<reco::CastorJetID>*)o)->end)());
  else   (((const ::edm::ValueMap<reco::CastorJetID>*)o)->end)();
}

static  void method_25892( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::ValueMap<reco::CastorJetID>*)o)->ids)();
  else   (((const ::edm::ValueMap<reco::CastorJetID>*)o)->ids)();
}

static  void method_25893( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::ValueMap<reco::CastorJetID>*)o)->get)(*(::size_t*)arg[0]);
  else   (((const ::edm::ValueMap<reco::CastorJetID>*)o)->get)(*(::size_t*)arg[0]);
}

static  void method_25894( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::ValueMap<reco::CastorJetID>*)o)->Class_Version)());
  else   (((::edm::ValueMap<reco::CastorJetID>*)o)->Class_Version)();
}

static void method_newdel_5080( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::ValueMap<reco::CastorJetID> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::ValueMap<reco::CastorJetID> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::ValueMap<reco::CastorJetID> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::ValueMap<reco::CastorJetID> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::ValueMap<reco::CastorJetID> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class ValueMap<reco::CastorJetID> -------------------------------
void __edm__ValueMap_reco__CastorJetID__db_datamem(Reflex::Class*);
void __edm__ValueMap_reco__CastorJetID__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__ValueMap_reco__CastorJetID__datamem_bld(&__edm__ValueMap_reco__CastorJetID__db_datamem);
Reflex::GenreflexMemberBuilder __edm__ValueMap_reco__CastorJetID__funcmem_bld(&__edm__ValueMap_reco__CastorJetID__db_funcmem);
void __edm__ValueMap_reco__CastorJetID__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::ValueMap<reco::CastorJetID>"), typeid(::edm::ValueMap<reco::CastorJetID>), sizeof(::edm::ValueMap<reco::CastorJetID>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::ValueMap<reco::CastorJetID>::Class_Version())
  .AddTypedef(type_7846, Reflex::Literal("edm::ValueMap<reco::CastorJetID>::value_type"))
  .AddTypedef(type_2999, Reflex::Literal("edm::ValueMap<reco::CastorJetID>::container"))
  .AddTypedef(type_366, Reflex::Literal("edm::ValueMap<reco::CastorJetID>::offset"))
  .AddTypedef(type_2974, Reflex::Literal("edm::ValueMap<reco::CastorJetID>::id_offset_vector"))
  .AddTypedef(type_14540, Reflex::Literal("edm::ValueMap<reco::CastorJetID>::reference_type"))
  .AddTypedef(type_14542, Reflex::Literal("edm::ValueMap<reco::CastorJetID>::const_reference_type"))
  .AddTypedef(type_24318, Reflex::Literal("edm::ValueMap<reco::CastorJetID>::Filler"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~ValueMap"), destructor_25876, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_40018), Reflex::Literal("ValueMap"), constructor_25877, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("ValueMap"), constructor_25878, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_5080, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__ValueMap_reco__CastorJetID__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__ValueMap_reco__CastorJetID__funcmem_bld);
}

//------Delayed data member builder for class ValueMap<reco::CastorJetID> -------------------
void __edm__ValueMap_reco__CastorJetID__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2999, Reflex::Literal("values_"), OffsetOf(__shadow__::__edm__ValueMap_reco__CastorJetID_, values_), ::Reflex::PROTECTED)
  .AddDataMember(type_2974, Reflex::Literal("ids_"), OffsetOf(__shadow__::__edm__ValueMap_reco__CastorJetID_, ids_), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class ValueMap<reco::CastorJetID> -------------------
void __edm__ValueMap_reco__CastorJetID__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_40019), Reflex::Literal("swap"), method_25879, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_40019, type_40018), Reflex::Literal("operator="), operator_25880, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2121, type_4933, type_2121), Reflex::Literal("rawIndexOf"), method_25881, 0, "id;idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14542, type_4933, type_2121), Reflex::Literal("get"), method_25882, 0, "id;idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14540, type_4933, type_2121), Reflex::Literal("get"), method_25883, 0, "id;idx", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_40019, type_40018), Reflex::Literal("operator+="), operator_25884, 0, "o", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566, type_4933), Reflex::Literal("contains"), method_25885, 0, "id", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2121), Reflex::Literal("size"), method_25886, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2121), Reflex::Literal("idSize"), method_25887, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("empty"), method_25888, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694), Reflex::Literal("clear"), method_25889, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25874), Reflex::Literal("begin"), method_25890, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25874), Reflex::Literal("end"), method_25891, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35947), Reflex::Literal("ids"), method_25892, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14542, type_2121), Reflex::Literal("get"), method_25893, 0, "idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_237), Reflex::Literal("Class_Version"), method_25894, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Wrapper<edm::ValueMap<reco::CastorJetID> > -------------------------------
static void constructor_23556( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::ValueMap<reco::CastorJetID> >();
  else ::new(mem) ::edm::Wrapper<edm::ValueMap<reco::CastorJetID> >();
}

static void constructor_23557( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::ValueMap<reco::CastorJetID> >(*(::std::auto_ptr<edm::ValueMap<reco::CastorJetID> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::ValueMap<reco::CastorJetID> >(*(::std::auto_ptr<edm::ValueMap<reco::CastorJetID> >*)arg[0]);
}

static void destructor_23558(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<edm::ValueMap<reco::CastorJetID> >*)o)->::edm::Wrapper<edm::ValueMap<reco::CastorJetID> >::~Wrapper)();
}
static  void method_23559( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::ValueMap<reco::CastorJetID> >*)o)->product)());
  else   (((const ::edm::Wrapper<edm::ValueMap<reco::CastorJetID> >*)o)->product)();
}

static  void operator_23560( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::ValueMap<reco::CastorJetID> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<edm::ValueMap<reco::CastorJetID> >*)o)->operator->)();
}

static  void method_23561( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::ValueMap<reco::CastorJetID> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<edm::ValueMap<reco::CastorJetID> >*)o)->productTypeInfo)();
}

static  void method_23562( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::ValueMap<reco::CastorJetID> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<edm::ValueMap<reco::CastorJetID> >*)o)->typeInfo)();
}

static void constructor_23563( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::ValueMap<reco::CastorJetID> >((::edm::ValueMap<reco::CastorJetID>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::ValueMap<reco::CastorJetID> >((::edm::ValueMap<reco::CastorJetID>*)arg[0]);
}

static  void method_23564( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<edm::ValueMap<reco::CastorJetID> >*)o)->getInterface)());
  else   (((::edm::Wrapper<edm::ValueMap<reco::CastorJetID> >*)o)->getInterface)();
}

static  void method_23565( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::ValueMap<reco::CastorJetID> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_23566( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::ValueMap<reco::CastorJetID> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_23567( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::ValueMap<reco::CastorJetID> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_23568( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::ValueMap<reco::CastorJetID> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<edm::ValueMap<reco::CastorJetID> >*)o)->dynamicTypeInfo)();
}

static  void method_23569( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<edm::ValueMap<reco::CastorJetID> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<edm::ValueMap<reco::CastorJetID> >*)o)->isPresent)();
}

static  void method_23570( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::ValueMap<reco::CastorJetID> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<edm::ValueMap<reco::CastorJetID> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4760( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ValueMap<reco::CastorJetID> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ValueMap<reco::CastorJetID> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ValueMap<reco::CastorJetID> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ValueMap<reco::CastorJetID> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ValueMap<reco::CastorJetID> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<edm::ValueMap<reco::CastorJetID> > -------------------------------
void __edm__Wrapper_edm__ValueMap_reco__CastorJetID_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_edm__ValueMap_reco__CastorJetID_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__ValueMap_reco__CastorJetID_s__datamem_bld(&__edm__Wrapper_edm__ValueMap_reco__CastorJetID_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__ValueMap_reco__CastorJetID_s__funcmem_bld(&__edm__Wrapper_edm__ValueMap_reco__CastorJetID_s__db_funcmem);
void __edm__Wrapper_edm__ValueMap_reco__CastorJetID_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<edm::ValueMap<reco::CastorJetID> >"), typeid(::edm::Wrapper<edm::ValueMap<reco::CastorJetID> >), sizeof(::edm::Wrapper<edm::ValueMap<reco::CastorJetID> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_5080, Reflex::Literal("edm::Wrapper<edm::ValueMap<reco::CastorJetID> >::value_type"))
  .AddTypedef(type_5080, Reflex::Literal("edm::Wrapper<edm::ValueMap<reco::CastorJetID> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_23556, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2797), Reflex::Literal("Wrapper"), constructor_23557, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_23558, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39430), Reflex::Literal("Wrapper"), constructor_23563, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4760, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_edm__ValueMap_reco__CastorJetID_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_edm__ValueMap_reco__CastorJetID_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<edm::ValueMap<reco::CastorJetID> > -------------------
void __edm__Wrapper_edm__ValueMap_reco__CastorJetID_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1566, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_edm__ValueMap_reco__CastorJetID_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_5080, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_edm__ValueMap_reco__CastorJetID_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<edm::ValueMap<reco::CastorJetID> > -------------------
void __edm__Wrapper_edm__ValueMap_reco__CastorJetID_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39429), Reflex::Literal("product"), method_23559, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39429), Reflex::Literal("operator->"), operator_23560, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("productTypeInfo"), method_23561, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("typeInfo"), method_23562, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39431), Reflex::Literal("getInterface"), method_23564, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20599, type_20679, type_38738), Reflex::Literal("fillView"), method_23565, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20732, type_358, type_11036), Reflex::Literal("setPtr"), method_23566, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20732, type_26144, type_20679), Reflex::Literal("fillPtrVector"), method_23567, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("dynamicTypeInfo"), method_23568, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isPresent"), method_23569, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("dynamicTypeInfo_"), method_23570, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<reco::CastorJetID, std::allocator<reco::CastorJetID> > > -------------------------------
static void constructor_23598( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<reco::CastorJetID> >();
  else ::new(mem) ::edm::Wrapper<std::vector<reco::CastorJetID> >();
}

static void constructor_23599( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<reco::CastorJetID> >(*(::std::auto_ptr<std::vector<reco::CastorJetID> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<reco::CastorJetID> >(*(::std::auto_ptr<std::vector<reco::CastorJetID> >*)arg[0]);
}

static void destructor_23600(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<reco::CastorJetID> >*)o)->::edm::Wrapper<std::vector<reco::CastorJetID> >::~Wrapper)();
}
static  void method_23601( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<reco::CastorJetID> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<reco::CastorJetID> >*)o)->product)();
}

static  void operator_23602( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<reco::CastorJetID> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<reco::CastorJetID> >*)o)->operator->)();
}

static  void method_23603( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<reco::CastorJetID> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<reco::CastorJetID> >*)o)->productTypeInfo)();
}

static  void method_23604( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<reco::CastorJetID> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<reco::CastorJetID> >*)o)->typeInfo)();
}

static void constructor_23605( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<reco::CastorJetID> >((::std::vector<reco::CastorJetID>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<reco::CastorJetID> >((::std::vector<reco::CastorJetID>*)arg[0]);
}

static  void method_23606( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<reco::CastorJetID> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<reco::CastorJetID> >*)o)->getInterface)();
}

static  void method_23607( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<reco::CastorJetID> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_23608( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<reco::CastorJetID> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_23609( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<reco::CastorJetID> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_23610( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<reco::CastorJetID> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<reco::CastorJetID> >*)o)->dynamicTypeInfo)();
}

static  void method_23611( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<reco::CastorJetID> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<reco::CastorJetID> >*)o)->isPresent)();
}

static  void method_23612( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<reco::CastorJetID> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<reco::CastorJetID> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4762( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::CastorJetID> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::CastorJetID> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::CastorJetID> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::CastorJetID> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::CastorJetID> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<reco::CastorJetID, std::allocator<reco::CastorJetID> > > -------------------------------
void __edm__Wrapper_std__vector_reco__CastorJetID_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_reco__CastorJetID_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_reco__CastorJetID_s__datamem_bld(&__edm__Wrapper_std__vector_reco__CastorJetID_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_reco__CastorJetID_s__funcmem_bld(&__edm__Wrapper_std__vector_reco__CastorJetID_s__db_funcmem);
void __edm__Wrapper_std__vector_reco__CastorJetID_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<reco::CastorJetID> >"), typeid(::edm::Wrapper<std::vector<reco::CastorJetID> >), sizeof(::edm::Wrapper<std::vector<reco::CastorJetID> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2999, Reflex::Literal("edm::Wrapper<std::vector<reco::CastorJetID> >::value_type"))
  .AddTypedef(type_2999, Reflex::Literal("edm::Wrapper<std::vector<reco::CastorJetID> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_23598, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2799), Reflex::Literal("Wrapper"), constructor_23599, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_23600, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39439), Reflex::Literal("Wrapper"), constructor_23605, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4762, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_reco__CastorJetID_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_reco__CastorJetID_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<reco::CastorJetID, std::allocator<reco::CastorJetID> > > -------------------
void __edm__Wrapper_std__vector_reco__CastorJetID_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1566, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_reco__CastorJetID_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2999, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_reco__CastorJetID_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<reco::CastorJetID, std::allocator<reco::CastorJetID> > > -------------------
void __edm__Wrapper_std__vector_reco__CastorJetID_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39297), Reflex::Literal("product"), method_23601, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39297), Reflex::Literal("operator->"), operator_23602, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("productTypeInfo"), method_23603, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("typeInfo"), method_23604, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39440), Reflex::Literal("getInterface"), method_23606, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20599, type_20679, type_38738), Reflex::Literal("fillView"), method_23607, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20732, type_358, type_11036), Reflex::Literal("setPtr"), method_23608, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20732, type_26144, type_20679), Reflex::Literal("fillPtrVector"), method_23609, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("dynamicTypeInfo"), method_23610, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isPresent"), method_23611, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("dynamicTypeInfo_"), method_23612, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class ValueMap<reco::JetID> -------------------------------
static void destructor_25910(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::ValueMap<reco::JetID>*)o)->::edm::ValueMap<reco::JetID>::~ValueMap)();
}
static void constructor_25911( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::ValueMap<reco::JetID>(*(const ::edm::ValueMap<reco::JetID>*)arg[0]);
  else ::new(mem) ::edm::ValueMap<reco::JetID>(*(const ::edm::ValueMap<reco::JetID>*)arg[0]);
}

static void constructor_25912( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::ValueMap<reco::JetID>();
  else ::new(mem) ::edm::ValueMap<reco::JetID>();
}

static  void method_25913( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::ValueMap<reco::JetID>*)o)->swap)(*(::edm::ValueMap<reco::JetID>*)arg[0]);
}

static  void operator_25914( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::ValueMap<reco::JetID>*)o)->operator=)(*(const ::edm::ValueMap<reco::JetID>*)arg[0]);
  else   (((::edm::ValueMap<reco::JetID>*)o)->operator=)(*(const ::edm::ValueMap<reco::JetID>*)arg[0]);
}

static  void method_25915( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::ValueMap<reco::JetID>*)o)->rawIndexOf)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]));
  else   (((const ::edm::ValueMap<reco::JetID>*)o)->rawIndexOf)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]);
}

static  void method_25916( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::ValueMap<reco::JetID>*)o)->get)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]);
  else   (((const ::edm::ValueMap<reco::JetID>*)o)->get)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]);
}

static  void method_25917( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::ValueMap<reco::JetID>*)o)->get)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]);
  else   (((::edm::ValueMap<reco::JetID>*)o)->get)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]);
}

static  void operator_25918( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::ValueMap<reco::JetID>*)o)->operator+=)(*(const ::edm::ValueMap<reco::JetID>*)arg[0]);
  else   (((::edm::ValueMap<reco::JetID>*)o)->operator+=)(*(const ::edm::ValueMap<reco::JetID>*)arg[0]);
}

static  void method_25919( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::ValueMap<reco::JetID>*)o)->contains)(*(::edm::ProductID*)arg[0]));
  else   (((const ::edm::ValueMap<reco::JetID>*)o)->contains)(*(::edm::ProductID*)arg[0]);
}

static  void method_25920( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::ValueMap<reco::JetID>*)o)->size)());
  else   (((const ::edm::ValueMap<reco::JetID>*)o)->size)();
}

static  void method_25921( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::ValueMap<reco::JetID>*)o)->idSize)());
  else   (((const ::edm::ValueMap<reco::JetID>*)o)->idSize)();
}

static  void method_25922( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::ValueMap<reco::JetID>*)o)->empty)());
  else   (((const ::edm::ValueMap<reco::JetID>*)o)->empty)();
}

static  void method_25923( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::ValueMap<reco::JetID>*)o)->clear)();
}

static  void method_25924( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ValueMap<reco::JetID>::const_iterator)((((const ::edm::ValueMap<reco::JetID>*)o)->begin)());
  else   (((const ::edm::ValueMap<reco::JetID>*)o)->begin)();
}

static  void method_25925( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ValueMap<reco::JetID>::const_iterator)((((const ::edm::ValueMap<reco::JetID>*)o)->end)());
  else   (((const ::edm::ValueMap<reco::JetID>*)o)->end)();
}

static  void method_25926( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::ValueMap<reco::JetID>*)o)->ids)();
  else   (((const ::edm::ValueMap<reco::JetID>*)o)->ids)();
}

static  void method_25927( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::ValueMap<reco::JetID>*)o)->get)(*(::size_t*)arg[0]);
  else   (((const ::edm::ValueMap<reco::JetID>*)o)->get)(*(::size_t*)arg[0]);
}

static  void method_25928( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::ValueMap<reco::JetID>*)o)->Class_Version)());
  else   (((::edm::ValueMap<reco::JetID>*)o)->Class_Version)();
}

static void method_newdel_5081( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::ValueMap<reco::JetID> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::ValueMap<reco::JetID> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::ValueMap<reco::JetID> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::ValueMap<reco::JetID> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::ValueMap<reco::JetID> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class ValueMap<reco::JetID> -------------------------------
void __edm__ValueMap_reco__JetID__db_datamem(Reflex::Class*);
void __edm__ValueMap_reco__JetID__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__ValueMap_reco__JetID__datamem_bld(&__edm__ValueMap_reco__JetID__db_datamem);
Reflex::GenreflexMemberBuilder __edm__ValueMap_reco__JetID__funcmem_bld(&__edm__ValueMap_reco__JetID__db_funcmem);
void __edm__ValueMap_reco__JetID__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::ValueMap<reco::JetID>"), typeid(::edm::ValueMap<reco::JetID>), sizeof(::edm::ValueMap<reco::JetID>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::ValueMap<reco::JetID>::Class_Version())
  .AddTypedef(type_7841, Reflex::Literal("edm::ValueMap<reco::JetID>::value_type"))
  .AddTypedef(type_3000, Reflex::Literal("edm::ValueMap<reco::JetID>::container"))
  .AddTypedef(type_366, Reflex::Literal("edm::ValueMap<reco::JetID>::offset"))
  .AddTypedef(type_2974, Reflex::Literal("edm::ValueMap<reco::JetID>::id_offset_vector"))
  .AddTypedef(type_14605, Reflex::Literal("edm::ValueMap<reco::JetID>::reference_type"))
  .AddTypedef(type_14607, Reflex::Literal("edm::ValueMap<reco::JetID>::const_reference_type"))
  .AddTypedef(type_24319, Reflex::Literal("edm::ValueMap<reco::JetID>::Filler"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~ValueMap"), destructor_25910, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_40020), Reflex::Literal("ValueMap"), constructor_25911, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("ValueMap"), constructor_25912, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_5081, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__ValueMap_reco__JetID__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__ValueMap_reco__JetID__funcmem_bld);
}

//------Delayed data member builder for class ValueMap<reco::JetID> -------------------
void __edm__ValueMap_reco__JetID__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3000, Reflex::Literal("values_"), OffsetOf(__shadow__::__edm__ValueMap_reco__JetID_, values_), ::Reflex::PROTECTED)
  .AddDataMember(type_2974, Reflex::Literal("ids_"), OffsetOf(__shadow__::__edm__ValueMap_reco__JetID_, ids_), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class ValueMap<reco::JetID> -------------------
void __edm__ValueMap_reco__JetID__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_40021), Reflex::Literal("swap"), method_25913, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_40021, type_40020), Reflex::Literal("operator="), operator_25914, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2121, type_4933, type_2121), Reflex::Literal("rawIndexOf"), method_25915, 0, "id;idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14607, type_4933, type_2121), Reflex::Literal("get"), method_25916, 0, "id;idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14605, type_4933, type_2121), Reflex::Literal("get"), method_25917, 0, "id;idx", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_40021, type_40020), Reflex::Literal("operator+="), operator_25918, 0, "o", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566, type_4933), Reflex::Literal("contains"), method_25919, 0, "id", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2121), Reflex::Literal("size"), method_25920, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2121), Reflex::Literal("idSize"), method_25921, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("empty"), method_25922, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694), Reflex::Literal("clear"), method_25923, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25908), Reflex::Literal("begin"), method_25924, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25908), Reflex::Literal("end"), method_25925, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35947), Reflex::Literal("ids"), method_25926, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14607, type_2121), Reflex::Literal("get"), method_25927, 0, "idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_237), Reflex::Literal("Class_Version"), method_25928, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Wrapper<edm::ValueMap<reco::JetID> > -------------------------------
static void constructor_23619( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::ValueMap<reco::JetID> >();
  else ::new(mem) ::edm::Wrapper<edm::ValueMap<reco::JetID> >();
}

static void constructor_23620( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::ValueMap<reco::JetID> >(*(::std::auto_ptr<edm::ValueMap<reco::JetID> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::ValueMap<reco::JetID> >(*(::std::auto_ptr<edm::ValueMap<reco::JetID> >*)arg[0]);
}

static void destructor_23621(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<edm::ValueMap<reco::JetID> >*)o)->::edm::Wrapper<edm::ValueMap<reco::JetID> >::~Wrapper)();
}
static  void method_23622( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::ValueMap<reco::JetID> >*)o)->product)());
  else   (((const ::edm::Wrapper<edm::ValueMap<reco::JetID> >*)o)->product)();
}

static  void operator_23623( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::ValueMap<reco::JetID> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<edm::ValueMap<reco::JetID> >*)o)->operator->)();
}

static  void method_23624( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::ValueMap<reco::JetID> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<edm::ValueMap<reco::JetID> >*)o)->productTypeInfo)();
}

static  void method_23625( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::ValueMap<reco::JetID> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<edm::ValueMap<reco::JetID> >*)o)->typeInfo)();
}

static void constructor_23626( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::ValueMap<reco::JetID> >((::edm::ValueMap<reco::JetID>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::ValueMap<reco::JetID> >((::edm::ValueMap<reco::JetID>*)arg[0]);
}

static  void method_23627( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<edm::ValueMap<reco::JetID> >*)o)->getInterface)());
  else   (((::edm::Wrapper<edm::ValueMap<reco::JetID> >*)o)->getInterface)();
}

static  void method_23628( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::ValueMap<reco::JetID> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_23629( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::ValueMap<reco::JetID> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_23630( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::ValueMap<reco::JetID> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_23631( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::ValueMap<reco::JetID> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<edm::ValueMap<reco::JetID> >*)o)->dynamicTypeInfo)();
}

static  void method_23632( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<edm::ValueMap<reco::JetID> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<edm::ValueMap<reco::JetID> >*)o)->isPresent)();
}

static  void method_23633( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::ValueMap<reco::JetID> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<edm::ValueMap<reco::JetID> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4763( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ValueMap<reco::JetID> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ValueMap<reco::JetID> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ValueMap<reco::JetID> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ValueMap<reco::JetID> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ValueMap<reco::JetID> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<edm::ValueMap<reco::JetID> > -------------------------------
void __edm__Wrapper_edm__ValueMap_reco__JetID_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_edm__ValueMap_reco__JetID_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__ValueMap_reco__JetID_s__datamem_bld(&__edm__Wrapper_edm__ValueMap_reco__JetID_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__ValueMap_reco__JetID_s__funcmem_bld(&__edm__Wrapper_edm__ValueMap_reco__JetID_s__db_funcmem);
void __edm__Wrapper_edm__ValueMap_reco__JetID_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<edm::ValueMap<reco::JetID> >"), typeid(::edm::Wrapper<edm::ValueMap<reco::JetID> >), sizeof(::edm::Wrapper<edm::ValueMap<reco::JetID> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_5081, Reflex::Literal("edm::Wrapper<edm::ValueMap<reco::JetID> >::value_type"))
  .AddTypedef(type_5081, Reflex::Literal("edm::Wrapper<edm::ValueMap<reco::JetID> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_23619, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2800), Reflex::Literal("Wrapper"), constructor_23620, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_23621, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39444), Reflex::Literal("Wrapper"), constructor_23626, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4763, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_edm__ValueMap_reco__JetID_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_edm__ValueMap_reco__JetID_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<edm::ValueMap<reco::JetID> > -------------------
void __edm__Wrapper_edm__ValueMap_reco__JetID_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1566, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_edm__ValueMap_reco__JetID_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_5081, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_edm__ValueMap_reco__JetID_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<edm::ValueMap<reco::JetID> > -------------------
void __edm__Wrapper_edm__ValueMap_reco__JetID_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39443), Reflex::Literal("product"), method_23622, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39443), Reflex::Literal("operator->"), operator_23623, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("productTypeInfo"), method_23624, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("typeInfo"), method_23625, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39445), Reflex::Literal("getInterface"), method_23627, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20599, type_20679, type_38738), Reflex::Literal("fillView"), method_23628, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20732, type_358, type_11036), Reflex::Literal("setPtr"), method_23629, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20732, type_26144, type_20679), Reflex::Literal("fillPtrVector"), method_23630, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("dynamicTypeInfo"), method_23631, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isPresent"), method_23632, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("dynamicTypeInfo_"), method_23633, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<reco::JetID, std::allocator<reco::JetID> > > -------------------------------
static void constructor_23661( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<reco::JetID> >();
  else ::new(mem) ::edm::Wrapper<std::vector<reco::JetID> >();
}

static void constructor_23662( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<reco::JetID> >(*(::std::auto_ptr<std::vector<reco::JetID> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<reco::JetID> >(*(::std::auto_ptr<std::vector<reco::JetID> >*)arg[0]);
}

static void destructor_23663(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<reco::JetID> >*)o)->::edm::Wrapper<std::vector<reco::JetID> >::~Wrapper)();
}
static  void method_23664( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<reco::JetID> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<reco::JetID> >*)o)->product)();
}

static  void operator_23665( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<reco::JetID> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<reco::JetID> >*)o)->operator->)();
}

static  void method_23666( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<reco::JetID> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<reco::JetID> >*)o)->productTypeInfo)();
}

static  void method_23667( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<reco::JetID> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<reco::JetID> >*)o)->typeInfo)();
}

static void constructor_23668( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<reco::JetID> >((::std::vector<reco::JetID>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<reco::JetID> >((::std::vector<reco::JetID>*)arg[0]);
}

static  void method_23669( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<reco::JetID> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<reco::JetID> >*)o)->getInterface)();
}

static  void method_23670( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<reco::JetID> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_23671( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<reco::JetID> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_23672( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<reco::JetID> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_23673( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<reco::JetID> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<reco::JetID> >*)o)->dynamicTypeInfo)();
}

static  void method_23674( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<reco::JetID> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<reco::JetID> >*)o)->isPresent)();
}

static  void method_23675( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<reco::JetID> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<reco::JetID> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4765( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::JetID> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::JetID> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::JetID> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::JetID> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::JetID> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<reco::JetID, std::allocator<reco::JetID> > > -------------------------------
void __edm__Wrapper_std__vector_reco__JetID_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_reco__JetID_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_reco__JetID_s__datamem_bld(&__edm__Wrapper_std__vector_reco__JetID_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_reco__JetID_s__funcmem_bld(&__edm__Wrapper_std__vector_reco__JetID_s__db_funcmem);
void __edm__Wrapper_std__vector_reco__JetID_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<reco::JetID> >"), typeid(::edm::Wrapper<std::vector<reco::JetID> >), sizeof(::edm::Wrapper<std::vector<reco::JetID> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_3000, Reflex::Literal("edm::Wrapper<std::vector<reco::JetID> >::value_type"))
  .AddTypedef(type_3000, Reflex::Literal("edm::Wrapper<std::vector<reco::JetID> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_23661, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2802), Reflex::Literal("Wrapper"), constructor_23662, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_23663, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39453), Reflex::Literal("Wrapper"), constructor_23668, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4765, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_reco__JetID_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_reco__JetID_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<reco::JetID, std::allocator<reco::JetID> > > -------------------
void __edm__Wrapper_std__vector_reco__JetID_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1566, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_reco__JetID_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_3000, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_reco__JetID_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<reco::JetID, std::allocator<reco::JetID> > > -------------------
void __edm__Wrapper_std__vector_reco__JetID_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39303), Reflex::Literal("product"), method_23664, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39303), Reflex::Literal("operator->"), operator_23665, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("productTypeInfo"), method_23666, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("typeInfo"), method_23667, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39454), Reflex::Literal("getInterface"), method_23669, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20599, type_20679, type_38738), Reflex::Literal("fillView"), method_23670, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20732, type_358, type_11036), Reflex::Literal("setPtr"), method_23671, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20732, type_26144, type_20679), Reflex::Literal("fillPtrVector"), method_23672, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("dynamicTypeInfo"), method_23673, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isPresent"), method_23674, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("dynamicTypeInfo_"), method_23675, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class RefProd<std::vector<reco::CastorJetID, std::allocator<reco::CastorJetID> > > -------------------------------
static  void operator_24530( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefProd<std::vector<reco::CastorJetID> >*)o)->operator=)(*(const ::edm::RefProd<std::vector<reco::CastorJetID> >*)arg[0]);
  else   (((::edm::RefProd<std::vector<reco::CastorJetID> >*)o)->operator=)(*(const ::edm::RefProd<std::vector<reco::CastorJetID> >*)arg[0]);
}

static void constructor_24531( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::CastorJetID> >(*(const ::edm::RefProd<std::vector<reco::CastorJetID> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<reco::CastorJetID> >(*(const ::edm::RefProd<std::vector<reco::CastorJetID> >*)arg[0]);
}

static void constructor_24532( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::CastorJetID> >();
  else ::new(mem) ::edm::RefProd<std::vector<reco::CastorJetID> >();
}

static void constructor_24533( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::CastorJetID> >(*(const ::edm::Handle<std::vector<reco::CastorJetID> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<reco::CastorJetID> >(*(const ::edm::Handle<std::vector<reco::CastorJetID> >*)arg[0]);
}

static void constructor_24534( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::CastorJetID> >(*(const ::edm::OrphanHandle<std::vector<reco::CastorJetID> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<reco::CastorJetID> >(*(const ::edm::OrphanHandle<std::vector<reco::CastorJetID> >*)arg[0]);
}

static void constructor_24535( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::CastorJetID> >((const ::std::vector<reco::CastorJetID>*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<reco::CastorJetID> >((const ::std::vector<reco::CastorJetID>*)arg[0]);
}

static void constructor_24536( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::CastorJetID> >(*(const ::edm::TestHandle<std::vector<reco::CastorJetID> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<reco::CastorJetID> >(*(const ::edm::TestHandle<std::vector<reco::CastorJetID> >*)arg[0]);
}

static void constructor_24537( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::CastorJetID> >(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
  else ::new(mem) ::edm::RefProd<std::vector<reco::CastorJetID> >(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
}

static void destructor_24538(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefProd<std::vector<reco::CastorJetID> >*)o)->::edm::RefProd<std::vector<reco::CastorJetID> >::~RefProd)();
}
static  void operator_24539( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<std::vector<reco::CastorJetID> >*)o)->operator*)();
  else   (((const ::edm::RefProd<std::vector<reco::CastorJetID> >*)o)->operator*)();
}

static  void operator_24540( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<reco::CastorJetID> >*)o)->operator->)());
  else   (((const ::edm::RefProd<std::vector<reco::CastorJetID> >*)o)->operator->)();
}

static  void method_24541( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<reco::CastorJetID> >*)o)->get)());
  else   (((const ::edm::RefProd<std::vector<reco::CastorJetID> >*)o)->get)();
}

static  void method_24542( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<reco::CastorJetID> >*)o)->product)());
  else   (((const ::edm::RefProd<std::vector<reco::CastorJetID> >*)o)->product)();
}

static  void method_24543( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<std::vector<reco::CastorJetID> >*)o)->refCore)();
  else   (((const ::edm::RefProd<std::vector<reco::CastorJetID> >*)o)->refCore)();
}

static  void method_24544( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::CastorJetID> >*)o)->isNull)());
  else   (((const ::edm::RefProd<std::vector<reco::CastorJetID> >*)o)->isNull)();
}

static  void method_24545( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::CastorJetID> >*)o)->isNonnull)());
  else   (((const ::edm::RefProd<std::vector<reco::CastorJetID> >*)o)->isNonnull)();
}

static  void operator_24546( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::CastorJetID> >*)o)->operator!)());
  else   (((const ::edm::RefProd<std::vector<reco::CastorJetID> >*)o)->operator!)();
}

static  void method_24547( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefProd<std::vector<reco::CastorJetID> >*)o)->id)());
  else   (((const ::edm::RefProd<std::vector<reco::CastorJetID> >*)o)->id)();
}

static  void method_24548( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<reco::CastorJetID> >*)o)->productGetter)());
  else   (((const ::edm::RefProd<std::vector<reco::CastorJetID> >*)o)->productGetter)();
}

static  void method_24549( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::CastorJetID> >*)o)->hasCache)());
  else   (((const ::edm::RefProd<std::vector<reco::CastorJetID> >*)o)->hasCache)();
}

static  void method_24550( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::CastorJetID> >*)o)->hasProductCache)());
  else   (((const ::edm::RefProd<std::vector<reco::CastorJetID> >*)o)->hasProductCache)();
}

static  void method_24551( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::CastorJetID> >*)o)->isAvailable)());
  else   (((const ::edm::RefProd<std::vector<reco::CastorJetID> >*)o)->isAvailable)();
}

static  void method_24552( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::CastorJetID> >*)o)->isTransient)());
  else   (((const ::edm::RefProd<std::vector<reco::CastorJetID> >*)o)->isTransient)();
}

static  void method_24553( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefProd<std::vector<reco::CastorJetID> >*)o)->swap)(*(::edm::RefProd<std::vector<reco::CastorJetID> >*)arg[0]);
}

static  void method_24554( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefProd<std::vector<reco::CastorJetID> >*)o)->Class_Version)());
  else   (((::edm::RefProd<std::vector<reco::CastorJetID> >*)o)->Class_Version)();
}

static void method_newdel_4959( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<reco::CastorJetID> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<reco::CastorJetID> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<reco::CastorJetID> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<reco::CastorJetID> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<reco::CastorJetID> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefProd<std::vector<reco::CastorJetID, std::allocator<reco::CastorJetID> > > -------------------------------
void __edm__RefProd_std__vector_reco__CastorJetID_s__db_datamem(Reflex::Class*);
void __edm__RefProd_std__vector_reco__CastorJetID_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefProd_std__vector_reco__CastorJetID_s__datamem_bld(&__edm__RefProd_std__vector_reco__CastorJetID_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefProd_std__vector_reco__CastorJetID_s__funcmem_bld(&__edm__RefProd_std__vector_reco__CastorJetID_s__db_funcmem);
void __edm__RefProd_std__vector_reco__CastorJetID_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefProd<std::vector<reco::CastorJetID> >"), typeid(::edm::RefProd<std::vector<reco::CastorJetID> >), sizeof(::edm::RefProd<std::vector<reco::CastorJetID> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefProd<std::vector<reco::CastorJetID> >::Class_Version())
  .AddTypedef(type_2999, Reflex::Literal("edm::RefProd<std::vector<reco::CastorJetID> >::product_type"))
  .AddTypedef(type_2999, Reflex::Literal("edm::RefProd<std::vector<reco::CastorJetID> >::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39862, type_39863), Reflex::Literal("operator="), operator_24530, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39863), Reflex::Literal("RefProd"), constructor_24531, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefProd"), constructor_24532, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39864), Reflex::Literal("RefProd"), constructor_24533, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39865), Reflex::Literal("RefProd"), constructor_24534, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39297), Reflex::Literal("RefProd"), constructor_24535, 0, "iProduct", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39866), Reflex::Literal("RefProd"), constructor_24536, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20599, type_20675), Reflex::Literal("RefProd"), constructor_24537, 0, "productID;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefProd"), destructor_24538, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4959, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefProd_std__vector_reco__CastorJetID_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefProd_std__vector_reco__CastorJetID_s__funcmem_bld);
}

//------Delayed data member builder for class RefProd<std::vector<reco::CastorJetID, std::allocator<reco::CastorJetID> > > -------------------
void __edm__RefProd_std__vector_reco__CastorJetID_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4935, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__RefProd_std__vector_reco__CastorJetID_s_, product_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefProd<std::vector<reco::CastorJetID, std::allocator<reco::CastorJetID> > > -------------------
void __edm__RefProd_std__vector_reco__CastorJetID_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20858), Reflex::Literal("operator*"), operator_24539, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39297), Reflex::Literal("operator->"), operator_24540, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39297), Reflex::Literal("get"), method_24541, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39297), Reflex::Literal("product"), method_24542, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23940), Reflex::Literal("refCore"), method_24543, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isNull"), method_24544, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isNonnull"), method_24545, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("operator!"), operator_24546, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4933), Reflex::Literal("id"), method_24547, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20675), Reflex::Literal("productGetter"), method_24548, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("hasCache"), method_24549, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("hasProductCache"), method_24550, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isAvailable"), method_24551, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isTransient"), method_24552, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_39862), Reflex::Literal("swap"), method_24553, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_237), Reflex::Literal("Class_Version"), method_24554, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefProd<std::vector<reco::JetID, std::allocator<reco::JetID> > > -------------------------------
static  void operator_24559( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefProd<std::vector<reco::JetID> >*)o)->operator=)(*(const ::edm::RefProd<std::vector<reco::JetID> >*)arg[0]);
  else   (((::edm::RefProd<std::vector<reco::JetID> >*)o)->operator=)(*(const ::edm::RefProd<std::vector<reco::JetID> >*)arg[0]);
}

static void constructor_24560( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::JetID> >(*(const ::edm::RefProd<std::vector<reco::JetID> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<reco::JetID> >(*(const ::edm::RefProd<std::vector<reco::JetID> >*)arg[0]);
}

static void constructor_24561( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::JetID> >();
  else ::new(mem) ::edm::RefProd<std::vector<reco::JetID> >();
}

static void constructor_24562( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::JetID> >(*(const ::edm::Handle<std::vector<reco::JetID> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<reco::JetID> >(*(const ::edm::Handle<std::vector<reco::JetID> >*)arg[0]);
}

static void constructor_24563( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::JetID> >(*(const ::edm::OrphanHandle<std::vector<reco::JetID> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<reco::JetID> >(*(const ::edm::OrphanHandle<std::vector<reco::JetID> >*)arg[0]);
}

static void constructor_24564( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::JetID> >((const ::std::vector<reco::JetID>*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<reco::JetID> >((const ::std::vector<reco::JetID>*)arg[0]);
}

static void constructor_24565( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::JetID> >(*(const ::edm::TestHandle<std::vector<reco::JetID> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<reco::JetID> >(*(const ::edm::TestHandle<std::vector<reco::JetID> >*)arg[0]);
}

static void constructor_24566( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::JetID> >(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
  else ::new(mem) ::edm::RefProd<std::vector<reco::JetID> >(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
}

static void destructor_24567(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefProd<std::vector<reco::JetID> >*)o)->::edm::RefProd<std::vector<reco::JetID> >::~RefProd)();
}
static  void operator_24568( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<std::vector<reco::JetID> >*)o)->operator*)();
  else   (((const ::edm::RefProd<std::vector<reco::JetID> >*)o)->operator*)();
}

static  void operator_24569( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<reco::JetID> >*)o)->operator->)());
  else   (((const ::edm::RefProd<std::vector<reco::JetID> >*)o)->operator->)();
}

static  void method_24570( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<reco::JetID> >*)o)->get)());
  else   (((const ::edm::RefProd<std::vector<reco::JetID> >*)o)->get)();
}

static  void method_24571( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<reco::JetID> >*)o)->product)());
  else   (((const ::edm::RefProd<std::vector<reco::JetID> >*)o)->product)();
}

static  void method_24572( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<std::vector<reco::JetID> >*)o)->refCore)();
  else   (((const ::edm::RefProd<std::vector<reco::JetID> >*)o)->refCore)();
}

static  void method_24573( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::JetID> >*)o)->isNull)());
  else   (((const ::edm::RefProd<std::vector<reco::JetID> >*)o)->isNull)();
}

static  void method_24574( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::JetID> >*)o)->isNonnull)());
  else   (((const ::edm::RefProd<std::vector<reco::JetID> >*)o)->isNonnull)();
}

static  void operator_24575( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::JetID> >*)o)->operator!)());
  else   (((const ::edm::RefProd<std::vector<reco::JetID> >*)o)->operator!)();
}

static  void method_24576( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefProd<std::vector<reco::JetID> >*)o)->id)());
  else   (((const ::edm::RefProd<std::vector<reco::JetID> >*)o)->id)();
}

static  void method_24577( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<reco::JetID> >*)o)->productGetter)());
  else   (((const ::edm::RefProd<std::vector<reco::JetID> >*)o)->productGetter)();
}

static  void method_24578( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::JetID> >*)o)->hasCache)());
  else   (((const ::edm::RefProd<std::vector<reco::JetID> >*)o)->hasCache)();
}

static  void method_24579( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::JetID> >*)o)->hasProductCache)());
  else   (((const ::edm::RefProd<std::vector<reco::JetID> >*)o)->hasProductCache)();
}

static  void method_24580( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::JetID> >*)o)->isAvailable)());
  else   (((const ::edm::RefProd<std::vector<reco::JetID> >*)o)->isAvailable)();
}

static  void method_24581( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::JetID> >*)o)->isTransient)());
  else   (((const ::edm::RefProd<std::vector<reco::JetID> >*)o)->isTransient)();
}

static  void method_24582( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefProd<std::vector<reco::JetID> >*)o)->swap)(*(::edm::RefProd<std::vector<reco::JetID> >*)arg[0]);
}

static  void method_24583( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefProd<std::vector<reco::JetID> >*)o)->Class_Version)());
  else   (((::edm::RefProd<std::vector<reco::JetID> >*)o)->Class_Version)();
}

static void method_newdel_4960( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<reco::JetID> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<reco::JetID> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<reco::JetID> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<reco::JetID> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<reco::JetID> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefProd<std::vector<reco::JetID, std::allocator<reco::JetID> > > -------------------------------
void __edm__RefProd_std__vector_reco__JetID_s__db_datamem(Reflex::Class*);
void __edm__RefProd_std__vector_reco__JetID_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefProd_std__vector_reco__JetID_s__datamem_bld(&__edm__RefProd_std__vector_reco__JetID_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefProd_std__vector_reco__JetID_s__funcmem_bld(&__edm__RefProd_std__vector_reco__JetID_s__db_funcmem);
void __edm__RefProd_std__vector_reco__JetID_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefProd<std::vector<reco::JetID> >"), typeid(::edm::RefProd<std::vector<reco::JetID> >), sizeof(::edm::RefProd<std::vector<reco::JetID> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefProd<std::vector<reco::JetID> >::Class_Version())
  .AddTypedef(type_3000, Reflex::Literal("edm::RefProd<std::vector<reco::JetID> >::product_type"))
  .AddTypedef(type_3000, Reflex::Literal("edm::RefProd<std::vector<reco::JetID> >::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39867, type_39868), Reflex::Literal("operator="), operator_24559, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39868), Reflex::Literal("RefProd"), constructor_24560, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefProd"), constructor_24561, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39869), Reflex::Literal("RefProd"), constructor_24562, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39870), Reflex::Literal("RefProd"), constructor_24563, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39303), Reflex::Literal("RefProd"), constructor_24564, 0, "iProduct", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39871), Reflex::Literal("RefProd"), constructor_24565, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20599, type_20675), Reflex::Literal("RefProd"), constructor_24566, 0, "productID;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefProd"), destructor_24567, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4960, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefProd_std__vector_reco__JetID_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefProd_std__vector_reco__JetID_s__funcmem_bld);
}

//------Delayed data member builder for class RefProd<std::vector<reco::JetID, std::allocator<reco::JetID> > > -------------------
void __edm__RefProd_std__vector_reco__JetID_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4935, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__RefProd_std__vector_reco__JetID_s_, product_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefProd<std::vector<reco::JetID, std::allocator<reco::JetID> > > -------------------
void __edm__RefProd_std__vector_reco__JetID_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20870), Reflex::Literal("operator*"), operator_24568, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39303), Reflex::Literal("operator->"), operator_24569, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39303), Reflex::Literal("get"), method_24570, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39303), Reflex::Literal("product"), method_24571, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23940), Reflex::Literal("refCore"), method_24572, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isNull"), method_24573, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isNonnull"), method_24574, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("operator!"), operator_24575, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4933), Reflex::Literal("id"), method_24576, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20675), Reflex::Literal("productGetter"), method_24577, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("hasCache"), method_24578, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("hasProductCache"), method_24579, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isAvailable"), method_24580, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isTransient"), method_24581, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_39867), Reflex::Literal("swap"), method_24582, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_237), Reflex::Literal("Class_Version"), method_24583, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Ptr<reco::CastorJetID> -------------------------------
static  void operator_24771( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Ptr<reco::CastorJetID>*)o)->operator=)(*(const ::edm::Ptr<reco::CastorJetID>*)arg[0]);
  else   (((::edm::Ptr<reco::CastorJetID>*)o)->operator=)(*(const ::edm::Ptr<reco::CastorJetID>*)arg[0]);
}

static void constructor_24772( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<reco::CastorJetID>(*(const ::edm::Ptr<reco::CastorJetID>*)arg[0]);
  else ::new(mem) ::edm::Ptr<reco::CastorJetID>(*(const ::edm::Ptr<reco::CastorJetID>*)arg[0]);
}

static void constructor_24773( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<reco::CastorJetID>(*(const ::edm::ProductID*)arg[0],
      *(unsigned long*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
  else ::new(mem) ::edm::Ptr<reco::CastorJetID>(*(const ::edm::ProductID*)arg[0],
      *(unsigned long*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
}

static void constructor_24774( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<reco::CastorJetID>(*(const ::edm::ProductID*)arg[0],
      (const ::reco::CastorJetID*)arg[1],
      *(unsigned long*)arg[2]);
  else ::new(mem) ::edm::Ptr<reco::CastorJetID>(*(const ::edm::ProductID*)arg[0],
      (const ::reco::CastorJetID*)arg[1],
      *(unsigned long*)arg[2]);
}

static void constructor_24775( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<reco::CastorJetID>(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::Ptr<reco::CastorJetID>(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_24776( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<reco::CastorJetID>();
  else ::new(mem) ::edm::Ptr<reco::CastorJetID>();
}

static void destructor_24777(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Ptr<reco::CastorJetID>*)o)->::edm::Ptr<reco::CastorJetID>::~Ptr)();
}
static  void operator_24778( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ptr<reco::CastorJetID>*)o)->operator*)();
  else   (((const ::edm::Ptr<reco::CastorJetID>*)o)->operator*)();
}

static  void operator_24779( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<reco::CastorJetID>*)o)->operator->)());
  else   (((const ::edm::Ptr<reco::CastorJetID>*)o)->operator->)();
}

static  void method_24780( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<reco::CastorJetID>*)o)->get)());
  else   (((const ::edm::Ptr<reco::CastorJetID>*)o)->get)();
}

static  void method_24781( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::CastorJetID>*)o)->isNull)());
  else   (((const ::edm::Ptr<reco::CastorJetID>*)o)->isNull)();
}

static  void method_24782( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::CastorJetID>*)o)->isNonnull)());
  else   (((const ::edm::Ptr<reco::CastorJetID>*)o)->isNonnull)();
}

static  void operator_24783( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::CastorJetID>*)o)->operator!)());
  else   (((const ::edm::Ptr<reco::CastorJetID>*)o)->operator!)();
}

static  void method_24784( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::CastorJetID>*)o)->isAvailable)());
  else   (((const ::edm::Ptr<reco::CastorJetID>*)o)->isAvailable)();
}

static  void method_24785( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::CastorJetID>*)o)->isTransient)());
  else   (((const ::edm::Ptr<reco::CastorJetID>*)o)->isTransient)();
}

static  void method_24786( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::Ptr<reco::CastorJetID>*)o)->id)());
  else   (((const ::edm::Ptr<reco::CastorJetID>*)o)->id)();
}

static  void method_24787( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<reco::CastorJetID>*)o)->productGetter)());
  else   (((const ::edm::Ptr<reco::CastorJetID>*)o)->productGetter)();
}

static  void method_24788( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long)((((const ::edm::Ptr<reco::CastorJetID>*)o)->key)());
  else   (((const ::edm::Ptr<reco::CastorJetID>*)o)->key)();
}

static  void method_24789( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::CastorJetID>*)o)->hasProductCache)());
  else   (((const ::edm::Ptr<reco::CastorJetID>*)o)->hasProductCache)();
}

static  void method_24790( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ptr<reco::CastorJetID>*)o)->refCore)();
  else   (((const ::edm::Ptr<reco::CastorJetID>*)o)->refCore)();
}

static  void method_24791( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<reco::CastorJetID>*)o)->product)());
  else   (((const ::edm::Ptr<reco::CastorJetID>*)o)->product)();
}

static  void method_24792( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::Ptr<reco::CastorJetID>*)o)->Class_Version)());
  else   (((::edm::Ptr<reco::CastorJetID>*)o)->Class_Version)();
}

static void method_newdel_4988( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Ptr<reco::CastorJetID> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Ptr<reco::CastorJetID> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Ptr<reco::CastorJetID> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Ptr<reco::CastorJetID> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Ptr<reco::CastorJetID> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Ptr<reco::CastorJetID> -------------------------------
void __edm__Ptr_reco__CastorJetID__db_datamem(Reflex::Class*);
void __edm__Ptr_reco__CastorJetID__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Ptr_reco__CastorJetID__datamem_bld(&__edm__Ptr_reco__CastorJetID__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Ptr_reco__CastorJetID__funcmem_bld(&__edm__Ptr_reco__CastorJetID__db_funcmem);
void __edm__Ptr_reco__CastorJetID__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Ptr<reco::CastorJetID>"), typeid(::edm::Ptr<reco::CastorJetID>), sizeof(::edm::Ptr<reco::CastorJetID>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::Ptr<reco::CastorJetID>::Class_Version())
  .AddTypedef(type_358, Reflex::Literal("edm::Ptr<reco::CastorJetID>::key_type"))
  .AddTypedef(type_7846, Reflex::Literal("edm::Ptr<reco::CastorJetID>::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39900, type_39235), Reflex::Literal("operator="), operator_24771, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39235), Reflex::Literal("Ptr"), constructor_24772, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20599, type_358, type_20675), Reflex::Literal("Ptr"), constructor_24773, 0, "productID;itemKey;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20599, type_14538, type_358), Reflex::Literal("Ptr"), constructor_24774, 0, "productID;item;item_key", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20599), Reflex::Literal("Ptr"), constructor_24775, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Ptr"), constructor_24776, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Ptr"), destructor_24777, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4988, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Ptr_reco__CastorJetID__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Ptr_reco__CastorJetID__funcmem_bld);
}

//------Delayed data member builder for class Ptr<reco::CastorJetID> -------------------
void __edm__Ptr_reco__CastorJetID__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4935, Reflex::Literal("core_"), OffsetOf(__shadow__::__edm__Ptr_reco__CastorJetID_, core_), ::Reflex::PRIVATE)
  .AddDataMember(type_358, Reflex::Literal("key_"), OffsetOf(__shadow__::__edm__Ptr_reco__CastorJetID_, key_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Ptr<reco::CastorJetID> -------------------
void __edm__Ptr_reco__CastorJetID__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14542), Reflex::Literal("operator*"), operator_24778, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14538), Reflex::Literal("operator->"), operator_24779, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14538), Reflex::Literal("get"), method_24780, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isNull"), method_24781, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isNonnull"), method_24782, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("operator!"), operator_24783, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isAvailable"), method_24784, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isTransient"), method_24785, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4933), Reflex::Literal("id"), method_24786, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20675), Reflex::Literal("productGetter"), method_24787, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_358), Reflex::Literal("key"), method_24788, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("hasProductCache"), method_24789, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23940), Reflex::Literal("refCore"), method_24790, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4071), Reflex::Literal("product"), method_24791, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_237), Reflex::Literal("Class_Version"), method_24792, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Ptr<reco::JetID> -------------------------------
static  void operator_24799( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Ptr<reco::JetID>*)o)->operator=)(*(const ::edm::Ptr<reco::JetID>*)arg[0]);
  else   (((::edm::Ptr<reco::JetID>*)o)->operator=)(*(const ::edm::Ptr<reco::JetID>*)arg[0]);
}

static void constructor_24800( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<reco::JetID>(*(const ::edm::Ptr<reco::JetID>*)arg[0]);
  else ::new(mem) ::edm::Ptr<reco::JetID>(*(const ::edm::Ptr<reco::JetID>*)arg[0]);
}

static void constructor_24801( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<reco::JetID>(*(const ::edm::ProductID*)arg[0],
      *(unsigned long*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
  else ::new(mem) ::edm::Ptr<reco::JetID>(*(const ::edm::ProductID*)arg[0],
      *(unsigned long*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
}

static void constructor_24802( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<reco::JetID>(*(const ::edm::ProductID*)arg[0],
      (const ::reco::JetID*)arg[1],
      *(unsigned long*)arg[2]);
  else ::new(mem) ::edm::Ptr<reco::JetID>(*(const ::edm::ProductID*)arg[0],
      (const ::reco::JetID*)arg[1],
      *(unsigned long*)arg[2]);
}

static void constructor_24803( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<reco::JetID>(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::Ptr<reco::JetID>(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_24804( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<reco::JetID>();
  else ::new(mem) ::edm::Ptr<reco::JetID>();
}

static void destructor_24805(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Ptr<reco::JetID>*)o)->::edm::Ptr<reco::JetID>::~Ptr)();
}
static  void operator_24806( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ptr<reco::JetID>*)o)->operator*)();
  else   (((const ::edm::Ptr<reco::JetID>*)o)->operator*)();
}

static  void operator_24807( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<reco::JetID>*)o)->operator->)());
  else   (((const ::edm::Ptr<reco::JetID>*)o)->operator->)();
}

static  void method_24808( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<reco::JetID>*)o)->get)());
  else   (((const ::edm::Ptr<reco::JetID>*)o)->get)();
}

static  void method_24809( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::JetID>*)o)->isNull)());
  else   (((const ::edm::Ptr<reco::JetID>*)o)->isNull)();
}

static  void method_24810( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::JetID>*)o)->isNonnull)());
  else   (((const ::edm::Ptr<reco::JetID>*)o)->isNonnull)();
}

static  void operator_24811( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::JetID>*)o)->operator!)());
  else   (((const ::edm::Ptr<reco::JetID>*)o)->operator!)();
}

static  void method_24812( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::JetID>*)o)->isAvailable)());
  else   (((const ::edm::Ptr<reco::JetID>*)o)->isAvailable)();
}

static  void method_24813( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::JetID>*)o)->isTransient)());
  else   (((const ::edm::Ptr<reco::JetID>*)o)->isTransient)();
}

static  void method_24814( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::Ptr<reco::JetID>*)o)->id)());
  else   (((const ::edm::Ptr<reco::JetID>*)o)->id)();
}

static  void method_24815( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<reco::JetID>*)o)->productGetter)());
  else   (((const ::edm::Ptr<reco::JetID>*)o)->productGetter)();
}

static  void method_24816( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long)((((const ::edm::Ptr<reco::JetID>*)o)->key)());
  else   (((const ::edm::Ptr<reco::JetID>*)o)->key)();
}

static  void method_24817( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::JetID>*)o)->hasProductCache)());
  else   (((const ::edm::Ptr<reco::JetID>*)o)->hasProductCache)();
}

static  void method_24818( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ptr<reco::JetID>*)o)->refCore)();
  else   (((const ::edm::Ptr<reco::JetID>*)o)->refCore)();
}

static  void method_24819( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<reco::JetID>*)o)->product)());
  else   (((const ::edm::Ptr<reco::JetID>*)o)->product)();
}

static  void method_24820( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::Ptr<reco::JetID>*)o)->Class_Version)());
  else   (((::edm::Ptr<reco::JetID>*)o)->Class_Version)();
}

static void method_newdel_4989( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Ptr<reco::JetID> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Ptr<reco::JetID> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Ptr<reco::JetID> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Ptr<reco::JetID> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Ptr<reco::JetID> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Ptr<reco::JetID> -------------------------------
void __edm__Ptr_reco__JetID__db_datamem(Reflex::Class*);
void __edm__Ptr_reco__JetID__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Ptr_reco__JetID__datamem_bld(&__edm__Ptr_reco__JetID__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Ptr_reco__JetID__funcmem_bld(&__edm__Ptr_reco__JetID__db_funcmem);
void __edm__Ptr_reco__JetID__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Ptr<reco::JetID>"), typeid(::edm::Ptr<reco::JetID>), sizeof(::edm::Ptr<reco::JetID>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::Ptr<reco::JetID>::Class_Version())
  .AddTypedef(type_358, Reflex::Literal("edm::Ptr<reco::JetID>::key_type"))
  .AddTypedef(type_7841, Reflex::Literal("edm::Ptr<reco::JetID>::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39901, type_39238), Reflex::Literal("operator="), operator_24799, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39238), Reflex::Literal("Ptr"), constructor_24800, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20599, type_358, type_20675), Reflex::Literal("Ptr"), constructor_24801, 0, "productID;itemKey;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20599, type_14603, type_358), Reflex::Literal("Ptr"), constructor_24802, 0, "productID;item;item_key", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20599), Reflex::Literal("Ptr"), constructor_24803, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Ptr"), constructor_24804, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Ptr"), destructor_24805, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4989, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Ptr_reco__JetID__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Ptr_reco__JetID__funcmem_bld);
}

//------Delayed data member builder for class Ptr<reco::JetID> -------------------
void __edm__Ptr_reco__JetID__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4935, Reflex::Literal("core_"), OffsetOf(__shadow__::__edm__Ptr_reco__JetID_, core_), ::Reflex::PRIVATE)
  .AddDataMember(type_358, Reflex::Literal("key_"), OffsetOf(__shadow__::__edm__Ptr_reco__JetID_, key_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Ptr<reco::JetID> -------------------
void __edm__Ptr_reco__JetID__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14607), Reflex::Literal("operator*"), operator_24806, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14603), Reflex::Literal("operator->"), operator_24807, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14603), Reflex::Literal("get"), method_24808, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isNull"), method_24809, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isNonnull"), method_24810, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("operator!"), operator_24811, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isAvailable"), method_24812, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isTransient"), method_24813, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4933), Reflex::Literal("id"), method_24814, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20675), Reflex::Literal("productGetter"), method_24815, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_358), Reflex::Literal("key"), method_24816, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("hasProductCache"), method_24817, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23940), Reflex::Literal("refCore"), method_24818, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4071), Reflex::Literal("product"), method_24819, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_237), Reflex::Literal("Class_Version"), method_24820, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Ptr<reco::PFClusterJet> -------------------------------
static  void operator_24855( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Ptr<reco::PFClusterJet>*)o)->operator=)(*(const ::edm::Ptr<reco::PFClusterJet>*)arg[0]);
  else   (((::edm::Ptr<reco::PFClusterJet>*)o)->operator=)(*(const ::edm::Ptr<reco::PFClusterJet>*)arg[0]);
}

static void constructor_24856( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<reco::PFClusterJet>(*(const ::edm::Ptr<reco::PFClusterJet>*)arg[0]);
  else ::new(mem) ::edm::Ptr<reco::PFClusterJet>(*(const ::edm::Ptr<reco::PFClusterJet>*)arg[0]);
}

static void constructor_24857( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<reco::PFClusterJet>(*(const ::edm::ProductID*)arg[0],
      *(unsigned long*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
  else ::new(mem) ::edm::Ptr<reco::PFClusterJet>(*(const ::edm::ProductID*)arg[0],
      *(unsigned long*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
}

static void constructor_24858( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<reco::PFClusterJet>(*(const ::edm::ProductID*)arg[0],
      (const ::reco::PFClusterJet*)arg[1],
      *(unsigned long*)arg[2]);
  else ::new(mem) ::edm::Ptr<reco::PFClusterJet>(*(const ::edm::ProductID*)arg[0],
      (const ::reco::PFClusterJet*)arg[1],
      *(unsigned long*)arg[2]);
}

static void constructor_24859( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<reco::PFClusterJet>(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::Ptr<reco::PFClusterJet>(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_24860( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<reco::PFClusterJet>();
  else ::new(mem) ::edm::Ptr<reco::PFClusterJet>();
}

static void destructor_24861(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Ptr<reco::PFClusterJet>*)o)->::edm::Ptr<reco::PFClusterJet>::~Ptr)();
}
static  void operator_24862( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ptr<reco::PFClusterJet>*)o)->operator*)();
  else   (((const ::edm::Ptr<reco::PFClusterJet>*)o)->operator*)();
}

static  void operator_24863( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<reco::PFClusterJet>*)o)->operator->)());
  else   (((const ::edm::Ptr<reco::PFClusterJet>*)o)->operator->)();
}

static  void method_24864( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<reco::PFClusterJet>*)o)->get)());
  else   (((const ::edm::Ptr<reco::PFClusterJet>*)o)->get)();
}

static  void method_24865( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::PFClusterJet>*)o)->isNull)());
  else   (((const ::edm::Ptr<reco::PFClusterJet>*)o)->isNull)();
}

static  void method_24866( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::PFClusterJet>*)o)->isNonnull)());
  else   (((const ::edm::Ptr<reco::PFClusterJet>*)o)->isNonnull)();
}

static  void operator_24867( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::PFClusterJet>*)o)->operator!)());
  else   (((const ::edm::Ptr<reco::PFClusterJet>*)o)->operator!)();
}

static  void method_24868( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::PFClusterJet>*)o)->isAvailable)());
  else   (((const ::edm::Ptr<reco::PFClusterJet>*)o)->isAvailable)();
}

static  void method_24869( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::PFClusterJet>*)o)->isTransient)());
  else   (((const ::edm::Ptr<reco::PFClusterJet>*)o)->isTransient)();
}

static  void method_24870( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::Ptr<reco::PFClusterJet>*)o)->id)());
  else   (((const ::edm::Ptr<reco::PFClusterJet>*)o)->id)();
}

static  void method_24871( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<reco::PFClusterJet>*)o)->productGetter)());
  else   (((const ::edm::Ptr<reco::PFClusterJet>*)o)->productGetter)();
}

static  void method_24872( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long)((((const ::edm::Ptr<reco::PFClusterJet>*)o)->key)());
  else   (((const ::edm::Ptr<reco::PFClusterJet>*)o)->key)();
}

static  void method_24873( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::PFClusterJet>*)o)->hasProductCache)());
  else   (((const ::edm::Ptr<reco::PFClusterJet>*)o)->hasProductCache)();
}

static  void method_24874( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ptr<reco::PFClusterJet>*)o)->refCore)();
  else   (((const ::edm::Ptr<reco::PFClusterJet>*)o)->refCore)();
}

static  void method_24875( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<reco::PFClusterJet>*)o)->product)());
  else   (((const ::edm::Ptr<reco::PFClusterJet>*)o)->product)();
}

static  void method_24876( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::Ptr<reco::PFClusterJet>*)o)->Class_Version)());
  else   (((::edm::Ptr<reco::PFClusterJet>*)o)->Class_Version)();
}

static void method_newdel_4991( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Ptr<reco::PFClusterJet> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Ptr<reco::PFClusterJet> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Ptr<reco::PFClusterJet> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Ptr<reco::PFClusterJet> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Ptr<reco::PFClusterJet> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Ptr<reco::PFClusterJet> -------------------------------
void __edm__Ptr_reco__PFClusterJet__db_datamem(Reflex::Class*);
void __edm__Ptr_reco__PFClusterJet__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Ptr_reco__PFClusterJet__datamem_bld(&__edm__Ptr_reco__PFClusterJet__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Ptr_reco__PFClusterJet__funcmem_bld(&__edm__Ptr_reco__PFClusterJet__db_funcmem);
void __edm__Ptr_reco__PFClusterJet__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Ptr<reco::PFClusterJet>"), typeid(::edm::Ptr<reco::PFClusterJet>), sizeof(::edm::Ptr<reco::PFClusterJet>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::Ptr<reco::PFClusterJet>::Class_Version())
  .AddTypedef(type_358, Reflex::Literal("edm::Ptr<reco::PFClusterJet>::key_type"))
  .AddTypedef(type_8007, Reflex::Literal("edm::Ptr<reco::PFClusterJet>::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39902, type_39241), Reflex::Literal("operator="), operator_24855, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39241), Reflex::Literal("Ptr"), constructor_24856, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20599, type_358, type_20675), Reflex::Literal("Ptr"), constructor_24857, 0, "productID;itemKey;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20599, type_15503, type_358), Reflex::Literal("Ptr"), constructor_24858, 0, "productID;item;item_key", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20599), Reflex::Literal("Ptr"), constructor_24859, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Ptr"), constructor_24860, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Ptr"), destructor_24861, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4991, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Ptr_reco__PFClusterJet__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Ptr_reco__PFClusterJet__funcmem_bld);
}

//------Delayed data member builder for class Ptr<reco::PFClusterJet> -------------------
void __edm__Ptr_reco__PFClusterJet__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4935, Reflex::Literal("core_"), OffsetOf(__shadow__::__edm__Ptr_reco__PFClusterJet_, core_), ::Reflex::PRIVATE)
  .AddDataMember(type_358, Reflex::Literal("key_"), OffsetOf(__shadow__::__edm__Ptr_reco__PFClusterJet_, key_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Ptr<reco::PFClusterJet> -------------------
void __edm__Ptr_reco__PFClusterJet__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15507), Reflex::Literal("operator*"), operator_24862, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15503), Reflex::Literal("operator->"), operator_24863, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15503), Reflex::Literal("get"), method_24864, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isNull"), method_24865, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isNonnull"), method_24866, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("operator!"), operator_24867, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isAvailable"), method_24868, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isTransient"), method_24869, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4933), Reflex::Literal("id"), method_24870, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20675), Reflex::Literal("productGetter"), method_24871, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_358), Reflex::Literal("key"), method_24872, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("hasProductCache"), method_24873, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23940), Reflex::Literal("refCore"), method_24874, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4071), Reflex::Literal("product"), method_24875, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_237), Reflex::Literal("Class_Version"), method_24876, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Ptr<reco::TrackJet> -------------------------------
static  void operator_24883( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Ptr<reco::TrackJet>*)o)->operator=)(*(const ::edm::Ptr<reco::TrackJet>*)arg[0]);
  else   (((::edm::Ptr<reco::TrackJet>*)o)->operator=)(*(const ::edm::Ptr<reco::TrackJet>*)arg[0]);
}

static void constructor_24884( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<reco::TrackJet>(*(const ::edm::Ptr<reco::TrackJet>*)arg[0]);
  else ::new(mem) ::edm::Ptr<reco::TrackJet>(*(const ::edm::Ptr<reco::TrackJet>*)arg[0]);
}

static void constructor_24885( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<reco::TrackJet>(*(const ::edm::ProductID*)arg[0],
      *(unsigned long*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
  else ::new(mem) ::edm::Ptr<reco::TrackJet>(*(const ::edm::ProductID*)arg[0],
      *(unsigned long*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
}

static void constructor_24886( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<reco::TrackJet>(*(const ::edm::ProductID*)arg[0],
      (const ::reco::TrackJet*)arg[1],
      *(unsigned long*)arg[2]);
  else ::new(mem) ::edm::Ptr<reco::TrackJet>(*(const ::edm::ProductID*)arg[0],
      (const ::reco::TrackJet*)arg[1],
      *(unsigned long*)arg[2]);
}

static void constructor_24887( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<reco::TrackJet>(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::Ptr<reco::TrackJet>(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_24888( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<reco::TrackJet>();
  else ::new(mem) ::edm::Ptr<reco::TrackJet>();
}

static void destructor_24889(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Ptr<reco::TrackJet>*)o)->::edm::Ptr<reco::TrackJet>::~Ptr)();
}
static  void operator_24890( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ptr<reco::TrackJet>*)o)->operator*)();
  else   (((const ::edm::Ptr<reco::TrackJet>*)o)->operator*)();
}

static  void operator_24891( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<reco::TrackJet>*)o)->operator->)());
  else   (((const ::edm::Ptr<reco::TrackJet>*)o)->operator->)();
}

static  void method_24892( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<reco::TrackJet>*)o)->get)());
  else   (((const ::edm::Ptr<reco::TrackJet>*)o)->get)();
}

static  void method_24893( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::TrackJet>*)o)->isNull)());
  else   (((const ::edm::Ptr<reco::TrackJet>*)o)->isNull)();
}

static  void method_24894( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::TrackJet>*)o)->isNonnull)());
  else   (((const ::edm::Ptr<reco::TrackJet>*)o)->isNonnull)();
}

static  void operator_24895( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::TrackJet>*)o)->operator!)());
  else   (((const ::edm::Ptr<reco::TrackJet>*)o)->operator!)();
}

static  void method_24896( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::TrackJet>*)o)->isAvailable)());
  else   (((const ::edm::Ptr<reco::TrackJet>*)o)->isAvailable)();
}

static  void method_24897( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::TrackJet>*)o)->isTransient)());
  else   (((const ::edm::Ptr<reco::TrackJet>*)o)->isTransient)();
}

static  void method_24898( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::Ptr<reco::TrackJet>*)o)->id)());
  else   (((const ::edm::Ptr<reco::TrackJet>*)o)->id)();
}

static  void method_24899( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<reco::TrackJet>*)o)->productGetter)());
  else   (((const ::edm::Ptr<reco::TrackJet>*)o)->productGetter)();
}

static  void method_24900( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long)((((const ::edm::Ptr<reco::TrackJet>*)o)->key)());
  else   (((const ::edm::Ptr<reco::TrackJet>*)o)->key)();
}

static  void method_24901( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::TrackJet>*)o)->hasProductCache)());
  else   (((const ::edm::Ptr<reco::TrackJet>*)o)->hasProductCache)();
}

static  void method_24902( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ptr<reco::TrackJet>*)o)->refCore)();
  else   (((const ::edm::Ptr<reco::TrackJet>*)o)->refCore)();
}

static  void method_24903( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<reco::TrackJet>*)o)->product)());
  else   (((const ::edm::Ptr<reco::TrackJet>*)o)->product)();
}

static  void method_24904( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::Ptr<reco::TrackJet>*)o)->Class_Version)());
  else   (((::edm::Ptr<reco::TrackJet>*)o)->Class_Version)();
}

static void method_newdel_4992( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Ptr<reco::TrackJet> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Ptr<reco::TrackJet> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Ptr<reco::TrackJet> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Ptr<reco::TrackJet> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Ptr<reco::TrackJet> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Ptr<reco::TrackJet> -------------------------------
void __edm__Ptr_reco__TrackJet__db_datamem(Reflex::Class*);
void __edm__Ptr_reco__TrackJet__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Ptr_reco__TrackJet__datamem_bld(&__edm__Ptr_reco__TrackJet__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Ptr_reco__TrackJet__funcmem_bld(&__edm__Ptr_reco__TrackJet__db_funcmem);
void __edm__Ptr_reco__TrackJet__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Ptr<reco::TrackJet>"), typeid(::edm::Ptr<reco::TrackJet>), sizeof(::edm::Ptr<reco::TrackJet>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::Ptr<reco::TrackJet>::Class_Version())
  .AddTypedef(type_358, Reflex::Literal("edm::Ptr<reco::TrackJet>::key_type"))
  .AddTypedef(type_7854, Reflex::Literal("edm::Ptr<reco::TrackJet>::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39903, type_39244), Reflex::Literal("operator="), operator_24883, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39244), Reflex::Literal("Ptr"), constructor_24884, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20599, type_358, type_20675), Reflex::Literal("Ptr"), constructor_24885, 0, "productID;itemKey;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20599, type_16024, type_358), Reflex::Literal("Ptr"), constructor_24886, 0, "productID;item;item_key", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20599), Reflex::Literal("Ptr"), constructor_24887, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Ptr"), constructor_24888, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Ptr"), destructor_24889, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4992, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Ptr_reco__TrackJet__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Ptr_reco__TrackJet__funcmem_bld);
}

//------Delayed data member builder for class Ptr<reco::TrackJet> -------------------
void __edm__Ptr_reco__TrackJet__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4935, Reflex::Literal("core_"), OffsetOf(__shadow__::__edm__Ptr_reco__TrackJet_, core_), ::Reflex::PRIVATE)
  .AddDataMember(type_358, Reflex::Literal("key_"), OffsetOf(__shadow__::__edm__Ptr_reco__TrackJet_, key_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Ptr<reco::TrackJet> -------------------
void __edm__Ptr_reco__TrackJet__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16028), Reflex::Literal("operator*"), operator_24890, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16024), Reflex::Literal("operator->"), operator_24891, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16024), Reflex::Literal("get"), method_24892, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isNull"), method_24893, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isNonnull"), method_24894, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("operator!"), operator_24895, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isAvailable"), method_24896, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isTransient"), method_24897, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4933), Reflex::Literal("id"), method_24898, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20675), Reflex::Literal("productGetter"), method_24899, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_358), Reflex::Literal("key"), method_24900, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("hasProductCache"), method_24901, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23940), Reflex::Literal("refCore"), method_24902, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4071), Reflex::Literal("product"), method_24903, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_237), Reflex::Literal("Class_Version"), method_24904, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Ptr<reco::GenJet> -------------------------------
static  void operator_24911( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Ptr<reco::GenJet>*)o)->operator=)(*(const ::edm::Ptr<reco::GenJet>*)arg[0]);
  else   (((::edm::Ptr<reco::GenJet>*)o)->operator=)(*(const ::edm::Ptr<reco::GenJet>*)arg[0]);
}

static void constructor_24912( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<reco::GenJet>(*(const ::edm::Ptr<reco::GenJet>*)arg[0]);
  else ::new(mem) ::edm::Ptr<reco::GenJet>(*(const ::edm::Ptr<reco::GenJet>*)arg[0]);
}

static void constructor_24913( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<reco::GenJet>(*(const ::edm::ProductID*)arg[0],
      *(unsigned long*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
  else ::new(mem) ::edm::Ptr<reco::GenJet>(*(const ::edm::ProductID*)arg[0],
      *(unsigned long*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
}

static void constructor_24914( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<reco::GenJet>(*(const ::edm::ProductID*)arg[0],
      (const ::reco::GenJet*)arg[1],
      *(unsigned long*)arg[2]);
  else ::new(mem) ::edm::Ptr<reco::GenJet>(*(const ::edm::ProductID*)arg[0],
      (const ::reco::GenJet*)arg[1],
      *(unsigned long*)arg[2]);
}

static void constructor_24915( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<reco::GenJet>(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::Ptr<reco::GenJet>(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_24916( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<reco::GenJet>();
  else ::new(mem) ::edm::Ptr<reco::GenJet>();
}

static void destructor_24917(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Ptr<reco::GenJet>*)o)->::edm::Ptr<reco::GenJet>::~Ptr)();
}
static  void operator_24918( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ptr<reco::GenJet>*)o)->operator*)();
  else   (((const ::edm::Ptr<reco::GenJet>*)o)->operator*)();
}

static  void operator_24919( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<reco::GenJet>*)o)->operator->)());
  else   (((const ::edm::Ptr<reco::GenJet>*)o)->operator->)();
}

static  void method_24920( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<reco::GenJet>*)o)->get)());
  else   (((const ::edm::Ptr<reco::GenJet>*)o)->get)();
}

static  void method_24921( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::GenJet>*)o)->isNull)());
  else   (((const ::edm::Ptr<reco::GenJet>*)o)->isNull)();
}

static  void method_24922( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::GenJet>*)o)->isNonnull)());
  else   (((const ::edm::Ptr<reco::GenJet>*)o)->isNonnull)();
}

static  void operator_24923( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::GenJet>*)o)->operator!)());
  else   (((const ::edm::Ptr<reco::GenJet>*)o)->operator!)();
}

static  void method_24924( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::GenJet>*)o)->isAvailable)());
  else   (((const ::edm::Ptr<reco::GenJet>*)o)->isAvailable)();
}

static  void method_24925( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::GenJet>*)o)->isTransient)());
  else   (((const ::edm::Ptr<reco::GenJet>*)o)->isTransient)();
}

static  void method_24926( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::Ptr<reco::GenJet>*)o)->id)());
  else   (((const ::edm::Ptr<reco::GenJet>*)o)->id)();
}

static  void method_24927( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<reco::GenJet>*)o)->productGetter)());
  else   (((const ::edm::Ptr<reco::GenJet>*)o)->productGetter)();
}

static  void method_24928( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long)((((const ::edm::Ptr<reco::GenJet>*)o)->key)());
  else   (((const ::edm::Ptr<reco::GenJet>*)o)->key)();
}

static  void method_24929( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::GenJet>*)o)->hasProductCache)());
  else   (((const ::edm::Ptr<reco::GenJet>*)o)->hasProductCache)();
}

static  void method_24930( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ptr<reco::GenJet>*)o)->refCore)();
  else   (((const ::edm::Ptr<reco::GenJet>*)o)->refCore)();
}

static  void method_24931( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<reco::GenJet>*)o)->product)());
  else   (((const ::edm::Ptr<reco::GenJet>*)o)->product)();
}

static  void method_24932( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::Ptr<reco::GenJet>*)o)->Class_Version)());
  else   (((::edm::Ptr<reco::GenJet>*)o)->Class_Version)();
}

static void method_newdel_4993( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Ptr<reco::GenJet> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Ptr<reco::GenJet> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Ptr<reco::GenJet> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Ptr<reco::GenJet> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Ptr<reco::GenJet> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Ptr<reco::GenJet> -------------------------------
void __edm__Ptr_reco__GenJet__db_datamem(Reflex::Class*);
void __edm__Ptr_reco__GenJet__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Ptr_reco__GenJet__datamem_bld(&__edm__Ptr_reco__GenJet__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Ptr_reco__GenJet__funcmem_bld(&__edm__Ptr_reco__GenJet__db_funcmem);
void __edm__Ptr_reco__GenJet__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Ptr<reco::GenJet>"), typeid(::edm::Ptr<reco::GenJet>), sizeof(::edm::Ptr<reco::GenJet>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::Ptr<reco::GenJet>::Class_Version())
  .AddTypedef(type_358, Reflex::Literal("edm::Ptr<reco::GenJet>::key_type"))
  .AddTypedef(type_7893, Reflex::Literal("edm::Ptr<reco::GenJet>::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39904, type_39247), Reflex::Literal("operator="), operator_24911, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39247), Reflex::Literal("Ptr"), constructor_24912, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20599, type_358, type_20675), Reflex::Literal("Ptr"), constructor_24913, 0, "productID;itemKey;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20599, type_16346, type_358), Reflex::Literal("Ptr"), constructor_24914, 0, "productID;item;item_key", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20599), Reflex::Literal("Ptr"), constructor_24915, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Ptr"), constructor_24916, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Ptr"), destructor_24917, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4993, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Ptr_reco__GenJet__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Ptr_reco__GenJet__funcmem_bld);
}

//------Delayed data member builder for class Ptr<reco::GenJet> -------------------
void __edm__Ptr_reco__GenJet__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4935, Reflex::Literal("core_"), OffsetOf(__shadow__::__edm__Ptr_reco__GenJet_, core_), ::Reflex::PRIVATE)
  .AddDataMember(type_358, Reflex::Literal("key_"), OffsetOf(__shadow__::__edm__Ptr_reco__GenJet_, key_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Ptr<reco::GenJet> -------------------
void __edm__Ptr_reco__GenJet__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16350), Reflex::Literal("operator*"), operator_24918, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16346), Reflex::Literal("operator->"), operator_24919, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16346), Reflex::Literal("get"), method_24920, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isNull"), method_24921, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isNonnull"), method_24922, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("operator!"), operator_24923, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isAvailable"), method_24924, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isTransient"), method_24925, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4933), Reflex::Literal("id"), method_24926, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20675), Reflex::Literal("productGetter"), method_24927, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_358), Reflex::Literal("key"), method_24928, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("hasProductCache"), method_24929, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23940), Reflex::Literal("refCore"), method_24930, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4071), Reflex::Literal("product"), method_24931, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_237), Reflex::Literal("Class_Version"), method_24932, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Ptr<reco::BasicJet> -------------------------------
static  void operator_24939( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Ptr<reco::BasicJet>*)o)->operator=)(*(const ::edm::Ptr<reco::BasicJet>*)arg[0]);
  else   (((::edm::Ptr<reco::BasicJet>*)o)->operator=)(*(const ::edm::Ptr<reco::BasicJet>*)arg[0]);
}

static void constructor_24940( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<reco::BasicJet>(*(const ::edm::Ptr<reco::BasicJet>*)arg[0]);
  else ::new(mem) ::edm::Ptr<reco::BasicJet>(*(const ::edm::Ptr<reco::BasicJet>*)arg[0]);
}

static void constructor_24941( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<reco::BasicJet>(*(const ::edm::ProductID*)arg[0],
      *(unsigned long*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
  else ::new(mem) ::edm::Ptr<reco::BasicJet>(*(const ::edm::ProductID*)arg[0],
      *(unsigned long*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
}

static void constructor_24942( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<reco::BasicJet>(*(const ::edm::ProductID*)arg[0],
      (const ::reco::BasicJet*)arg[1],
      *(unsigned long*)arg[2]);
  else ::new(mem) ::edm::Ptr<reco::BasicJet>(*(const ::edm::ProductID*)arg[0],
      (const ::reco::BasicJet*)arg[1],
      *(unsigned long*)arg[2]);
}

static void constructor_24943( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<reco::BasicJet>(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::Ptr<reco::BasicJet>(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_24944( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<reco::BasicJet>();
  else ::new(mem) ::edm::Ptr<reco::BasicJet>();
}

static void destructor_24945(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Ptr<reco::BasicJet>*)o)->::edm::Ptr<reco::BasicJet>::~Ptr)();
}
static  void operator_24946( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ptr<reco::BasicJet>*)o)->operator*)();
  else   (((const ::edm::Ptr<reco::BasicJet>*)o)->operator*)();
}

static  void operator_24947( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<reco::BasicJet>*)o)->operator->)());
  else   (((const ::edm::Ptr<reco::BasicJet>*)o)->operator->)();
}

static  void method_24948( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<reco::BasicJet>*)o)->get)());
  else   (((const ::edm::Ptr<reco::BasicJet>*)o)->get)();
}

static  void method_24949( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::BasicJet>*)o)->isNull)());
  else   (((const ::edm::Ptr<reco::BasicJet>*)o)->isNull)();
}

static  void method_24950( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::BasicJet>*)o)->isNonnull)());
  else   (((const ::edm::Ptr<reco::BasicJet>*)o)->isNonnull)();
}

static  void operator_24951( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::BasicJet>*)o)->operator!)());
  else   (((const ::edm::Ptr<reco::BasicJet>*)o)->operator!)();
}

static  void method_24952( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::BasicJet>*)o)->isAvailable)());
  else   (((const ::edm::Ptr<reco::BasicJet>*)o)->isAvailable)();
}

static  void method_24953( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::BasicJet>*)o)->isTransient)());
  else   (((const ::edm::Ptr<reco::BasicJet>*)o)->isTransient)();
}

static  void method_24954( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::Ptr<reco::BasicJet>*)o)->id)());
  else   (((const ::edm::Ptr<reco::BasicJet>*)o)->id)();
}

static  void method_24955( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<reco::BasicJet>*)o)->productGetter)());
  else   (((const ::edm::Ptr<reco::BasicJet>*)o)->productGetter)();
}

static  void method_24956( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long)((((const ::edm::Ptr<reco::BasicJet>*)o)->key)());
  else   (((const ::edm::Ptr<reco::BasicJet>*)o)->key)();
}

static  void method_24957( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::BasicJet>*)o)->hasProductCache)());
  else   (((const ::edm::Ptr<reco::BasicJet>*)o)->hasProductCache)();
}

static  void method_24958( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ptr<reco::BasicJet>*)o)->refCore)();
  else   (((const ::edm::Ptr<reco::BasicJet>*)o)->refCore)();
}

static  void method_24959( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<reco::BasicJet>*)o)->product)());
  else   (((const ::edm::Ptr<reco::BasicJet>*)o)->product)();
}

static  void method_24960( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::Ptr<reco::BasicJet>*)o)->Class_Version)());
  else   (((::edm::Ptr<reco::BasicJet>*)o)->Class_Version)();
}

static void method_newdel_4994( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Ptr<reco::BasicJet> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Ptr<reco::BasicJet> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Ptr<reco::BasicJet> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Ptr<reco::BasicJet> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Ptr<reco::BasicJet> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Ptr<reco::BasicJet> -------------------------------
void __edm__Ptr_reco__BasicJet__db_datamem(Reflex::Class*);
void __edm__Ptr_reco__BasicJet__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Ptr_reco__BasicJet__datamem_bld(&__edm__Ptr_reco__BasicJet__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Ptr_reco__BasicJet__funcmem_bld(&__edm__Ptr_reco__BasicJet__db_funcmem);
void __edm__Ptr_reco__BasicJet__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Ptr<reco::BasicJet>"), typeid(::edm::Ptr<reco::BasicJet>), sizeof(::edm::Ptr<reco::BasicJet>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::Ptr<reco::BasicJet>::Class_Version())
  .AddTypedef(type_358, Reflex::Literal("edm::Ptr<reco::BasicJet>::key_type"))
  .AddTypedef(type_7994, Reflex::Literal("edm::Ptr<reco::BasicJet>::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39905, type_39250), Reflex::Literal("operator="), operator_24939, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39250), Reflex::Literal("Ptr"), constructor_24940, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20599, type_358, type_20675), Reflex::Literal("Ptr"), constructor_24941, 0, "productID;itemKey;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20599, type_16732, type_358), Reflex::Literal("Ptr"), constructor_24942, 0, "productID;item;item_key", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20599), Reflex::Literal("Ptr"), constructor_24943, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Ptr"), constructor_24944, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Ptr"), destructor_24945, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4994, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Ptr_reco__BasicJet__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Ptr_reco__BasicJet__funcmem_bld);
}

//------Delayed data member builder for class Ptr<reco::BasicJet> -------------------
void __edm__Ptr_reco__BasicJet__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4935, Reflex::Literal("core_"), OffsetOf(__shadow__::__edm__Ptr_reco__BasicJet_, core_), ::Reflex::PRIVATE)
  .AddDataMember(type_358, Reflex::Literal("key_"), OffsetOf(__shadow__::__edm__Ptr_reco__BasicJet_, key_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Ptr<reco::BasicJet> -------------------
void __edm__Ptr_reco__BasicJet__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16736), Reflex::Literal("operator*"), operator_24946, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16732), Reflex::Literal("operator->"), operator_24947, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16732), Reflex::Literal("get"), method_24948, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isNull"), method_24949, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isNonnull"), method_24950, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("operator!"), operator_24951, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isAvailable"), method_24952, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isTransient"), method_24953, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4933), Reflex::Literal("id"), method_24954, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20675), Reflex::Literal("productGetter"), method_24955, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_358), Reflex::Literal("key"), method_24956, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("hasProductCache"), method_24957, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23940), Reflex::Literal("refCore"), method_24958, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4071), Reflex::Literal("product"), method_24959, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_237), Reflex::Literal("Class_Version"), method_24960, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Ptr<reco::PFJet> -------------------------------
static  void operator_24967( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Ptr<reco::PFJet>*)o)->operator=)(*(const ::edm::Ptr<reco::PFJet>*)arg[0]);
  else   (((::edm::Ptr<reco::PFJet>*)o)->operator=)(*(const ::edm::Ptr<reco::PFJet>*)arg[0]);
}

static void constructor_24968( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<reco::PFJet>(*(const ::edm::Ptr<reco::PFJet>*)arg[0]);
  else ::new(mem) ::edm::Ptr<reco::PFJet>(*(const ::edm::Ptr<reco::PFJet>*)arg[0]);
}

static void constructor_24969( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<reco::PFJet>(*(const ::edm::ProductID*)arg[0],
      *(unsigned long*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
  else ::new(mem) ::edm::Ptr<reco::PFJet>(*(const ::edm::ProductID*)arg[0],
      *(unsigned long*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
}

static void constructor_24970( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<reco::PFJet>(*(const ::edm::ProductID*)arg[0],
      (const ::reco::PFJet*)arg[1],
      *(unsigned long*)arg[2]);
  else ::new(mem) ::edm::Ptr<reco::PFJet>(*(const ::edm::ProductID*)arg[0],
      (const ::reco::PFJet*)arg[1],
      *(unsigned long*)arg[2]);
}

static void constructor_24971( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<reco::PFJet>(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::Ptr<reco::PFJet>(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_24972( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<reco::PFJet>();
  else ::new(mem) ::edm::Ptr<reco::PFJet>();
}

static void destructor_24973(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Ptr<reco::PFJet>*)o)->::edm::Ptr<reco::PFJet>::~Ptr)();
}
static  void operator_24974( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ptr<reco::PFJet>*)o)->operator*)();
  else   (((const ::edm::Ptr<reco::PFJet>*)o)->operator*)();
}

static  void operator_24975( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<reco::PFJet>*)o)->operator->)());
  else   (((const ::edm::Ptr<reco::PFJet>*)o)->operator->)();
}

static  void method_24976( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<reco::PFJet>*)o)->get)());
  else   (((const ::edm::Ptr<reco::PFJet>*)o)->get)();
}

static  void method_24977( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::PFJet>*)o)->isNull)());
  else   (((const ::edm::Ptr<reco::PFJet>*)o)->isNull)();
}

static  void method_24978( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::PFJet>*)o)->isNonnull)());
  else   (((const ::edm::Ptr<reco::PFJet>*)o)->isNonnull)();
}

static  void operator_24979( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::PFJet>*)o)->operator!)());
  else   (((const ::edm::Ptr<reco::PFJet>*)o)->operator!)();
}

static  void method_24980( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::PFJet>*)o)->isAvailable)());
  else   (((const ::edm::Ptr<reco::PFJet>*)o)->isAvailable)();
}

static  void method_24981( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::PFJet>*)o)->isTransient)());
  else   (((const ::edm::Ptr<reco::PFJet>*)o)->isTransient)();
}

static  void method_24982( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::Ptr<reco::PFJet>*)o)->id)());
  else   (((const ::edm::Ptr<reco::PFJet>*)o)->id)();
}

static  void method_24983( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<reco::PFJet>*)o)->productGetter)());
  else   (((const ::edm::Ptr<reco::PFJet>*)o)->productGetter)();
}

static  void method_24984( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long)((((const ::edm::Ptr<reco::PFJet>*)o)->key)());
  else   (((const ::edm::Ptr<reco::PFJet>*)o)->key)();
}

static  void method_24985( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::PFJet>*)o)->hasProductCache)());
  else   (((const ::edm::Ptr<reco::PFJet>*)o)->hasProductCache)();
}

static  void method_24986( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ptr<reco::PFJet>*)o)->refCore)();
  else   (((const ::edm::Ptr<reco::PFJet>*)o)->refCore)();
}

static  void method_24987( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<reco::PFJet>*)o)->product)());
  else   (((const ::edm::Ptr<reco::PFJet>*)o)->product)();
}

static  void method_24988( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::Ptr<reco::PFJet>*)o)->Class_Version)());
  else   (((::edm::Ptr<reco::PFJet>*)o)->Class_Version)();
}

static void method_newdel_4995( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Ptr<reco::PFJet> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Ptr<reco::PFJet> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Ptr<reco::PFJet> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Ptr<reco::PFJet> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Ptr<reco::PFJet> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Ptr<reco::PFJet> -------------------------------
void __edm__Ptr_reco__PFJet__db_datamem(Reflex::Class*);
void __edm__Ptr_reco__PFJet__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Ptr_reco__PFJet__datamem_bld(&__edm__Ptr_reco__PFJet__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Ptr_reco__PFJet__funcmem_bld(&__edm__Ptr_reco__PFJet__db_funcmem);
void __edm__Ptr_reco__PFJet__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Ptr<reco::PFJet>"), typeid(::edm::Ptr<reco::PFJet>), sizeof(::edm::Ptr<reco::PFJet>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::Ptr<reco::PFJet>::Class_Version())
  .AddTypedef(type_358, Reflex::Literal("edm::Ptr<reco::PFJet>::key_type"))
  .AddTypedef(type_7794, Reflex::Literal("edm::Ptr<reco::PFJet>::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39906, type_39253), Reflex::Literal("operator="), operator_24967, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39253), Reflex::Literal("Ptr"), constructor_24968, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20599, type_358, type_20675), Reflex::Literal("Ptr"), constructor_24969, 0, "productID;itemKey;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20599, type_16216, type_358), Reflex::Literal("Ptr"), constructor_24970, 0, "productID;item;item_key", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20599), Reflex::Literal("Ptr"), constructor_24971, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Ptr"), constructor_24972, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Ptr"), destructor_24973, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4995, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Ptr_reco__PFJet__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Ptr_reco__PFJet__funcmem_bld);
}

//------Delayed data member builder for class Ptr<reco::PFJet> -------------------
void __edm__Ptr_reco__PFJet__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4935, Reflex::Literal("core_"), OffsetOf(__shadow__::__edm__Ptr_reco__PFJet_, core_), ::Reflex::PRIVATE)
  .AddDataMember(type_358, Reflex::Literal("key_"), OffsetOf(__shadow__::__edm__Ptr_reco__PFJet_, key_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Ptr<reco::PFJet> -------------------
void __edm__Ptr_reco__PFJet__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16220), Reflex::Literal("operator*"), operator_24974, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16216), Reflex::Literal("operator->"), operator_24975, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16216), Reflex::Literal("get"), method_24976, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isNull"), method_24977, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isNonnull"), method_24978, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("operator!"), operator_24979, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isAvailable"), method_24980, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isTransient"), method_24981, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4933), Reflex::Literal("id"), method_24982, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20675), Reflex::Literal("productGetter"), method_24983, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_358), Reflex::Literal("key"), method_24984, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("hasProductCache"), method_24985, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23940), Reflex::Literal("refCore"), method_24986, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4071), Reflex::Literal("product"), method_24987, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_237), Reflex::Literal("Class_Version"), method_24988, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Ptr<reco::CaloJet> -------------------------------
static  void operator_25023( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Ptr<reco::CaloJet>*)o)->operator=)(*(const ::edm::Ptr<reco::CaloJet>*)arg[0]);
  else   (((::edm::Ptr<reco::CaloJet>*)o)->operator=)(*(const ::edm::Ptr<reco::CaloJet>*)arg[0]);
}

static void constructor_25024( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<reco::CaloJet>(*(const ::edm::Ptr<reco::CaloJet>*)arg[0]);
  else ::new(mem) ::edm::Ptr<reco::CaloJet>(*(const ::edm::Ptr<reco::CaloJet>*)arg[0]);
}

static void constructor_25025( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<reco::CaloJet>(*(const ::edm::ProductID*)arg[0],
      *(unsigned long*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
  else ::new(mem) ::edm::Ptr<reco::CaloJet>(*(const ::edm::ProductID*)arg[0],
      *(unsigned long*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
}

static void constructor_25026( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<reco::CaloJet>(*(const ::edm::ProductID*)arg[0],
      (const ::reco::CaloJet*)arg[1],
      *(unsigned long*)arg[2]);
  else ::new(mem) ::edm::Ptr<reco::CaloJet>(*(const ::edm::ProductID*)arg[0],
      (const ::reco::CaloJet*)arg[1],
      *(unsigned long*)arg[2]);
}

static void constructor_25027( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<reco::CaloJet>(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::Ptr<reco::CaloJet>(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_25028( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<reco::CaloJet>();
  else ::new(mem) ::edm::Ptr<reco::CaloJet>();
}

static void destructor_25029(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Ptr<reco::CaloJet>*)o)->::edm::Ptr<reco::CaloJet>::~Ptr)();
}
static  void operator_25030( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ptr<reco::CaloJet>*)o)->operator*)();
  else   (((const ::edm::Ptr<reco::CaloJet>*)o)->operator*)();
}

static  void operator_25031( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<reco::CaloJet>*)o)->operator->)());
  else   (((const ::edm::Ptr<reco::CaloJet>*)o)->operator->)();
}

static  void method_25032( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<reco::CaloJet>*)o)->get)());
  else   (((const ::edm::Ptr<reco::CaloJet>*)o)->get)();
}

static  void method_25033( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::CaloJet>*)o)->isNull)());
  else   (((const ::edm::Ptr<reco::CaloJet>*)o)->isNull)();
}

static  void method_25034( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::CaloJet>*)o)->isNonnull)());
  else   (((const ::edm::Ptr<reco::CaloJet>*)o)->isNonnull)();
}

static  void operator_25035( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::CaloJet>*)o)->operator!)());
  else   (((const ::edm::Ptr<reco::CaloJet>*)o)->operator!)();
}

static  void method_25036( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::CaloJet>*)o)->isAvailable)());
  else   (((const ::edm::Ptr<reco::CaloJet>*)o)->isAvailable)();
}

static  void method_25037( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::CaloJet>*)o)->isTransient)());
  else   (((const ::edm::Ptr<reco::CaloJet>*)o)->isTransient)();
}

static  void method_25038( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::Ptr<reco::CaloJet>*)o)->id)());
  else   (((const ::edm::Ptr<reco::CaloJet>*)o)->id)();
}

static  void method_25039( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<reco::CaloJet>*)o)->productGetter)());
  else   (((const ::edm::Ptr<reco::CaloJet>*)o)->productGetter)();
}

static  void method_25040( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long)((((const ::edm::Ptr<reco::CaloJet>*)o)->key)());
  else   (((const ::edm::Ptr<reco::CaloJet>*)o)->key)();
}

static  void method_25041( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::CaloJet>*)o)->hasProductCache)());
  else   (((const ::edm::Ptr<reco::CaloJet>*)o)->hasProductCache)();
}

static  void method_25042( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ptr<reco::CaloJet>*)o)->refCore)();
  else   (((const ::edm::Ptr<reco::CaloJet>*)o)->refCore)();
}

static  void method_25043( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<reco::CaloJet>*)o)->product)());
  else   (((const ::edm::Ptr<reco::CaloJet>*)o)->product)();
}

static  void method_25044( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::Ptr<reco::CaloJet>*)o)->Class_Version)());
  else   (((::edm::Ptr<reco::CaloJet>*)o)->Class_Version)();
}

static void method_newdel_4997( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Ptr<reco::CaloJet> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Ptr<reco::CaloJet> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Ptr<reco::CaloJet> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Ptr<reco::CaloJet> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Ptr<reco::CaloJet> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Ptr<reco::CaloJet> -------------------------------
void __edm__Ptr_reco__CaloJet__db_datamem(Reflex::Class*);
void __edm__Ptr_reco__CaloJet__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Ptr_reco__CaloJet__datamem_bld(&__edm__Ptr_reco__CaloJet__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Ptr_reco__CaloJet__funcmem_bld(&__edm__Ptr_reco__CaloJet__db_funcmem);
void __edm__Ptr_reco__CaloJet__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Ptr<reco::CaloJet>"), typeid(::edm::Ptr<reco::CaloJet>), sizeof(::edm::Ptr<reco::CaloJet>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::Ptr<reco::CaloJet>::Class_Version())
  .AddTypedef(type_358, Reflex::Literal("edm::Ptr<reco::CaloJet>::key_type"))
  .AddTypedef(type_7818, Reflex::Literal("edm::Ptr<reco::CaloJet>::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39908, type_39259), Reflex::Literal("operator="), operator_25023, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39259), Reflex::Literal("Ptr"), constructor_25024, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20599, type_358, type_20675), Reflex::Literal("Ptr"), constructor_25025, 0, "productID;itemKey;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20599, type_16604, type_358), Reflex::Literal("Ptr"), constructor_25026, 0, "productID;item;item_key", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20599), Reflex::Literal("Ptr"), constructor_25027, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Ptr"), constructor_25028, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Ptr"), destructor_25029, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4997, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Ptr_reco__CaloJet__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Ptr_reco__CaloJet__funcmem_bld);
}

//------Delayed data member builder for class Ptr<reco::CaloJet> -------------------
void __edm__Ptr_reco__CaloJet__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4935, Reflex::Literal("core_"), OffsetOf(__shadow__::__edm__Ptr_reco__CaloJet_, core_), ::Reflex::PRIVATE)
  .AddDataMember(type_358, Reflex::Literal("key_"), OffsetOf(__shadow__::__edm__Ptr_reco__CaloJet_, key_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Ptr<reco::CaloJet> -------------------
void __edm__Ptr_reco__CaloJet__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16608), Reflex::Literal("operator*"), operator_25030, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16604), Reflex::Literal("operator->"), operator_25031, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16604), Reflex::Literal("get"), method_25032, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isNull"), method_25033, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isNonnull"), method_25034, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("operator!"), operator_25035, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isAvailable"), method_25036, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isTransient"), method_25037, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4933), Reflex::Literal("id"), method_25038, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20675), Reflex::Literal("productGetter"), method_25039, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_358), Reflex::Literal("key"), method_25040, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("hasProductCache"), method_25041, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23940), Reflex::Literal("refCore"), method_25042, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4071), Reflex::Literal("product"), method_25043, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_237), Reflex::Literal("Class_Version"), method_25044, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Ptr<reco::Jet> -------------------------------
static  void operator_25051( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Ptr<reco::Jet>*)o)->operator=)(*(const ::edm::Ptr<reco::Jet>*)arg[0]);
  else   (((::edm::Ptr<reco::Jet>*)o)->operator=)(*(const ::edm::Ptr<reco::Jet>*)arg[0]);
}

static void constructor_25052( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<reco::Jet>(*(const ::edm::Ptr<reco::Jet>*)arg[0]);
  else ::new(mem) ::edm::Ptr<reco::Jet>(*(const ::edm::Ptr<reco::Jet>*)arg[0]);
}

static void constructor_25053( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<reco::Jet>(*(const ::edm::ProductID*)arg[0],
      *(unsigned long*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
  else ::new(mem) ::edm::Ptr<reco::Jet>(*(const ::edm::ProductID*)arg[0],
      *(unsigned long*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
}

static void constructor_25054( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<reco::Jet>(*(const ::edm::ProductID*)arg[0],
      (const ::reco::Jet*)arg[1],
      *(unsigned long*)arg[2]);
  else ::new(mem) ::edm::Ptr<reco::Jet>(*(const ::edm::ProductID*)arg[0],
      (const ::reco::Jet*)arg[1],
      *(unsigned long*)arg[2]);
}

static void constructor_25055( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<reco::Jet>(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::Ptr<reco::Jet>(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_25056( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<reco::Jet>();
  else ::new(mem) ::edm::Ptr<reco::Jet>();
}

static void destructor_25057(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Ptr<reco::Jet>*)o)->::edm::Ptr<reco::Jet>::~Ptr)();
}
static  void operator_25058( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ptr<reco::Jet>*)o)->operator*)();
  else   (((const ::edm::Ptr<reco::Jet>*)o)->operator*)();
}

static  void operator_25059( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<reco::Jet>*)o)->operator->)());
  else   (((const ::edm::Ptr<reco::Jet>*)o)->operator->)();
}

static  void method_25060( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<reco::Jet>*)o)->get)());
  else   (((const ::edm::Ptr<reco::Jet>*)o)->get)();
}

static  void method_25061( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::Jet>*)o)->isNull)());
  else   (((const ::edm::Ptr<reco::Jet>*)o)->isNull)();
}

static  void method_25062( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::Jet>*)o)->isNonnull)());
  else   (((const ::edm::Ptr<reco::Jet>*)o)->isNonnull)();
}

static  void operator_25063( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::Jet>*)o)->operator!)());
  else   (((const ::edm::Ptr<reco::Jet>*)o)->operator!)();
}

static  void method_25064( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::Jet>*)o)->isAvailable)());
  else   (((const ::edm::Ptr<reco::Jet>*)o)->isAvailable)();
}

static  void method_25065( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::Jet>*)o)->isTransient)());
  else   (((const ::edm::Ptr<reco::Jet>*)o)->isTransient)();
}

static  void method_25066( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::Ptr<reco::Jet>*)o)->id)());
  else   (((const ::edm::Ptr<reco::Jet>*)o)->id)();
}

static  void method_25067( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<reco::Jet>*)o)->productGetter)());
  else   (((const ::edm::Ptr<reco::Jet>*)o)->productGetter)();
}

static  void method_25068( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long)((((const ::edm::Ptr<reco::Jet>*)o)->key)());
  else   (((const ::edm::Ptr<reco::Jet>*)o)->key)();
}

static  void method_25069( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::Jet>*)o)->hasProductCache)());
  else   (((const ::edm::Ptr<reco::Jet>*)o)->hasProductCache)();
}

static  void method_25070( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ptr<reco::Jet>*)o)->refCore)();
  else   (((const ::edm::Ptr<reco::Jet>*)o)->refCore)();
}

static  void method_25071( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<reco::Jet>*)o)->product)());
  else   (((const ::edm::Ptr<reco::Jet>*)o)->product)();
}

static  void method_25072( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::Ptr<reco::Jet>*)o)->Class_Version)());
  else   (((::edm::Ptr<reco::Jet>*)o)->Class_Version)();
}

static void method_newdel_4998( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Ptr<reco::Jet> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Ptr<reco::Jet> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Ptr<reco::Jet> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Ptr<reco::Jet> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Ptr<reco::Jet> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Ptr<reco::Jet> -------------------------------
void __edm__Ptr_reco__Jet__db_datamem(Reflex::Class*);
void __edm__Ptr_reco__Jet__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Ptr_reco__Jet__datamem_bld(&__edm__Ptr_reco__Jet__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Ptr_reco__Jet__funcmem_bld(&__edm__Ptr_reco__Jet__db_funcmem);
void __edm__Ptr_reco__Jet__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Ptr<reco::Jet>"), typeid(::edm::Ptr<reco::Jet>), sizeof(::edm::Ptr<reco::Jet>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::Ptr<reco::Jet>::Class_Version())
  .AddTypedef(type_358, Reflex::Literal("edm::Ptr<reco::Jet>::key_type"))
  .AddTypedef(type_7843, Reflex::Literal("edm::Ptr<reco::Jet>::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39909, type_39262), Reflex::Literal("operator="), operator_25051, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39262), Reflex::Literal("Ptr"), constructor_25052, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20599, type_358, type_20675), Reflex::Literal("Ptr"), constructor_25053, 0, "productID;itemKey;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20599, type_14466, type_358), Reflex::Literal("Ptr"), constructor_25054, 0, "productID;item;item_key", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20599), Reflex::Literal("Ptr"), constructor_25055, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Ptr"), constructor_25056, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Ptr"), destructor_25057, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4998, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Ptr_reco__Jet__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Ptr_reco__Jet__funcmem_bld);
}

//------Delayed data member builder for class Ptr<reco::Jet> -------------------
void __edm__Ptr_reco__Jet__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4935, Reflex::Literal("core_"), OffsetOf(__shadow__::__edm__Ptr_reco__Jet_, core_), ::Reflex::PRIVATE)
  .AddDataMember(type_358, Reflex::Literal("key_"), OffsetOf(__shadow__::__edm__Ptr_reco__Jet_, key_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Ptr<reco::Jet> -------------------
void __edm__Ptr_reco__Jet__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24098), Reflex::Literal("operator*"), operator_25058, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14466), Reflex::Literal("operator->"), operator_25059, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14466), Reflex::Literal("get"), method_25060, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isNull"), method_25061, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isNonnull"), method_25062, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("operator!"), operator_25063, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isAvailable"), method_25064, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isTransient"), method_25065, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4933), Reflex::Literal("id"), method_25066, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20675), Reflex::Literal("productGetter"), method_25067, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_358), Reflex::Literal("key"), method_25068, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("hasProductCache"), method_25069, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23940), Reflex::Literal("refCore"), method_25070, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4071), Reflex::Literal("product"), method_25071, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_237), Reflex::Literal("Class_Version"), method_25072, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Ref<std::vector<reco::CastorJetID, std::allocator<reco::CastorJetID> >,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID, std::allocator<reco::CastorJetID> >, reco::CastorJetID> > -------------------------------
static  void operator_25496( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->operator=)(*(const ::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)arg[0]);
  else   (((::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->operator=)(*(const ::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)arg[0]);
}

static void constructor_25497( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >(*(const ::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)arg[0]);
  else ::new(mem) ::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >(*(const ::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)arg[0]);
}

static void constructor_25498( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >();
  else ::new(mem) ::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >();
}

static void constructor_25499( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >(*(const ::edm::Handle<std::vector<reco::CastorJetID> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >(*(const ::edm::Handle<std::vector<reco::CastorJetID> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >(*(const ::edm::Handle<std::vector<reco::CastorJetID> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >(*(const ::edm::Handle<std::vector<reco::CastorJetID> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_25500( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >(*(const ::edm::OrphanHandle<std::vector<reco::CastorJetID> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >(*(const ::edm::OrphanHandle<std::vector<reco::CastorJetID> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >(*(const ::edm::OrphanHandle<std::vector<reco::CastorJetID> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >(*(const ::edm::OrphanHandle<std::vector<reco::CastorJetID> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_25501( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >(*(const ::edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >(*(const ::edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >(*(const ::edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >(*(const ::edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_25502( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >((const ::std::vector<reco::CastorJetID>*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >((const ::std::vector<reco::CastorJetID>*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >((const ::std::vector<reco::CastorJetID>*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >((const ::std::vector<reco::CastorJetID>*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_25503( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >(*(const ::edm::TestHandle<std::vector<reco::CastorJetID> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >(*(const ::edm::TestHandle<std::vector<reco::CastorJetID> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >(*(const ::edm::TestHandle<std::vector<reco::CastorJetID> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >(*(const ::edm::TestHandle<std::vector<reco::CastorJetID> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_25504( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >(*(const ::edm::ProductID*)arg[0],
      *(unsigned int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >(*(const ::edm::ProductID*)arg[0],
      *(unsigned int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
}

static void constructor_25505( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >(*(const ::edm::ProductID*)arg[0],
      (const ::reco::CastorJetID*)arg[1],
      *(unsigned int*)arg[2],
      (const ::std::vector<reco::CastorJetID>*)arg[3]);
  else ::new(mem) ::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >(*(const ::edm::ProductID*)arg[0],
      (const ::reco::CastorJetID*)arg[1],
      *(unsigned int*)arg[2],
      (const ::std::vector<reco::CastorJetID>*)arg[3]);
}

static void constructor_25506( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_25507( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >(*(const ::edm::RefProd<std::vector<reco::CastorJetID> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >(*(const ::edm::RefProd<std::vector<reco::CastorJetID> >*)arg[0],
      *(unsigned int*)arg[1]);
}

static void destructor_25508(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >::~Ref)();
}
static  void operator_25509( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->operator*)();
  else   (((const ::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->operator*)();
}

static  void operator_25510( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->operator->)());
  else   (((const ::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->operator->)();
}

static  void method_25511( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->get)());
  else   (((const ::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->get)();
}

static  void method_25512( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->isNull)());
  else   (((const ::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->isNull)();
}

static  void method_25513( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->isNonnull)());
  else   (((const ::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->isNonnull)();
}

static  void operator_25514( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->operator!)());
  else   (((const ::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->operator!)();
}

static  void method_25515( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->id)());
  else   (((const ::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->id)();
}

static  void method_25516( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->productGetter)());
  else   (((const ::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->productGetter)();
}

static  void method_25517( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->product)());
  else   (((const ::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->product)();
}

static  void method_25518( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->key)());
  else   (((const ::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->key)();
}

static  void method_25519( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->index)());
  else   (((const ::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->index)();
}

static  void method_25520( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->hasProductCache)());
  else   (((const ::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->hasProductCache)();
}

static  void method_25521( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->isAvailable)());
  else   (((const ::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->isAvailable)();
}

static  void method_25522( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->isTransient)());
  else   (((const ::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->isTransient)();
}

static  void method_25523( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->refCore)();
  else   (((const ::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->refCore)();
}

static  void method_25524( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->Class_Version)());
  else   (((::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >*)o)->Class_Version)();
}

static void constructor_25525( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >(*(const ::edm::RefCore*)arg[0],
      *(const unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >(*(const ::edm::RefCore*)arg[0],
      *(const unsigned int*)arg[1]);
}

static void method_newdel_5025( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Ref<std::vector<reco::CastorJetID, std::allocator<reco::CastorJetID> >,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID, std::allocator<reco::CastorJetID> >, reco::CastorJetID> > -------------------------------
void __edm__Ref_std__vector_reco__CastorJetID__reco__CastorJetID_edm__refhelper__FindUsingAdvance_std__vector_reco__CastorJetID__reco__CastorJetID_s__db_datamem(Reflex::Class*);
void __edm__Ref_std__vector_reco__CastorJetID__reco__CastorJetID_edm__refhelper__FindUsingAdvance_std__vector_reco__CastorJetID__reco__CastorJetID_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Ref_std__vector_reco__CastorJetID__reco__CastorJetID_edm__refhelper__FindUsingAdvance_std__vector_reco__CastorJetID__reco__CastorJetID_s__datamem_bld(&__edm__Ref_std__vector_reco__CastorJetID__reco__CastorJetID_edm__refhelper__FindUsingAdvance_std__vector_reco__CastorJetID__reco__CastorJetID_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Ref_std__vector_reco__CastorJetID__reco__CastorJetID_edm__refhelper__FindUsingAdvance_std__vector_reco__CastorJetID__reco__CastorJetID_s__funcmem_bld(&__edm__Ref_std__vector_reco__CastorJetID__reco__CastorJetID_edm__refhelper__FindUsingAdvance_std__vector_reco__CastorJetID__reco__CastorJetID_s__db_funcmem);
void __edm__Ref_std__vector_reco__CastorJetID__reco__CastorJetID_edm__refhelper__FindUsingAdvance_std__vector_reco__CastorJetID__reco__CastorJetID_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >"), typeid(::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >), sizeof(::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >::Class_Version())
  .AddTypedef(type_7846, Reflex::Literal("edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >::T"))
  .AddTypedef(type_20853, Reflex::Literal("edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >::F"))
  .AddTypedef(type_22259, Reflex::Literal("edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >::VF"))
  .AddTypedef(type_22258, Reflex::Literal("edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >::VBF"))
  .AddTypedef(type_2999, Reflex::Literal("edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >::product_type"))
  .AddTypedef(type_7846, Reflex::Literal("edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >::value_type"))
  .AddTypedef(type_7846c, Reflex::Literal("edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >::element_type"))
  .AddTypedef(type_20853, Reflex::Literal("edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >::finder_type"))
  .AddTypedef(type_366, Reflex::Literal("edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >::argument_type"))
  .AddTypedef(type_366, Reflex::Literal("edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> >::key_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39931, type_39296), Reflex::Literal("operator="), operator_25496, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39296), Reflex::Literal("Ref"), constructor_25497, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Ref"), constructor_25498, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39864, type_366, type_1566), Reflex::Literal("Ref"), constructor_25499, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39865, type_366, type_1566), Reflex::Literal("Ref"), constructor_25500, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39295, type_366, type_1566), Reflex::Literal("Ref"), constructor_25501, 0, "refvector;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39297, type_366, type_1566), Reflex::Literal("Ref"), constructor_25502, 0, "iProduct;iItemKey;iSetNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39866, type_366, type_1566), Reflex::Literal("Ref"), constructor_25503, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20599, type_366, type_20675), Reflex::Literal("Ref"), constructor_25504, 0, "productID;itemKey;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20599, type_14538, type_366, type_39297), Reflex::Literal("Ref"), constructor_25505, 0, "iProductID;;iItemKey;iProduct", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20599), Reflex::Literal("Ref"), constructor_25506, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39863, type_366), Reflex::Literal("Ref"), constructor_25507, 0, "refProd;itemKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Ref"), destructor_25508, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23940, type_10985), Reflex::Literal("Ref"), constructor_25525, 0, "iRefCore;iKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_5025, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Ref_std__vector_reco__CastorJetID__reco__CastorJetID_edm__refhelper__FindUsingAdvance_std__vector_reco__CastorJetID__reco__CastorJetID_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Ref_std__vector_reco__CastorJetID__reco__CastorJetID_edm__refhelper__FindUsingAdvance_std__vector_reco__CastorJetID__reco__CastorJetID_s__funcmem_bld);
}

//------Delayed data member builder for class Ref<std::vector<reco::CastorJetID, std::allocator<reco::CastorJetID> >,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID, std::allocator<reco::CastorJetID> >, reco::CastorJetID> > -------------------
void __edm__Ref_std__vector_reco__CastorJetID__reco__CastorJetID_edm__refhelper__FindUsingAdvance_std__vector_reco__CastorJetID__reco__CastorJetID_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4624, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__Ref_std__vector_reco__CastorJetID__reco__CastorJetID_edm__refhelper__FindUsingAdvance_std__vector_reco__CastorJetID__reco__CastorJetID_s_, product_), ::Reflex::PRIVATE | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class Ref<std::vector<reco::CastorJetID, std::allocator<reco::CastorJetID> >,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID, std::allocator<reco::CastorJetID> >, reco::CastorJetID> > -------------------
void __edm__Ref_std__vector_reco__CastorJetID__reco__CastorJetID_edm__refhelper__FindUsingAdvance_std__vector_reco__CastorJetID__reco__CastorJetID_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14542), Reflex::Literal("operator*"), operator_25509, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14538), Reflex::Literal("operator->"), operator_25510, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14538), Reflex::Literal("get"), method_25511, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isNull"), method_25512, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isNonnull"), method_25513, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("operator!"), operator_25514, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4933), Reflex::Literal("id"), method_25515, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20675), Reflex::Literal("productGetter"), method_25516, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39297), Reflex::Literal("product"), method_25517, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_366), Reflex::Literal("key"), method_25518, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_366), Reflex::Literal("index"), method_25519, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("hasProductCache"), method_25520, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isAvailable"), method_25521, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isTransient"), method_25522, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23940), Reflex::Literal("refCore"), method_25523, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_237), Reflex::Literal("Class_Version"), method_25524, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Ref<std::vector<reco::JetID, std::allocator<reco::JetID> >,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID, std::allocator<reco::JetID> >, reco::JetID> > -------------------------------
static  void operator_25538( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->operator=)(*(const ::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)arg[0]);
  else   (((::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->operator=)(*(const ::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)arg[0]);
}

static void constructor_25539( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >(*(const ::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)arg[0]);
  else ::new(mem) ::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >(*(const ::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)arg[0]);
}

static void constructor_25540( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >();
  else ::new(mem) ::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >();
}

static void constructor_25541( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >(*(const ::edm::Handle<std::vector<reco::JetID> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >(*(const ::edm::Handle<std::vector<reco::JetID> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >(*(const ::edm::Handle<std::vector<reco::JetID> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >(*(const ::edm::Handle<std::vector<reco::JetID> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_25542( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >(*(const ::edm::OrphanHandle<std::vector<reco::JetID> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >(*(const ::edm::OrphanHandle<std::vector<reco::JetID> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >(*(const ::edm::OrphanHandle<std::vector<reco::JetID> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >(*(const ::edm::OrphanHandle<std::vector<reco::JetID> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_25543( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >(*(const ::edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >(*(const ::edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >(*(const ::edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >(*(const ::edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_25544( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >((const ::std::vector<reco::JetID>*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >((const ::std::vector<reco::JetID>*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >((const ::std::vector<reco::JetID>*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >((const ::std::vector<reco::JetID>*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_25545( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >(*(const ::edm::TestHandle<std::vector<reco::JetID> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >(*(const ::edm::TestHandle<std::vector<reco::JetID> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >(*(const ::edm::TestHandle<std::vector<reco::JetID> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >(*(const ::edm::TestHandle<std::vector<reco::JetID> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_25546( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >(*(const ::edm::ProductID*)arg[0],
      *(unsigned int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >(*(const ::edm::ProductID*)arg[0],
      *(unsigned int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
}

static void constructor_25547( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >(*(const ::edm::ProductID*)arg[0],
      (const ::reco::JetID*)arg[1],
      *(unsigned int*)arg[2],
      (const ::std::vector<reco::JetID>*)arg[3]);
  else ::new(mem) ::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >(*(const ::edm::ProductID*)arg[0],
      (const ::reco::JetID*)arg[1],
      *(unsigned int*)arg[2],
      (const ::std::vector<reco::JetID>*)arg[3]);
}

static void constructor_25548( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_25549( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >(*(const ::edm::RefProd<std::vector<reco::JetID> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >(*(const ::edm::RefProd<std::vector<reco::JetID> >*)arg[0],
      *(unsigned int*)arg[1]);
}

static void destructor_25550(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >::~Ref)();
}
static  void operator_25551( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->operator*)();
  else   (((const ::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->operator*)();
}

static  void operator_25552( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->operator->)());
  else   (((const ::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->operator->)();
}

static  void method_25553( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->get)());
  else   (((const ::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->get)();
}

static  void method_25554( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->isNull)());
  else   (((const ::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->isNull)();
}

static  void method_25555( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->isNonnull)());
  else   (((const ::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->isNonnull)();
}

static  void operator_25556( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->operator!)());
  else   (((const ::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->operator!)();
}

static  void method_25557( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->id)());
  else   (((const ::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->id)();
}

static  void method_25558( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->productGetter)());
  else   (((const ::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->productGetter)();
}

static  void method_25559( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->product)());
  else   (((const ::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->product)();
}

static  void method_25560( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->key)());
  else   (((const ::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->key)();
}

static  void method_25561( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->index)());
  else   (((const ::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->index)();
}

static  void method_25562( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->hasProductCache)());
  else   (((const ::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->hasProductCache)();
}

static  void method_25563( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->isAvailable)());
  else   (((const ::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->isAvailable)();
}

static  void method_25564( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->isTransient)());
  else   (((const ::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->isTransient)();
}

static  void method_25565( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->refCore)();
  else   (((const ::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->refCore)();
}

static  void method_25566( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->Class_Version)());
  else   (((::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >*)o)->Class_Version)();
}

static void constructor_25567( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >(*(const ::edm::RefCore*)arg[0],
      *(const unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >(*(const ::edm::RefCore*)arg[0],
      *(const unsigned int*)arg[1]);
}

static void method_newdel_5026( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Ref<std::vector<reco::JetID, std::allocator<reco::JetID> >,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID, std::allocator<reco::JetID> >, reco::JetID> > -------------------------------
void __edm__Ref_std__vector_reco__JetID__reco__JetID_edm__refhelper__FindUsingAdvance_std__vector_reco__JetID__reco__JetID_s__db_datamem(Reflex::Class*);
void __edm__Ref_std__vector_reco__JetID__reco__JetID_edm__refhelper__FindUsingAdvance_std__vector_reco__JetID__reco__JetID_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Ref_std__vector_reco__JetID__reco__JetID_edm__refhelper__FindUsingAdvance_std__vector_reco__JetID__reco__JetID_s__datamem_bld(&__edm__Ref_std__vector_reco__JetID__reco__JetID_edm__refhelper__FindUsingAdvance_std__vector_reco__JetID__reco__JetID_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Ref_std__vector_reco__JetID__reco__JetID_edm__refhelper__FindUsingAdvance_std__vector_reco__JetID__reco__JetID_s__funcmem_bld(&__edm__Ref_std__vector_reco__JetID__reco__JetID_edm__refhelper__FindUsingAdvance_std__vector_reco__JetID__reco__JetID_s__db_funcmem);
void __edm__Ref_std__vector_reco__JetID__reco__JetID_edm__refhelper__FindUsingAdvance_std__vector_reco__JetID__reco__JetID_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >"), typeid(::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >), sizeof(::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >::Class_Version())
  .AddTypedef(type_7841, Reflex::Literal("edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >::T"))
  .AddTypedef(type_20865, Reflex::Literal("edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >::F"))
  .AddTypedef(type_22261, Reflex::Literal("edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >::VF"))
  .AddTypedef(type_22260, Reflex::Literal("edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >::VBF"))
  .AddTypedef(type_3000, Reflex::Literal("edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >::product_type"))
  .AddTypedef(type_7841, Reflex::Literal("edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >::value_type"))
  .AddTypedef(type_7841c, Reflex::Literal("edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >::element_type"))
  .AddTypedef(type_20865, Reflex::Literal("edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >::finder_type"))
  .AddTypedef(type_366, Reflex::Literal("edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >::argument_type"))
  .AddTypedef(type_366, Reflex::Literal("edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> >::key_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39932, type_39302), Reflex::Literal("operator="), operator_25538, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39302), Reflex::Literal("Ref"), constructor_25539, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Ref"), constructor_25540, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39869, type_366, type_1566), Reflex::Literal("Ref"), constructor_25541, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39870, type_366, type_1566), Reflex::Literal("Ref"), constructor_25542, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39301, type_366, type_1566), Reflex::Literal("Ref"), constructor_25543, 0, "refvector;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39303, type_366, type_1566), Reflex::Literal("Ref"), constructor_25544, 0, "iProduct;iItemKey;iSetNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39871, type_366, type_1566), Reflex::Literal("Ref"), constructor_25545, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20599, type_366, type_20675), Reflex::Literal("Ref"), constructor_25546, 0, "productID;itemKey;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20599, type_14603, type_366, type_39303), Reflex::Literal("Ref"), constructor_25547, 0, "iProductID;;iItemKey;iProduct", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20599), Reflex::Literal("Ref"), constructor_25548, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39868, type_366), Reflex::Literal("Ref"), constructor_25549, 0, "refProd;itemKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Ref"), destructor_25550, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23940, type_10985), Reflex::Literal("Ref"), constructor_25567, 0, "iRefCore;iKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_5026, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Ref_std__vector_reco__JetID__reco__JetID_edm__refhelper__FindUsingAdvance_std__vector_reco__JetID__reco__JetID_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Ref_std__vector_reco__JetID__reco__JetID_edm__refhelper__FindUsingAdvance_std__vector_reco__JetID__reco__JetID_s__funcmem_bld);
}

//------Delayed data member builder for class Ref<std::vector<reco::JetID, std::allocator<reco::JetID> >,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID, std::allocator<reco::JetID> >, reco::JetID> > -------------------
void __edm__Ref_std__vector_reco__JetID__reco__JetID_edm__refhelper__FindUsingAdvance_std__vector_reco__JetID__reco__JetID_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4624, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__Ref_std__vector_reco__JetID__reco__JetID_edm__refhelper__FindUsingAdvance_std__vector_reco__JetID__reco__JetID_s_, product_), ::Reflex::PRIVATE | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class Ref<std::vector<reco::JetID, std::allocator<reco::JetID> >,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID, std::allocator<reco::JetID> >, reco::JetID> > -------------------
void __edm__Ref_std__vector_reco__JetID__reco__JetID_edm__refhelper__FindUsingAdvance_std__vector_reco__JetID__reco__JetID_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14607), Reflex::Literal("operator*"), operator_25551, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14603), Reflex::Literal("operator->"), operator_25552, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14603), Reflex::Literal("get"), method_25553, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isNull"), method_25554, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isNonnull"), method_25555, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("operator!"), operator_25556, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4933), Reflex::Literal("id"), method_25557, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20675), Reflex::Literal("productGetter"), method_25558, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39303), Reflex::Literal("product"), method_25559, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_366), Reflex::Literal("key"), method_25560, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_366), Reflex::Literal("index"), method_25561, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("hasProductCache"), method_25562, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isAvailable"), method_25563, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isTransient"), method_25564, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23940), Reflex::Literal("refCore"), method_25565, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_237), Reflex::Literal("Class_Version"), method_25566, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class CATopJetTagInfo -------------------------------
static  void operator_27638( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::reco::CATopJetTagInfo*)o)->operator=)(*(const ::reco::CATopJetTagInfo*)arg[0]);
  else   (((::reco::CATopJetTagInfo*)o)->operator=)(*(const ::reco::CATopJetTagInfo*)arg[0]);
}

static void constructor_27639( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::CATopJetTagInfo(*(const ::reco::CATopJetTagInfo*)arg[0]);
  else ::new(mem) ::reco::CATopJetTagInfo(*(const ::reco::CATopJetTagInfo*)arg[0]);
}

static void constructor_27640( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::CATopJetTagInfo();
  else ::new(mem) ::reco::CATopJetTagInfo();
}

static void destructor_27641(void*, void * o, const std::vector<void*>&, void *) {
(((::reco::CATopJetTagInfo*)o)->::reco::CATopJetTagInfo::~CATopJetTagInfo)();
}
static  void method_27642( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::reco::CATopJetTagInfo*)o)->clone)());
  else   (((const ::reco::CATopJetTagInfo*)o)->clone)();
}

static  void method_27643( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::reco::CATopJetTagInfo*)o)->properties)();
  else   (((const ::reco::CATopJetTagInfo*)o)->properties)();
}

static  void method_27644( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::reco::CATopJetTagInfo*)o)->insert)(*(const ::edm::RefToBase<reco::Jet>*)arg[0],
    *(const ::reco::CATopJetProperties*)arg[1]);
}

static void method_newdel_7813( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::reco::CATopJetTagInfo >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::reco::CATopJetTagInfo >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::reco::CATopJetTagInfo >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::reco::CATopJetTagInfo >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::reco::CATopJetTagInfo >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x90( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::JetTagInfo")), ::Reflex::BaseOffset< ::reco::CATopJetTagInfo,::reco::JetTagInfo >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::BaseTagInfo")), ::Reflex::BaseOffset< ::reco::CATopJetTagInfo,::reco::BaseTagInfo >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class CATopJetTagInfo -------------------------------
void __reco__CATopJetTagInfo_db_datamem(Reflex::Class*);
void __reco__CATopJetTagInfo_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __reco__CATopJetTagInfo_datamem_bld(&__reco__CATopJetTagInfo_db_datamem);
Reflex::GenreflexMemberBuilder __reco__CATopJetTagInfo_funcmem_bld(&__reco__CATopJetTagInfo_db_funcmem);
void __reco__CATopJetTagInfo_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("reco::CATopJetTagInfo"), typeid(::reco::CATopJetTagInfo), sizeof(::reco::CATopJetTagInfo), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddBase(type_7991, ::Reflex::BaseOffset< ::reco::CATopJetTagInfo, ::reco::JetTagInfo >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_4978, Reflex::Literal("reco::CATopJetTagInfo::jet_type"))
  .AddTypedef(type_7826, Reflex::Literal("reco::CATopJetTagInfo::properties_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13241, type_13243), Reflex::Literal("operator="), operator_27638, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13243), Reflex::Literal("CATopJetTagInfo"), constructor_27639, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("CATopJetTagInfo"), constructor_27640, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~CATopJetTagInfo"), destructor_27641, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_7813, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x90, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__reco__CATopJetTagInfo_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__reco__CATopJetTagInfo_funcmem_bld);
}

//------Delayed data member builder for class CATopJetTagInfo -------------------
void __reco__CATopJetTagInfo_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_7826, Reflex::Literal("properties_"), OffsetOf(__shadow__::__reco__CATopJetTagInfo, properties_), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class CATopJetTagInfo -------------------
void __reco__CATopJetTagInfo_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9609), Reflex::Literal("clone"), method_27642, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35928), Reflex::Literal("properties"), method_27643, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_35927, type_35928), Reflex::Literal("insert"), method_27644, 0, "jet;properties", ::Reflex::PUBLIC);
}
//------Stub functions for class CATopJetProperties -------------------------------
static void destructor_27766(void*, void * o, const std::vector<void*>&, void *) {
(((::reco::CATopJetProperties*)o)->::reco::CATopJetProperties::~CATopJetProperties)();
}
static  void operator_27767( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::reco::CATopJetProperties*)o)->operator=)(*(const ::reco::CATopJetProperties*)arg[0]);
  else   (((::reco::CATopJetProperties*)o)->operator=)(*(const ::reco::CATopJetProperties*)arg[0]);
}

static void constructor_27768( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::CATopJetProperties(*(const ::reco::CATopJetProperties*)arg[0]);
  else ::new(mem) ::reco::CATopJetProperties(*(const ::reco::CATopJetProperties*)arg[0]);
}

static void constructor_27769( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::CATopJetProperties();
  else ::new(mem) ::reco::CATopJetProperties();
}

static void method_newdel_7826( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::reco::CATopJetProperties >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::reco::CATopJetProperties >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::reco::CATopJetProperties >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::reco::CATopJetProperties >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::reco::CATopJetProperties >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class CATopJetProperties -------------------------------
void __reco__CATopJetProperties_db_datamem(Reflex::Class*);
void __reco__CATopJetProperties_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __reco__CATopJetProperties_datamem_bld(&__reco__CATopJetProperties_db_datamem);
Reflex::GenreflexMemberBuilder __reco__CATopJetProperties_funcmem_bld(&__reco__CATopJetProperties_db_funcmem);
void __reco__CATopJetProperties_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("reco::CATopJetProperties"), typeid(::reco::CATopJetProperties), sizeof(::reco::CATopJetProperties), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~CATopJetProperties"), destructor_27766, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_40762, type_35928), Reflex::Literal("operator="), operator_27767, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35928), Reflex::Literal("CATopJetProperties"), constructor_27768, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("CATopJetProperties"), constructor_27769, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_7826, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__reco__CATopJetProperties_datamem_bld);
}

//------Delayed data member builder for class CATopJetProperties -------------------
void __reco__CATopJetProperties_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_68, Reflex::Literal("nSubJets"), OffsetOf(__shadow__::__reco__CATopJetProperties, nSubJets), ::Reflex::PUBLIC)
  .AddDataMember(type_101, Reflex::Literal("minMass"), OffsetOf(__shadow__::__reco__CATopJetProperties, minMass), ::Reflex::PUBLIC)
  .AddDataMember(type_101, Reflex::Literal("topMass"), OffsetOf(__shadow__::__reco__CATopJetProperties, topMass), ::Reflex::PUBLIC)
  .AddDataMember(type_101, Reflex::Literal("wMass"), OffsetOf(__shadow__::__reco__CATopJetProperties, wMass), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class CATopJetProperties -------------------
void __reco__CATopJetProperties_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class FFTJet<float> -------------------------------
static  void operator_28691( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::reco::FFTJet<float>*)o)->operator=)(*(const ::reco::FFTJet<float>*)arg[0]);
  else   (((::reco::FFTJet<float>*)o)->operator=)(*(const ::reco::FFTJet<float>*)arg[0]);
}

static void constructor_28692( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::FFTJet<float>(*(const ::reco::FFTJet<float>*)arg[0]);
  else ::new(mem) ::reco::FFTJet<float>(*(const ::reco::FFTJet<float>*)arg[0]);
}

static void constructor_28693( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::FFTJet<float>();
  else ::new(mem) ::reco::FFTJet<float>();
}

static void constructor_28694( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::FFTJet<float>(*(const ::reco::PattRecoPeak<float>*)arg[0],
      *(const ::ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(double*)arg[9],
      *(double*)arg[10],
      *(double*)arg[11],
      *(double*)arg[12],
      *(double*)arg[13],
      *(int*)arg[14],
      *(int*)arg[15]);
  else ::new(mem) ::reco::FFTJet<float>(*(const ::reco::PattRecoPeak<float>*)arg[0],
      *(const ::ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(double*)arg[9],
      *(double*)arg[10],
      *(double*)arg[11],
      *(double*)arg[12],
      *(double*)arg[13],
      *(int*)arg[14],
      *(int*)arg[15]);
}

static void destructor_28695(void*, void * o, const std::vector<void*>&, void *) {
(((::reco::FFTJet<float>*)o)->::reco::FFTJet<float>::~FFTJet)();
}
static  void method_28696( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::reco::FFTJet<float>*)o)->f_precluster)();
  else   (((const ::reco::FFTJet<float>*)o)->f_precluster)();
}

static  void method_28697( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::reco::FFTJet<float>*)o)->f_vec)();
  else   (((const ::reco::FFTJet<float>*)o)->f_vec)();
}

static  void method_28698( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::reco::FFTJet<float>*)o)->f_pileup)();
  else   (((const ::reco::FFTJet<float>*)o)->f_pileup)();
}

static  void method_28699( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::reco::FFTJet<float>*)o)->f_ncells)());
  else   (((const ::reco::FFTJet<float>*)o)->f_ncells)();
}

static  void method_28700( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::reco::FFTJet<float>*)o)->f_etSum)());
  else   (((const ::reco::FFTJet<float>*)o)->f_etSum)();
}

static  void method_28701( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::reco::FFTJet<float>*)o)->f_centroidEta)());
  else   (((const ::reco::FFTJet<float>*)o)->f_centroidEta)();
}

static  void method_28702( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::reco::FFTJet<float>*)o)->f_centroidPhi)());
  else   (((const ::reco::FFTJet<float>*)o)->f_centroidPhi)();
}

static  void method_28703( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::reco::FFTJet<float>*)o)->f_etaWidth)());
  else   (((const ::reco::FFTJet<float>*)o)->f_etaWidth)();
}

static  void method_28704( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::reco::FFTJet<float>*)o)->f_phiWidth)());
  else   (((const ::reco::FFTJet<float>*)o)->f_phiWidth)();
}

static  void method_28705( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::reco::FFTJet<float>*)o)->f_etaPhiCorr)());
  else   (((const ::reco::FFTJet<float>*)o)->f_etaPhiCorr)();
}

static  void method_28706( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::reco::FFTJet<float>*)o)->f_fuzziness)());
  else   (((const ::reco::FFTJet<float>*)o)->f_fuzziness)();
}

static  void method_28707( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::reco::FFTJet<float>*)o)->f_convergenceDistance)());
  else   (((const ::reco::FFTJet<float>*)o)->f_convergenceDistance)();
}

static  void method_28708( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::reco::FFTJet<float>*)o)->f_recoScale)());
  else   (((const ::reco::FFTJet<float>*)o)->f_recoScale)();
}

static  void method_28709( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::reco::FFTJet<float>*)o)->f_recoScaleRatio)());
  else   (((const ::reco::FFTJet<float>*)o)->f_recoScaleRatio)();
}

static  void method_28710( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::reco::FFTJet<float>*)o)->f_membershipFactor)());
  else   (((const ::reco::FFTJet<float>*)o)->f_membershipFactor)();
}

static  void method_28711( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::reco::FFTJet<float>*)o)->f_code)());
  else   (((const ::reco::FFTJet<float>*)o)->f_code)();
}

static  void method_28712( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::reco::FFTJet<float>*)o)->f_status)());
  else   (((const ::reco::FFTJet<float>*)o)->f_status)();
}

static  void method_28713( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::reco::FFTJet<float>*)o)->setPileup)(*(const ::ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >*)arg[0]);
}

static  void method_28714( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::reco::FFTJet<float>*)o)->setFourVec)(*(const ::ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >*)arg[0]);
}

static  void method_28715( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::reco::FFTJet<float>*)o)->setCode)(*(const int*)arg[0]);
}

static  void method_28716( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::reco::FFTJet<float>*)o)->setStatus)(*(const int*)arg[0]);
}

static  void method_28717( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::reco::FFTJet<float>*)o)->setNCells)(*(const double*)arg[0]);
}

static void method_newdel_7938( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::reco::FFTJet<float> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::reco::FFTJet<float> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::reco::FFTJet<float> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::reco::FFTJet<float> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::reco::FFTJet<float> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class FFTJet<float> -------------------------------
void __reco__FFTJet_float__db_datamem(Reflex::Class*);
void __reco__FFTJet_float__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __reco__FFTJet_float__datamem_bld(&__reco__FFTJet_float__db_datamem);
Reflex::GenreflexMemberBuilder __reco__FFTJet_float__funcmem_bld(&__reco__FFTJet_float__db_funcmem);
void __reco__FFTJet_float__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("reco::FFTJet<float>"), typeid(::reco::FFTJet<float>), sizeof(::reco::FFTJet<float>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_40923, type_40757), Reflex::Literal("operator="), operator_28691, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_40757), Reflex::Literal("FFTJet"), constructor_28692, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("FFTJet"), constructor_28693, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_40756, type_40177, type_101, type_101, type_101, type_101, type_101, type_101, type_101, type_101, type_101, type_101, type_101, type_101, type_68, type_68), Reflex::Literal("FFTJet"), constructor_28694, 0, "peak;vec;ncells;etSum;centroidEta;centroidPhi;etaWidth;phiWidth;etaPhiCorr;fuzziness;convergenceDistance;recoScale;recoScaleRatio;membershipFactor;code;status", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~FFTJet"), destructor_28695, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_7938, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__reco__FFTJet_float__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__reco__FFTJet_float__funcmem_bld);
}

//------Delayed data member builder for class FFTJet<float> -------------------
void __reco__FFTJet_float__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_7810, Reflex::Literal("peak_"), OffsetOf(__shadow__::__reco__FFTJet_float_, peak_), ::Reflex::PRIVATE)
  .AddDataMember(type_6765, Reflex::Literal("vec_"), OffsetOf(__shadow__::__reco__FFTJet_float_, vec_), ::Reflex::PRIVATE)
  .AddDataMember(type_6765, Reflex::Literal("pileup_"), OffsetOf(__shadow__::__reco__FFTJet_float_, pileup_), ::Reflex::PRIVATE)
  .AddDataMember(type_894, Reflex::Literal("ncells_"), OffsetOf(__shadow__::__reco__FFTJet_float_, ncells_), ::Reflex::PRIVATE)
  .AddDataMember(type_894, Reflex::Literal("etSum_"), OffsetOf(__shadow__::__reco__FFTJet_float_, etSum_), ::Reflex::PRIVATE)
  .AddDataMember(type_894, Reflex::Literal("centroidEta_"), OffsetOf(__shadow__::__reco__FFTJet_float_, centroidEta_), ::Reflex::PRIVATE)
  .AddDataMember(type_894, Reflex::Literal("centroidPhi_"), OffsetOf(__shadow__::__reco__FFTJet_float_, centroidPhi_), ::Reflex::PRIVATE)
  .AddDataMember(type_894, Reflex::Literal("etaWidth_"), OffsetOf(__shadow__::__reco__FFTJet_float_, etaWidth_), ::Reflex::PRIVATE)
  .AddDataMember(type_894, Reflex::Literal("phiWidth_"), OffsetOf(__shadow__::__reco__FFTJet_float_, phiWidth_), ::Reflex::PRIVATE)
  .AddDataMember(type_894, Reflex::Literal("etaPhiCorr_"), OffsetOf(__shadow__::__reco__FFTJet_float_, etaPhiCorr_), ::Reflex::PRIVATE)
  .AddDataMember(type_894, Reflex::Literal("fuzziness_"), OffsetOf(__shadow__::__reco__FFTJet_float_, fuzziness_), ::Reflex::PRIVATE)
  .AddDataMember(type_894, Reflex::Literal("convergenceD_"), OffsetOf(__shadow__::__reco__FFTJet_float_, convergenceD_), ::Reflex::PRIVATE)
  .AddDataMember(type_894, Reflex::Literal("recoScale_"), OffsetOf(__shadow__::__reco__FFTJet_float_, recoScale_), ::Reflex::PRIVATE)
  .AddDataMember(type_894, Reflex::Literal("recoScaleRatio_"), OffsetOf(__shadow__::__reco__FFTJet_float_, recoScaleRatio_), ::Reflex::PRIVATE)
  .AddDataMember(type_894, Reflex::Literal("membershipFactor_"), OffsetOf(__shadow__::__reco__FFTJet_float_, membershipFactor_), ::Reflex::PRIVATE)
  .AddDataMember(type_68, Reflex::Literal("code_"), OffsetOf(__shadow__::__reco__FFTJet_float_, code_), ::Reflex::PRIVATE)
  .AddDataMember(type_68, Reflex::Literal("status_"), OffsetOf(__shadow__::__reco__FFTJet_float_, status_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class FFTJet<float> -------------------
void __reco__FFTJet_float__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_40756), Reflex::Literal("f_precluster"), method_28696, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_40177), Reflex::Literal("f_vec"), method_28697, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_40177), Reflex::Literal("f_pileup"), method_28698, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_894), Reflex::Literal("f_ncells"), method_28699, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_894), Reflex::Literal("f_etSum"), method_28700, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_894), Reflex::Literal("f_centroidEta"), method_28701, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_894), Reflex::Literal("f_centroidPhi"), method_28702, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_894), Reflex::Literal("f_etaWidth"), method_28703, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_894), Reflex::Literal("f_phiWidth"), method_28704, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_894), Reflex::Literal("f_etaPhiCorr"), method_28705, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_894), Reflex::Literal("f_fuzziness"), method_28706, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_894), Reflex::Literal("f_convergenceDistance"), method_28707, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_894), Reflex::Literal("f_recoScale"), method_28708, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_894), Reflex::Literal("f_recoScaleRatio"), method_28709, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_894), Reflex::Literal("f_membershipFactor"), method_28710, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_68), Reflex::Literal("f_code"), method_28711, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_68), Reflex::Literal("f_status"), method_28712, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_40177), Reflex::Literal("setPileup"), method_28713, 0, "p", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_40177), Reflex::Literal("setFourVec"), method_28714, 0, "p", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_68c), Reflex::Literal("setCode"), method_28715, 0, "c", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_68c), Reflex::Literal("setStatus"), method_28716, 0, "c", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_101c), Reflex::Literal("setNCells"), method_28717, 0, "nc", ::Reflex::PUBLIC);
}
//------Stub functions for class FFTJet<double> -------------------------------
static  void operator_28735( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::reco::FFTJet<double>*)o)->operator=)(*(const ::reco::FFTJet<double>*)arg[0]);
  else   (((::reco::FFTJet<double>*)o)->operator=)(*(const ::reco::FFTJet<double>*)arg[0]);
}

static void constructor_28736( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::FFTJet<double>(*(const ::reco::FFTJet<double>*)arg[0]);
  else ::new(mem) ::reco::FFTJet<double>(*(const ::reco::FFTJet<double>*)arg[0]);
}

static void constructor_28737( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::FFTJet<double>();
  else ::new(mem) ::reco::FFTJet<double>();
}

static void constructor_28738( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::FFTJet<double>(*(const ::reco::PattRecoPeak<double>*)arg[0],
      *(const ::ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(double*)arg[9],
      *(double*)arg[10],
      *(double*)arg[11],
      *(double*)arg[12],
      *(double*)arg[13],
      *(int*)arg[14],
      *(int*)arg[15]);
  else ::new(mem) ::reco::FFTJet<double>(*(const ::reco::PattRecoPeak<double>*)arg[0],
      *(const ::ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(double*)arg[9],
      *(double*)arg[10],
      *(double*)arg[11],
      *(double*)arg[12],
      *(double*)arg[13],
      *(int*)arg[14],
      *(int*)arg[15]);
}

static void destructor_28739(void*, void * o, const std::vector<void*>&, void *) {
(((::reco::FFTJet<double>*)o)->::reco::FFTJet<double>::~FFTJet)();
}
static  void method_28740( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::reco::FFTJet<double>*)o)->f_precluster)();
  else   (((const ::reco::FFTJet<double>*)o)->f_precluster)();
}

static  void method_28741( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::reco::FFTJet<double>*)o)->f_vec)();
  else   (((const ::reco::FFTJet<double>*)o)->f_vec)();
}

static  void method_28742( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::reco::FFTJet<double>*)o)->f_pileup)();
  else   (((const ::reco::FFTJet<double>*)o)->f_pileup)();
}

static  void method_28743( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::FFTJet<double>*)o)->f_ncells)());
  else   (((const ::reco::FFTJet<double>*)o)->f_ncells)();
}

static  void method_28744( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::FFTJet<double>*)o)->f_etSum)());
  else   (((const ::reco::FFTJet<double>*)o)->f_etSum)();
}

static  void method_28745( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::FFTJet<double>*)o)->f_centroidEta)());
  else   (((const ::reco::FFTJet<double>*)o)->f_centroidEta)();
}

static  void method_28746( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::FFTJet<double>*)o)->f_centroidPhi)());
  else   (((const ::reco::FFTJet<double>*)o)->f_centroidPhi)();
}

static  void method_28747( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::FFTJet<double>*)o)->f_etaWidth)());
  else   (((const ::reco::FFTJet<double>*)o)->f_etaWidth)();
}

static  void method_28748( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::FFTJet<double>*)o)->f_phiWidth)());
  else   (((const ::reco::FFTJet<double>*)o)->f_phiWidth)();
}

static  void method_28749( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::FFTJet<double>*)o)->f_etaPhiCorr)());
  else   (((const ::reco::FFTJet<double>*)o)->f_etaPhiCorr)();
}

static  void method_28750( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::FFTJet<double>*)o)->f_fuzziness)());
  else   (((const ::reco::FFTJet<double>*)o)->f_fuzziness)();
}

static  void method_28751( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::FFTJet<double>*)o)->f_convergenceDistance)());
  else   (((const ::reco::FFTJet<double>*)o)->f_convergenceDistance)();
}

static  void method_28752( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::FFTJet<double>*)o)->f_recoScale)());
  else   (((const ::reco::FFTJet<double>*)o)->f_recoScale)();
}

static  void method_28753( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::FFTJet<double>*)o)->f_recoScaleRatio)());
  else   (((const ::reco::FFTJet<double>*)o)->f_recoScaleRatio)();
}

static  void method_28754( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::FFTJet<double>*)o)->f_membershipFactor)());
  else   (((const ::reco::FFTJet<double>*)o)->f_membershipFactor)();
}

static  void method_28755( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::reco::FFTJet<double>*)o)->f_code)());
  else   (((const ::reco::FFTJet<double>*)o)->f_code)();
}

static  void method_28756( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::reco::FFTJet<double>*)o)->f_status)());
  else   (((const ::reco::FFTJet<double>*)o)->f_status)();
}

static  void method_28757( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::reco::FFTJet<double>*)o)->setPileup)(*(const ::ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >*)arg[0]);
}

static  void method_28758( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::reco::FFTJet<double>*)o)->setFourVec)(*(const ::ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >*)arg[0]);
}

static  void method_28759( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::reco::FFTJet<double>*)o)->setCode)(*(const int*)arg[0]);
}

static  void method_28760( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::reco::FFTJet<double>*)o)->setStatus)(*(const int*)arg[0]);
}

static  void method_28761( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::reco::FFTJet<double>*)o)->setNCells)(*(const double*)arg[0]);
}

static void method_newdel_7939( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::reco::FFTJet<double> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::reco::FFTJet<double> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::reco::FFTJet<double> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::reco::FFTJet<double> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::reco::FFTJet<double> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class FFTJet<double> -------------------------------
void __reco__FFTJet_double__db_datamem(Reflex::Class*);
void __reco__FFTJet_double__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __reco__FFTJet_double__datamem_bld(&__reco__FFTJet_double__db_datamem);
Reflex::GenreflexMemberBuilder __reco__FFTJet_double__funcmem_bld(&__reco__FFTJet_double__db_funcmem);
void __reco__FFTJet_double__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("reco::FFTJet<double>"), typeid(::reco::FFTJet<double>), sizeof(::reco::FFTJet<double>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_40924, type_40925), Reflex::Literal("operator="), operator_28735, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_40925), Reflex::Literal("FFTJet"), constructor_28736, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("FFTJet"), constructor_28737, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_40753, type_40177, type_101, type_101, type_101, type_101, type_101, type_101, type_101, type_101, type_101, type_101, type_101, type_101, type_68, type_68), Reflex::Literal("FFTJet"), constructor_28738, 0, "peak;vec;ncells;etSum;centroidEta;centroidPhi;etaWidth;phiWidth;etaPhiCorr;fuzziness;convergenceDistance;recoScale;recoScaleRatio;membershipFactor;code;status", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~FFTJet"), destructor_28739, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_7939, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__reco__FFTJet_double__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__reco__FFTJet_double__funcmem_bld);
}

//------Delayed data member builder for class FFTJet<double> -------------------
void __reco__FFTJet_double__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_7809, Reflex::Literal("peak_"), OffsetOf(__shadow__::__reco__FFTJet_double_, peak_), ::Reflex::PRIVATE)
  .AddDataMember(type_6765, Reflex::Literal("vec_"), OffsetOf(__shadow__::__reco__FFTJet_double_, vec_), ::Reflex::PRIVATE)
  .AddDataMember(type_6765, Reflex::Literal("pileup_"), OffsetOf(__shadow__::__reco__FFTJet_double_, pileup_), ::Reflex::PRIVATE)
  .AddDataMember(type_101, Reflex::Literal("ncells_"), OffsetOf(__shadow__::__reco__FFTJet_double_, ncells_), ::Reflex::PRIVATE)
  .AddDataMember(type_101, Reflex::Literal("etSum_"), OffsetOf(__shadow__::__reco__FFTJet_double_, etSum_), ::Reflex::PRIVATE)
  .AddDataMember(type_101, Reflex::Literal("centroidEta_"), OffsetOf(__shadow__::__reco__FFTJet_double_, centroidEta_), ::Reflex::PRIVATE)
  .AddDataMember(type_101, Reflex::Literal("centroidPhi_"), OffsetOf(__shadow__::__reco__FFTJet_double_, centroidPhi_), ::Reflex::PRIVATE)
  .AddDataMember(type_101, Reflex::Literal("etaWidth_"), OffsetOf(__shadow__::__reco__FFTJet_double_, etaWidth_), ::Reflex::PRIVATE)
  .AddDataMember(type_101, Reflex::Literal("phiWidth_"), OffsetOf(__shadow__::__reco__FFTJet_double_, phiWidth_), ::Reflex::PRIVATE)
  .AddDataMember(type_101, Reflex::Literal("etaPhiCorr_"), OffsetOf(__shadow__::__reco__FFTJet_double_, etaPhiCorr_), ::Reflex::PRIVATE)
  .AddDataMember(type_101, Reflex::Literal("fuzziness_"), OffsetOf(__shadow__::__reco__FFTJet_double_, fuzziness_), ::Reflex::PRIVATE)
  .AddDataMember(type_101, Reflex::Literal("convergenceD_"), OffsetOf(__shadow__::__reco__FFTJet_double_, convergenceD_), ::Reflex::PRIVATE)
  .AddDataMember(type_101, Reflex::Literal("recoScale_"), OffsetOf(__shadow__::__reco__FFTJet_double_, recoScale_), ::Reflex::PRIVATE)
  .AddDataMember(type_101, Reflex::Literal("recoScaleRatio_"), OffsetOf(__shadow__::__reco__FFTJet_double_, recoScaleRatio_), ::Reflex::PRIVATE)
  .AddDataMember(type_101, Reflex::Literal("membershipFactor_"), OffsetOf(__shadow__::__reco__FFTJet_double_, membershipFactor_), ::Reflex::PRIVATE)
  .AddDataMember(type_68, Reflex::Literal("code_"), OffsetOf(__shadow__::__reco__FFTJet_double_, code_), ::Reflex::PRIVATE)
  .AddDataMember(type_68, Reflex::Literal("status_"), OffsetOf(__shadow__::__reco__FFTJet_double_, status_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class FFTJet<double> -------------------
void __reco__FFTJet_double__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_40753), Reflex::Literal("f_precluster"), method_28740, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_40177), Reflex::Literal("f_vec"), method_28741, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_40177), Reflex::Literal("f_pileup"), method_28742, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_101), Reflex::Literal("f_ncells"), method_28743, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_101), Reflex::Literal("f_etSum"), method_28744, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_101), Reflex::Literal("f_centroidEta"), method_28745, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_101), Reflex::Literal("f_centroidPhi"), method_28746, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_101), Reflex::Literal("f_etaWidth"), method_28747, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_101), Reflex::Literal("f_phiWidth"), method_28748, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_101), Reflex::Literal("f_etaPhiCorr"), method_28749, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_101), Reflex::Literal("f_fuzziness"), method_28750, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_101), Reflex::Literal("f_convergenceDistance"), method_28751, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_101), Reflex::Literal("f_recoScale"), method_28752, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_101), Reflex::Literal("f_recoScaleRatio"), method_28753, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_101), Reflex::Literal("f_membershipFactor"), method_28754, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_68), Reflex::Literal("f_code"), method_28755, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_68), Reflex::Literal("f_status"), method_28756, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_40177), Reflex::Literal("setPileup"), method_28757, 0, "p", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_40177), Reflex::Literal("setFourVec"), method_28758, 0, "p", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_68c), Reflex::Literal("setCode"), method_28759, 0, "c", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_68c), Reflex::Literal("setStatus"), method_28760, 0, "c", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_101c), Reflex::Literal("setNCells"), method_28761, 0, "nc", ::Reflex::PUBLIC);
}
//------Stub functions for class FFTAnyJet<reco::GenJet> -------------------------------
static  void operator_27628( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::reco::FFTAnyJet<reco::GenJet>*)o)->operator=)(*(const ::reco::FFTAnyJet<reco::GenJet>*)arg[0]);
  else   (((::reco::FFTAnyJet<reco::GenJet>*)o)->operator=)(*(const ::reco::FFTAnyJet<reco::GenJet>*)arg[0]);
}

static void constructor_27629( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::FFTAnyJet<reco::GenJet>(*(const ::reco::FFTAnyJet<reco::GenJet>*)arg[0]);
  else ::new(mem) ::reco::FFTAnyJet<reco::GenJet>(*(const ::reco::FFTAnyJet<reco::GenJet>*)arg[0]);
}

static void constructor_27630( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::FFTAnyJet<reco::GenJet>();
  else ::new(mem) ::reco::FFTAnyJet<reco::GenJet>();
}

static void destructor_27631(void*, void * o, const std::vector<void*>&, void *) {
(((::reco::FFTAnyJet<reco::GenJet>*)o)->::reco::FFTAnyJet<reco::GenJet>::~FFTAnyJet)();
}
static void constructor_27632( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::FFTAnyJet<reco::GenJet>(*(const ::reco::GenJet*)arg[0],
      *(const ::reco::FFTJet<float>*)arg[1]);
  else ::new(mem) ::reco::FFTAnyJet<reco::GenJet>(*(const ::reco::GenJet*)arg[0],
      *(const ::reco::FFTJet<float>*)arg[1]);
}

static  void method_27633( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::reco::FFTAnyJet<reco::GenJet>*)o)->clone)());
  else   (((const ::reco::FFTAnyJet<reco::GenJet>*)o)->clone)();
}

static  void method_27634( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::reco::FFTAnyJet<reco::GenJet>*)o)->getFFTSpecific)();
  else   (((const ::reco::FFTAnyJet<reco::GenJet>*)o)->getFFTSpecific)();
}

static void method_newdel_7811( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::reco::FFTAnyJet<reco::GenJet> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::reco::FFTAnyJet<reco::GenJet> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::reco::FFTAnyJet<reco::GenJet> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::reco::FFTAnyJet<reco::GenJet> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::reco::FFTAnyJet<reco::GenJet> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x95( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::GenJet")), ::Reflex::BaseOffset< ::reco::FFTAnyJet<reco::GenJet>,::reco::GenJet >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Jet")), ::Reflex::BaseOffset< ::reco::FFTAnyJet<reco::GenJet>,::reco::Jet >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::CompositePtrCandidate")), ::Reflex::BaseOffset< ::reco::FFTAnyJet<reco::GenJet>,::reco::CompositePtrCandidate >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::reco::FFTAnyJet<reco::GenJet>,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::reco::FFTAnyJet<reco::GenJet>,::reco::Candidate >::Get(),::Reflex::PUBLIC), 4));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class FFTAnyJet<reco::GenJet> -------------------------------
void __reco__FFTAnyJet_reco__GenJet__db_datamem(Reflex::Class*);
void __reco__FFTAnyJet_reco__GenJet__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __reco__FFTAnyJet_reco__GenJet__datamem_bld(&__reco__FFTAnyJet_reco__GenJet__db_datamem);
Reflex::GenreflexMemberBuilder __reco__FFTAnyJet_reco__GenJet__funcmem_bld(&__reco__FFTAnyJet_reco__GenJet__db_funcmem);
void __reco__FFTAnyJet_reco__GenJet__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("reco::FFTAnyJet<reco::GenJet>"), typeid(::reco::FFTAnyJet<reco::GenJet>), sizeof(::reco::FFTAnyJet<reco::GenJet>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_7893, ::Reflex::BaseOffset< ::reco::FFTAnyJet<reco::GenJet>, ::reco::GenJet >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_7893, Reflex::Literal("reco::FFTAnyJet<reco::GenJet>::Base"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13824, type_13826), Reflex::Literal("operator="), operator_27628, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13826), Reflex::Literal("FFTAnyJet"), constructor_27629, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("FFTAnyJet"), constructor_27630, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~FFTAnyJet"), destructor_27631, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_16350, type_40757), Reflex::Literal("FFTAnyJet"), constructor_27632, 0, "jet;fftjet", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_7811, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x95, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__reco__FFTAnyJet_reco__GenJet__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__reco__FFTAnyJet_reco__GenJet__funcmem_bld);
}

//------Delayed data member builder for class FFTAnyJet<reco::GenJet> -------------------
void __reco__FFTAnyJet_reco__GenJet__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_7938, Reflex::Literal("fftJetSpecific_"), OffsetOf(__shadow__::__reco__FFTAnyJet_reco__GenJet_, fftJetSpecific_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class FFTAnyJet<reco::GenJet> -------------------
void __reco__FFTAnyJet_reco__GenJet__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9704), Reflex::Literal("clone"), method_27633, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_40757), Reflex::Literal("getFFTSpecific"), method_27634, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >, reco::FFTAnyJet<reco::GenJet> > > -------------------------------
static  void operator_23793( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->operator=)(*(const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)arg[0]);
  else   (((::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->operator=)(*(const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)arg[0]);
}

static void constructor_23794( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >(*(const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)arg[0]);
  else ::new(mem) ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >(*(const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)arg[0]);
}

static void constructor_23795( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >();
  else ::new(mem) ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >();
}

static void constructor_23796( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >(*(const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)arg[0],
      *(const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)arg[1]);
  else ::new(mem) ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >(*(const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)arg[0],
      *(const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)arg[1]);
}

static void destructor_23797(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >::~FwdRef)();
}
static  void operator_23798( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->operator*)();
  else   (((const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->operator*)();
}

static  void operator_23799( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->operator->)());
  else   (((const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->operator->)();
}

static  void method_23800( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->get)());
  else   (((const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->get)();
}

static  void method_23801( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->isNull)());
  else   (((const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->isNull)();
}

static  void method_23802( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->isNonnull)());
  else   (((const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->isNonnull)();
}

static  void operator_23803( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->operator!)());
  else   (((const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->operator!)();
}

static  void method_23804( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->ref)();
  else   (((const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->ref)();
}

static  void method_23805( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->backRef)();
  else   (((const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->backRef)();
}

static  void method_23806( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->productGetter)());
  else   (((const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->productGetter)();
}

static  void method_23807( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->product)());
  else   (((const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->product)();
}

static  void method_23808( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->id)());
  else   (((const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->id)();
}

static  void method_23809( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->key)());
  else   (((const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->key)();
}

static  void method_23810( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->hasProductCache)());
  else   (((const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->hasProductCache)();
}

static  void method_23811( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->isAvailable)());
  else   (((const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->isAvailable)();
}

static  void method_23812( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->isTransient)());
  else   (((const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->isTransient)();
}

static  void method_23813( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->Class_Version)());
  else   (((::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->Class_Version)();
}

static void method_newdel_4775( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >, reco::FFTAnyJet<reco::GenJet> > > -------------------------------
void __edm__FwdRef_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s__db_datamem(Reflex::Class*);
void __edm__FwdRef_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__FwdRef_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s__datamem_bld(&__edm__FwdRef_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__FwdRef_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s__funcmem_bld(&__edm__FwdRef_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s__db_funcmem);
void __edm__FwdRef_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >"), typeid(::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >), sizeof(::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >::Class_Version())
  .AddTypedef(type_2988, Reflex::Literal("edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >::product_type"))
  .AddTypedef(type_7811, Reflex::Literal("edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >::value_type"))
  .AddTypedef(type_7811c, Reflex::Literal("edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >::element_type"))
  .AddTypedef(type_20829, Reflex::Literal("edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >::finder_type"))
  .AddTypedef(type_366, Reflex::Literal("edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >::argument_type"))
  .AddTypedef(type_366, Reflex::Literal("edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >::key_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13759, type_13761), Reflex::Literal("operator="), operator_23793, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13761), Reflex::Literal("FwdRef"), constructor_23794, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("FwdRef"), constructor_23795, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_38861, type_38861), Reflex::Literal("FwdRef"), constructor_23796, 0, "ref;backRef", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~FwdRef"), destructor_23797, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4775, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__FwdRef_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__FwdRef_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s__funcmem_bld);
}

//------Delayed data member builder for class FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >, reco::FFTAnyJet<reco::GenJet> > > -------------------
void __edm__FwdRef_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_5021, Reflex::Literal("ref_"), OffsetOf(__shadow__::__edm__FwdRef_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_, ref_), ::Reflex::PRIVATE)
  .AddDataMember(type_5021, Reflex::Literal("backRef_"), OffsetOf(__shadow__::__edm__FwdRef_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_, backRef_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >, reco::FFTAnyJet<reco::GenJet> > > -------------------
void __edm__FwdRef_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13826), Reflex::Literal("operator*"), operator_23798, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13822), Reflex::Literal("operator->"), operator_23799, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13822), Reflex::Literal("get"), method_23800, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isNull"), method_23801, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isNonnull"), method_23802, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("operator!"), operator_23803, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_38861), Reflex::Literal("ref"), method_23804, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_38861), Reflex::Literal("backRef"), method_23805, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20675), Reflex::Literal("productGetter"), method_23806, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39285), Reflex::Literal("product"), method_23807, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4933), Reflex::Literal("id"), method_23808, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_366), Reflex::Literal("key"), method_23809, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("hasProductCache"), method_23810, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isAvailable"), method_23811, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isTransient"), method_23812, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_237), Reflex::Literal("Class_Version"), method_23813, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefVector<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >, reco::FFTAnyJet<reco::GenJet> > > -------------------------------
static void destructor_22788(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->::edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >::~RefVector)();
}
static void constructor_22789( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >();
  else ::new(mem) ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >();
}

static void constructor_22790( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >(*(const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)arg[0]);
  else ::new(mem) ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >(*(const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)arg[0]);
}

static void constructor_22791( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >(*(const ::edm::ProductID*)arg[0]);
}

static  void method_22792( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->push_back)(*(const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)arg[0]);
}

static  void operator_22793( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >)((((const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->operator[])(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_22794( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >)((((const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->at)(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_22795( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->refVector)();
  else   (((const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->refVector)();
}

static  void method_22796( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->empty)());
  else   (((const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->empty)();
}

static  void method_22797( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->size)());
  else   (((const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->size)();
}

static  void method_22798( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->capacity)());
  else   (((const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->capacity)();
}

static  void method_22799( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void method_22800( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >)((((const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->begin)());
  else   (((const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->begin)();
}

static  void method_22801( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >)((((const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->end)());
  else   (((const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->end)();
}

static  void method_22802( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->id)());
  else   (((const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->id)();
}

static  void method_22803( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->productGetter)());
  else   (((const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->productGetter)();
}

static  void method_22804( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->isNull)());
  else   (((const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->isNull)();
}

static  void method_22805( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->isNonnull)());
  else   (((const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->isNonnull)();
}

static  void operator_22806( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->operator!)());
  else   (((const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->operator!)();
}

static  void method_22807( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->product)());
  else   (((const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->product)();
}

static  void method_22808( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->isAvailable)());
  else   (((const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->isAvailable)();
}

static  void method_22809( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->isTransient)());
  else   (((const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->isTransient)();
}

static  void method_22810( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >)((((::edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->erase)(*(const ::edm::RefVectorIterator<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)arg[0]));
  else   (((::edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->erase)(*(const ::edm::RefVectorIterator<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)arg[0]);
}

static  void method_22811( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->clear)();
}

static  void method_22812( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->swap)(*(::edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)arg[0]);
}

static  void operator_22813( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->operator=)(*(const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)arg[0]);
  else   (((::edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->operator=)(*(const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)arg[0]);
}

static  void method_22814( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->hasProductCache)());
  else   (((const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->hasProductCache)();
}

static  void method_22815( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::edm::helper_vector*)arg[2]);
}

static  void method_22816( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->Class_Version)());
  else   (((::edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->Class_Version)();
}

static void method_newdel_4676( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefVector<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >, reco::FFTAnyJet<reco::GenJet> > > -------------------------------
void __edm__RefVector_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s__db_datamem(Reflex::Class*);
void __edm__RefVector_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefVector_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s__datamem_bld(&__edm__RefVector_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefVector_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s__funcmem_bld(&__edm__RefVector_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s__db_funcmem);
void __edm__RefVector_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >"), typeid(::edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >), sizeof(::edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >::Class_Version())
  .AddTypedef(type_2988, Reflex::Literal("edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >::collection_type"))
  .AddTypedef(type_7811, Reflex::Literal("edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >::member_type"))
  .AddTypedef(type_20829, Reflex::Literal("edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >::finder_type"))
  .AddTypedef(type_4614, Reflex::Literal("edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >::iterator"))
  .AddTypedef(type_4614, Reflex::Literal("edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >::const_iterator"))
  .AddTypedef(type_5021, Reflex::Literal("edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >::value_type"))
  .AddTypedef(type_5021c, Reflex::Literal("edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >::const_reference"))
  .AddTypedef(type_5021c, Reflex::Literal("edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >::reference"))
  .AddTypedef(type_366, Reflex::Literal("edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >::key_type"))
  .AddTypedef(type_2972, Reflex::Literal("edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >::KeyVec"))
  .AddTypedef(type_3254, Reflex::Literal("edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >::size_type"))
  .AddTypedef(type_4039, Reflex::Literal("edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >::contents_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefVector"), destructor_22788, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefVector"), constructor_22789, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39284), Reflex::Literal("RefVector"), constructor_22790, 0, "rh", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20599), Reflex::Literal("RefVector"), constructor_22791, 0, "iId", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4676, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefVector_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefVector_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s__funcmem_bld);
}

//------Delayed data member builder for class RefVector<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >, reco::FFTAnyJet<reco::GenJet> > > -------------------
void __edm__RefVector_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4039, Reflex::Literal("refVector_"), OffsetOf(__shadow__::__edm__RefVector_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_, refVector_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefVector<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >, reco::FFTAnyJet<reco::GenJet> > > -------------------
void __edm__RefVector_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_38861), Reflex::Literal("push_back"), method_22792, 0, "ref", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5021c, type_3254), Reflex::Literal("operator[]"), operator_22793, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5021c, type_3254), Reflex::Literal("at"), method_22794, 0, "idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20674), Reflex::Literal("refVector"), method_22795, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("empty"), method_22796, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3254), Reflex::Literal("size"), method_22797, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3254), Reflex::Literal("capacity"), method_22798, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_3254), Reflex::Literal("reserve"), method_22799, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4614), Reflex::Literal("begin"), method_22800, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4614), Reflex::Literal("end"), method_22801, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4933), Reflex::Literal("id"), method_22802, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20675), Reflex::Literal("productGetter"), method_22803, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isNull"), method_22804, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isNonnull"), method_22805, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("operator!"), operator_22806, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39285), Reflex::Literal("product"), method_22807, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isAvailable"), method_22808, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isTransient"), method_22809, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4614, type_39286), Reflex::Literal("erase"), method_22810, 0, "pos", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694), Reflex::Literal("clear"), method_22811, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_39287), Reflex::Literal("swap"), method_22812, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39287, type_39284), Reflex::Literal("operator="), operator_22813, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("hasProductCache"), method_22814, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20599, type_20679, type_20680), Reflex::Literal("fillView"), method_22815, 0, ";pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_237), Reflex::Literal("Class_Version"), method_22816, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class FFTAnyJet<reco::CaloJet> -------------------------------
static  void operator_27989( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::reco::FFTAnyJet<reco::CaloJet>*)o)->operator=)(*(const ::reco::FFTAnyJet<reco::CaloJet>*)arg[0]);
  else   (((::reco::FFTAnyJet<reco::CaloJet>*)o)->operator=)(*(const ::reco::FFTAnyJet<reco::CaloJet>*)arg[0]);
}

static void constructor_27990( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::FFTAnyJet<reco::CaloJet>(*(const ::reco::FFTAnyJet<reco::CaloJet>*)arg[0]);
  else ::new(mem) ::reco::FFTAnyJet<reco::CaloJet>(*(const ::reco::FFTAnyJet<reco::CaloJet>*)arg[0]);
}

static void constructor_27991( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::FFTAnyJet<reco::CaloJet>();
  else ::new(mem) ::reco::FFTAnyJet<reco::CaloJet>();
}

static void destructor_27992(void*, void * o, const std::vector<void*>&, void *) {
(((::reco::FFTAnyJet<reco::CaloJet>*)o)->::reco::FFTAnyJet<reco::CaloJet>::~FFTAnyJet)();
}
static void constructor_27993( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::FFTAnyJet<reco::CaloJet>(*(const ::reco::CaloJet*)arg[0],
      *(const ::reco::FFTJet<float>*)arg[1]);
  else ::new(mem) ::reco::FFTAnyJet<reco::CaloJet>(*(const ::reco::CaloJet*)arg[0],
      *(const ::reco::FFTJet<float>*)arg[1]);
}

static  void method_27994( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::reco::FFTAnyJet<reco::CaloJet>*)o)->clone)());
  else   (((const ::reco::FFTAnyJet<reco::CaloJet>*)o)->clone)();
}

static  void method_27995( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::reco::FFTAnyJet<reco::CaloJet>*)o)->getFFTSpecific)();
  else   (((const ::reco::FFTAnyJet<reco::CaloJet>*)o)->getFFTSpecific)();
}

static void method_newdel_7851( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::reco::FFTAnyJet<reco::CaloJet> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::reco::FFTAnyJet<reco::CaloJet> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::reco::FFTAnyJet<reco::CaloJet> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::reco::FFTAnyJet<reco::CaloJet> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::reco::FFTAnyJet<reco::CaloJet> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x99( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::CaloJet")), ::Reflex::BaseOffset< ::reco::FFTAnyJet<reco::CaloJet>,::reco::CaloJet >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Jet")), ::Reflex::BaseOffset< ::reco::FFTAnyJet<reco::CaloJet>,::reco::Jet >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::CompositePtrCandidate")), ::Reflex::BaseOffset< ::reco::FFTAnyJet<reco::CaloJet>,::reco::CompositePtrCandidate >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::reco::FFTAnyJet<reco::CaloJet>,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::reco::FFTAnyJet<reco::CaloJet>,::reco::Candidate >::Get(),::Reflex::PUBLIC), 4));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class FFTAnyJet<reco::CaloJet> -------------------------------
void __reco__FFTAnyJet_reco__CaloJet__db_datamem(Reflex::Class*);
void __reco__FFTAnyJet_reco__CaloJet__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __reco__FFTAnyJet_reco__CaloJet__datamem_bld(&__reco__FFTAnyJet_reco__CaloJet__db_datamem);
Reflex::GenreflexMemberBuilder __reco__FFTAnyJet_reco__CaloJet__funcmem_bld(&__reco__FFTAnyJet_reco__CaloJet__db_funcmem);
void __reco__FFTAnyJet_reco__CaloJet__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("reco::FFTAnyJet<reco::CaloJet>"), typeid(::reco::FFTAnyJet<reco::CaloJet>), sizeof(::reco::FFTAnyJet<reco::CaloJet>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_7818, ::Reflex::BaseOffset< ::reco::FFTAnyJet<reco::CaloJet>, ::reco::CaloJet >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_7818, Reflex::Literal("reco::FFTAnyJet<reco::CaloJet>::Base"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13629, type_13631), Reflex::Literal("operator="), operator_27989, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13631), Reflex::Literal("FFTAnyJet"), constructor_27990, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("FFTAnyJet"), constructor_27991, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~FFTAnyJet"), destructor_27992, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_16608, type_40757), Reflex::Literal("FFTAnyJet"), constructor_27993, 0, "jet;fftjet", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_7851, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x99, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__reco__FFTAnyJet_reco__CaloJet__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__reco__FFTAnyJet_reco__CaloJet__funcmem_bld);
}

//------Delayed data member builder for class FFTAnyJet<reco::CaloJet> -------------------
void __reco__FFTAnyJet_reco__CaloJet__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_7938, Reflex::Literal("fftJetSpecific_"), OffsetOf(__shadow__::__reco__FFTAnyJet_reco__CaloJet_, fftJetSpecific_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class FFTAnyJet<reco::CaloJet> -------------------
void __reco__FFTAnyJet_reco__CaloJet__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9723), Reflex::Literal("clone"), method_27994, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_40757), Reflex::Literal("getFFTSpecific"), method_27995, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >, reco::FFTAnyJet<reco::CaloJet> > > -------------------------------
static  void operator_23764( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->operator=)(*(const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)arg[0]);
  else   (((::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->operator=)(*(const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)arg[0]);
}

static void constructor_23765( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >(*(const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)arg[0]);
  else ::new(mem) ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >(*(const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)arg[0]);
}

static void constructor_23766( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >();
  else ::new(mem) ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >();
}

static void constructor_23767( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >(*(const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)arg[0],
      *(const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)arg[1]);
  else ::new(mem) ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >(*(const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)arg[0],
      *(const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)arg[1]);
}

static void destructor_23768(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >::~FwdRef)();
}
static  void operator_23769( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->operator*)();
  else   (((const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->operator*)();
}

static  void operator_23770( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->operator->)());
  else   (((const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->operator->)();
}

static  void method_23771( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->get)());
  else   (((const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->get)();
}

static  void method_23772( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->isNull)());
  else   (((const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->isNull)();
}

static  void method_23773( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->isNonnull)());
  else   (((const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->isNonnull)();
}

static  void operator_23774( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->operator!)());
  else   (((const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->operator!)();
}

static  void method_23775( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->ref)();
  else   (((const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->ref)();
}

static  void method_23776( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->backRef)();
  else   (((const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->backRef)();
}

static  void method_23777( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->productGetter)());
  else   (((const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->productGetter)();
}

static  void method_23778( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->product)());
  else   (((const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->product)();
}

static  void method_23779( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->id)());
  else   (((const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->id)();
}

static  void method_23780( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->key)());
  else   (((const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->key)();
}

static  void method_23781( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->hasProductCache)());
  else   (((const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->hasProductCache)();
}

static  void method_23782( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->isAvailable)());
  else   (((const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->isAvailable)();
}

static  void method_23783( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->isTransient)());
  else   (((const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->isTransient)();
}

static  void method_23784( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->Class_Version)());
  else   (((::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->Class_Version)();
}

static void method_newdel_4774( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >, reco::FFTAnyJet<reco::CaloJet> > > -------------------------------
void __edm__FwdRef_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s__db_datamem(Reflex::Class*);
void __edm__FwdRef_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__FwdRef_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s__datamem_bld(&__edm__FwdRef_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__FwdRef_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s__funcmem_bld(&__edm__FwdRef_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s__db_funcmem);
void __edm__FwdRef_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >"), typeid(::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >), sizeof(::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >::Class_Version())
  .AddTypedef(type_2983, Reflex::Literal("edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >::product_type"))
  .AddTypedef(type_7851, Reflex::Literal("edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >::value_type"))
  .AddTypedef(type_7851c, Reflex::Literal("edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >::element_type"))
  .AddTypedef(type_20817, Reflex::Literal("edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >::finder_type"))
  .AddTypedef(type_366, Reflex::Literal("edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >::argument_type"))
  .AddTypedef(type_366, Reflex::Literal("edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >::key_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13564, type_13566), Reflex::Literal("operator="), operator_23764, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13566), Reflex::Literal("FwdRef"), constructor_23765, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("FwdRef"), constructor_23766, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_38847, type_38847), Reflex::Literal("FwdRef"), constructor_23767, 0, "ref;backRef", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~FwdRef"), destructor_23768, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4774, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__FwdRef_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__FwdRef_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s__funcmem_bld);
}

//------Delayed data member builder for class FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >, reco::FFTAnyJet<reco::CaloJet> > > -------------------
void __edm__FwdRef_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_5019, Reflex::Literal("ref_"), OffsetOf(__shadow__::__edm__FwdRef_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_, ref_), ::Reflex::PRIVATE)
  .AddDataMember(type_5019, Reflex::Literal("backRef_"), OffsetOf(__shadow__::__edm__FwdRef_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_, backRef_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >, reco::FFTAnyJet<reco::CaloJet> > > -------------------
void __edm__FwdRef_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13631), Reflex::Literal("operator*"), operator_23769, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13627), Reflex::Literal("operator->"), operator_23770, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13627), Reflex::Literal("get"), method_23771, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isNull"), method_23772, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isNonnull"), method_23773, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("operator!"), operator_23774, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_38847), Reflex::Literal("ref"), method_23775, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_38847), Reflex::Literal("backRef"), method_23776, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20675), Reflex::Literal("productGetter"), method_23777, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39280), Reflex::Literal("product"), method_23778, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4933), Reflex::Literal("id"), method_23779, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_366), Reflex::Literal("key"), method_23780, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("hasProductCache"), method_23781, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isAvailable"), method_23782, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isTransient"), method_23783, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_237), Reflex::Literal("Class_Version"), method_23784, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefVector<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> >,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> >, reco::CATopJetTagInfo> > -------------------------------
static void destructor_22662(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >::~RefVector)();
}
static void constructor_22663( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >();
  else ::new(mem) ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >();
}

static void constructor_22664( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >(*(const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)arg[0]);
  else ::new(mem) ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >(*(const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)arg[0]);
}

static void constructor_22665( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >(*(const ::edm::ProductID*)arg[0]);
}

static  void method_22666( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->push_back)(*(const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)arg[0]);
}

static  void operator_22667( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >)((((const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->operator[])(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_22668( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >)((((const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->at)(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_22669( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->refVector)();
  else   (((const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->refVector)();
}

static  void method_22670( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->empty)());
  else   (((const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->empty)();
}

static  void method_22671( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->size)());
  else   (((const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->size)();
}

static  void method_22672( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->capacity)());
  else   (((const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->capacity)();
}

static  void method_22673( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void method_22674( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >)((((const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->begin)());
  else   (((const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->begin)();
}

static  void method_22675( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >)((((const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->end)());
  else   (((const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->end)();
}

static  void method_22676( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->id)());
  else   (((const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->id)();
}

static  void method_22677( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->productGetter)());
  else   (((const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->productGetter)();
}

static  void method_22678( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->isNull)());
  else   (((const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->isNull)();
}

static  void method_22679( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->isNonnull)());
  else   (((const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->isNonnull)();
}

static  void operator_22680( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->operator!)());
  else   (((const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->operator!)();
}

static  void method_22681( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->product)());
  else   (((const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->product)();
}

static  void method_22682( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->isAvailable)());
  else   (((const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->isAvailable)();
}

static  void method_22683( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->isTransient)());
  else   (((const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->isTransient)();
}

static  void method_22684( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >)((((::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->erase)(*(const ::edm::RefVectorIterator<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)arg[0]));
  else   (((::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->erase)(*(const ::edm::RefVectorIterator<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)arg[0]);
}

static  void method_22685( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->clear)();
}

static  void method_22686( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->swap)(*(::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)arg[0]);
}

static  void operator_22687( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->operator=)(*(const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)arg[0]);
  else   (((::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->operator=)(*(const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)arg[0]);
}

static  void method_22688( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->hasProductCache)());
  else   (((const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->hasProductCache)();
}

static  void method_22689( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::edm::helper_vector*)arg[2]);
}

static  void method_22690( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->Class_Version)());
  else   (((::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->Class_Version)();
}

static void method_newdel_4665( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefVector<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> >,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> >, reco::CATopJetTagInfo> > -------------------------------
void __edm__RefVector_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s__db_datamem(Reflex::Class*);
void __edm__RefVector_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefVector_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s__datamem_bld(&__edm__RefVector_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefVector_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s__funcmem_bld(&__edm__RefVector_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s__db_funcmem);
void __edm__RefVector_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >"), typeid(::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >), sizeof(::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >::Class_Version())
  .AddTypedef(type_2973, Reflex::Literal("edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >::collection_type"))
  .AddTypedef(type_7813, Reflex::Literal("edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >::member_type"))
  .AddTypedef(type_20805, Reflex::Literal("edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >::finder_type"))
  .AddTypedef(type_4612, Reflex::Literal("edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >::iterator"))
  .AddTypedef(type_4612, Reflex::Literal("edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >::const_iterator"))
  .AddTypedef(type_5018, Reflex::Literal("edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >::value_type"))
  .AddTypedef(type_5018c, Reflex::Literal("edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >::const_reference"))
  .AddTypedef(type_5018c, Reflex::Literal("edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >::reference"))
  .AddTypedef(type_366, Reflex::Literal("edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >::key_type"))
  .AddTypedef(type_2972, Reflex::Literal("edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >::KeyVec"))
  .AddTypedef(type_3254, Reflex::Literal("edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >::size_type"))
  .AddTypedef(type_4039, Reflex::Literal("edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >::contents_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefVector"), destructor_22662, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefVector"), constructor_22663, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39271), Reflex::Literal("RefVector"), constructor_22664, 0, "rh", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20599), Reflex::Literal("RefVector"), constructor_22665, 0, "iId", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4665, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefVector_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefVector_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s__funcmem_bld);
}

//------Delayed data member builder for class RefVector<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> >,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> >, reco::CATopJetTagInfo> > -------------------
void __edm__RefVector_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4039, Reflex::Literal("refVector_"), OffsetOf(__shadow__::__edm__RefVector_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_, refVector_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefVector<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> >,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> >, reco::CATopJetTagInfo> > -------------------
void __edm__RefVector_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_39272), Reflex::Literal("push_back"), method_22666, 0, "ref", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5018c, type_3254), Reflex::Literal("operator[]"), operator_22667, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5018c, type_3254), Reflex::Literal("at"), method_22668, 0, "idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20674), Reflex::Literal("refVector"), method_22669, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("empty"), method_22670, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3254), Reflex::Literal("size"), method_22671, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3254), Reflex::Literal("capacity"), method_22672, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_3254), Reflex::Literal("reserve"), method_22673, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4612), Reflex::Literal("begin"), method_22674, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4612), Reflex::Literal("end"), method_22675, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4933), Reflex::Literal("id"), method_22676, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20675), Reflex::Literal("productGetter"), method_22677, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isNull"), method_22678, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isNonnull"), method_22679, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("operator!"), operator_22680, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39273), Reflex::Literal("product"), method_22681, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isAvailable"), method_22682, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isTransient"), method_22683, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4612, type_39274), Reflex::Literal("erase"), method_22684, 0, "pos", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694), Reflex::Literal("clear"), method_22685, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_39275), Reflex::Literal("swap"), method_22686, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39275, type_39271), Reflex::Literal("operator="), operator_22687, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("hasProductCache"), method_22688, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20599, type_20679, type_20680), Reflex::Literal("fillView"), method_22689, 0, ";pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_237), Reflex::Literal("Class_Version"), method_22690, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class FwdPtr<reco::FFTAnyJet<reco::CaloJet> > -------------------------------
static  void operator_22603( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >*)o)->operator=)(*(const ::edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >*)arg[0]);
  else   (((::edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >*)o)->operator=)(*(const ::edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >*)arg[0]);
}

static void constructor_22604( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >(*(const ::edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >*)arg[0]);
  else ::new(mem) ::edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >(*(const ::edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >*)arg[0]);
}

static void constructor_22605( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >();
  else ::new(mem) ::edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >();
}

static void destructor_22606(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >*)o)->::edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >::~FwdPtr)();
}
static  void operator_22607( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >*)o)->operator*)();
  else   (((const ::edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >*)o)->operator*)();
}

static  void operator_22608( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >*)o)->operator->)());
  else   (((const ::edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >*)o)->operator->)();
}

static  void method_22609( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >*)o)->get)());
  else   (((const ::edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >*)o)->get)();
}

static  void method_22610( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >*)o)->isNull)());
  else   (((const ::edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >*)o)->isNull)();
}

static  void method_22611( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >*)o)->isNonnull)());
  else   (((const ::edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >*)o)->isNonnull)();
}

static  void operator_22612( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >*)o)->operator!)());
  else   (((const ::edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >*)o)->operator!)();
}

static  void method_22613( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >*)o)->isAvailable)());
  else   (((const ::edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >*)o)->isAvailable)();
}

static  void method_22614( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >*)o)->isTransient)());
  else   (((const ::edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >*)o)->isTransient)();
}

static  void method_22615( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >*)o)->id)());
  else   (((const ::edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >*)o)->id)();
}

static  void method_22616( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >*)o)->productGetter)());
  else   (((const ::edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >*)o)->productGetter)();
}

static  void method_22617( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long)((((const ::edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >*)o)->key)());
  else   (((const ::edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >*)o)->key)();
}

static  void method_22618( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >*)o)->hasProductCache)());
  else   (((const ::edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >*)o)->hasProductCache)();
}

static  void method_22619( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >*)o)->refCore)();
  else   (((const ::edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >*)o)->refCore)();
}

static  void method_22620( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >*)o)->product)());
  else   (((const ::edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >*)o)->product)();
}

static  void method_22621( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >*)o)->ptr)();
  else   (((const ::edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >*)o)->ptr)();
}

static  void method_22622( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >*)o)->backPtr)();
  else   (((const ::edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >*)o)->backPtr)();
}

static  void method_22623( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >*)o)->Class_Version)());
  else   (((::edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >*)o)->Class_Version)();
}

static void method_newdel_4655( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class FwdPtr<reco::FFTAnyJet<reco::CaloJet> > -------------------------------
void __edm__FwdPtr_reco__FFTAnyJet_reco__CaloJet_s__db_datamem(Reflex::Class*);
void __edm__FwdPtr_reco__FFTAnyJet_reco__CaloJet_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__FwdPtr_reco__FFTAnyJet_reco__CaloJet_s__datamem_bld(&__edm__FwdPtr_reco__FFTAnyJet_reco__CaloJet_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__FwdPtr_reco__FFTAnyJet_reco__CaloJet_s__funcmem_bld(&__edm__FwdPtr_reco__FFTAnyJet_reco__CaloJet_s__db_funcmem);
void __edm__FwdPtr_reco__FFTAnyJet_reco__CaloJet_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >"), typeid(::edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >), sizeof(::edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >::Class_Version())
  .AddTypedef(type_358, Reflex::Literal("edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >::key_type"))
  .AddTypedef(type_7851, Reflex::Literal("edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13499, type_13501), Reflex::Literal("operator="), operator_22603, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13501), Reflex::Literal("FwdPtr"), constructor_22604, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("FwdPtr"), constructor_22605, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~FwdPtr"), destructor_22606, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4655, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__FwdPtr_reco__FFTAnyJet_reco__CaloJet_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__FwdPtr_reco__FFTAnyJet_reco__CaloJet_s__funcmem_bld);
}

//------Delayed data member builder for class FwdPtr<reco::FFTAnyJet<reco::CaloJet> > -------------------
void __edm__FwdPtr_reco__FFTAnyJet_reco__CaloJet_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4986, Reflex::Literal("ptr_"), OffsetOf(__shadow__::__edm__FwdPtr_reco__FFTAnyJet_reco__CaloJet_s_, ptr_), ::Reflex::PRIVATE)
  .AddDataMember(type_4986, Reflex::Literal("backPtr_"), OffsetOf(__shadow__::__edm__FwdPtr_reco__FFTAnyJet_reco__CaloJet_s_, backPtr_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class FwdPtr<reco::FFTAnyJet<reco::CaloJet> > -------------------
void __edm__FwdPtr_reco__FFTAnyJet_reco__CaloJet_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13631), Reflex::Literal("operator*"), operator_22607, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13627), Reflex::Literal("operator->"), operator_22608, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13627), Reflex::Literal("get"), method_22609, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isNull"), method_22610, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isNonnull"), method_22611, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("operator!"), operator_22612, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isAvailable"), method_22613, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isTransient"), method_22614, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4933), Reflex::Literal("id"), method_22615, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20675), Reflex::Literal("productGetter"), method_22616, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_358), Reflex::Literal("key"), method_22617, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("hasProductCache"), method_22618, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23940), Reflex::Literal("refCore"), method_22619, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4071), Reflex::Literal("product"), method_22620, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39229), Reflex::Literal("ptr"), method_22621, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39229), Reflex::Literal("backPtr"), method_22622, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_237), Reflex::Literal("Class_Version"), method_22623, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >,std::allocator<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > > -------------------------------
static void constructor_13510( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >();
  else ::new(mem) ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >();
}

static void constructor_13511( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >(*(const ::std::allocator<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >*)arg[0]);
  else ::new(mem) ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >(*(const ::std::allocator<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >*)arg[0]);
}

static void constructor_13512( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >(*(::std::size_t*)arg[0],
      *(const ::edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >*)arg[1]);
  else ::new(mem) ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >(*(::std::size_t*)arg[0],
      *(const ::edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >(*(::std::size_t*)arg[0],
      *(const ::edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >*)arg[1],
      *(const ::std::allocator<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >*)arg[2]);
  else ::new(mem) ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >(*(::std::size_t*)arg[0],
      *(const ::edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >*)arg[1],
      *(const ::std::allocator<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >*)arg[2]);
  }
}

static void constructor_13513( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >(*(const ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >*)arg[0]);
  else ::new(mem) ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >(*(const ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >*)arg[0]);
}

static void destructor_13514(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >*)o)->::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >::~vector)();
}
static  void operator_13515( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >*)o)->operator=)(*(const ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >*)arg[0]);
  else   (((::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >*)o)->operator=)(*(const ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >*)arg[0]);
}

static  void method_13516( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >*)arg[1]);
}

static  void method_13517( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >*,std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > >)((((::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >*)o)->begin)());
  else   (((::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >*)o)->begin)();
}

static  void method_13518( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >*,std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > >)((((const ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >*)o)->begin)());
  else   (((const ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >*)o)->begin)();
}

static  void method_13519( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >*,std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > >)((((::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >*)o)->end)());
  else   (((::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >*)o)->end)();
}

static  void method_13520( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >*,std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > >)((((const ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >*)o)->end)());
  else   (((const ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >*)o)->end)();
}

static  void method_13525( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >*)o)->size)());
  else   (((const ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >*)o)->size)();
}

static  void method_13526( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >*)o)->max_size)());
  else   (((const ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >*)o)->max_size)();
}

static  void method_13527( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >*)arg[1]);
  }
}

static  void method_13528( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >*)o)->capacity)());
  else   (((const ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >*)o)->capacity)();
}

static  void method_13529( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >*)o)->empty)());
  else   (((const ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >*)o)->empty)();
}

static  void method_13530( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_13531( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_13532( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_13534( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_13535( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_13536( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >*)o)->front)();
  else   (((::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >*)o)->front)();
}

static  void method_13537( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >*)o)->front)();
  else   (((const ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >*)o)->front)();
}

static  void method_13538( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >*)o)->back)();
  else   (((::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >*)o)->back)();
}

static  void method_13539( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >*)o)->back)();
  else   (((const ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >*)o)->back)();
}

static  void method_13540( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >*)o)->data)());
  else   (((::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >*)o)->data)();
}

static  void method_13541( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >*)o)->data)());
  else   (((const ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >*)o)->data)();
}

static  void method_13542( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >*)o)->push_back)(*(const ::edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >*)arg[0]);
}

static  void method_13543( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >*)o)->pop_back)();
}

static  void method_13544( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >*,std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > >)((((::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >*,std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > >*)arg[0],
    *(const ::edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >*)arg[1]));
  else   (((::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >*,std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > >*)arg[0],
    *(const ::edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >*)arg[1]);
}

static  void method_13545( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >*,std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >*)arg[2]);
}

static  void method_13546( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >*,std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > >)((((::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >*,std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > >*)arg[0]));
  else   (((::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >*,std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > >*)arg[0]);
}

static  void method_13547( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >*,std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > >)((((::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >*,std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >*,std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > >*)arg[1]));
  else   (((::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >*,std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >*,std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > >*)arg[1]);
}

static  void method_13548( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >*)o)->swap)(*(::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >*)arg[0]);
}

static  void method_13549( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >*)o)->clear)();
}

static void method_newdel_2981( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x104( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >,std::allocator<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > >")), ::Reflex::BaseOffset< ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >,::std::_Vector_base<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >,std::allocator<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x105( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > >::Generate();
  else ::Reflex::Proxy< ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > >::Generate();
}

//------Dictionary for class vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >,std::allocator<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > > -------------------------------
void __std__vector_edm__FwdPtr_reco__FFTAnyJet_reco__CaloJet_s_s__db_datamem(Reflex::Class*);
void __std__vector_edm__FwdPtr_reco__FFTAnyJet_reco__CaloJet_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_edm__FwdPtr_reco__FFTAnyJet_reco__CaloJet_s_s__datamem_bld(&__std__vector_edm__FwdPtr_reco__FFTAnyJet_reco__CaloJet_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_edm__FwdPtr_reco__FFTAnyJet_reco__CaloJet_s_s__funcmem_bld(&__std__vector_edm__FwdPtr_reco__FFTAnyJet_reco__CaloJet_s_s__db_funcmem);
void __std__vector_edm__FwdPtr_reco__FFTAnyJet_reco__CaloJet_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >"), typeid(::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >), sizeof(::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2484, ::Reflex::BaseOffset< ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >, ::std::_Vector_base<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >,std::allocator<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_4655, Reflex::Literal("std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >::_Alloc_value_type"))
  .AddTypedef(type_2484, Reflex::Literal("std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >::_Base"))
  .AddTypedef(type_3284, Reflex::Literal("std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >::_Tp_alloc_type"))
  .AddTypedef(type_8464, Reflex::Literal("std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >::_Alloc_traits"))
  .AddTypedef(type_4655, Reflex::Literal("std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >::value_type"))
  .AddTypedef(type_9343, Reflex::Literal("std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >::pointer"))
  .AddTypedef(type_13497, Reflex::Literal("std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >::const_pointer"))
  .AddTypedef(type_13499, Reflex::Literal("std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >::reference"))
  .AddTypedef(type_13501, Reflex::Literal("std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >::const_reference"))
  .AddTypedef(type_8294, Reflex::Literal("std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >::iterator"))
  .AddTypedef(type_8295, Reflex::Literal("std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >::const_iterator"))
  .AddTypedef(type_3503, Reflex::Literal("std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >::const_reverse_iterator"))
  .AddTypedef(type_3504, Reflex::Literal("std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >::reverse_iterator"))
  .AddTypedef(type_3254, Reflex::Literal("std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >::size_type"))
  .AddTypedef(type_3138, Reflex::Literal("std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >::difference_type"))
  .AddTypedef(type_3284, Reflex::Literal("std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_13510, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_34532), Reflex::Literal("vector"), constructor_13511, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3254, type_13501, type_34532), Reflex::Literal("vector"), constructor_13512, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35955), Reflex::Literal("vector"), constructor_13513, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_13514, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2981, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x104, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x105, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_edm__FwdPtr_reco__FFTAnyJet_reco__CaloJet_s_s__funcmem_bld);
}

//------Delayed data member builder for class vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >,std::allocator<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > > -------------------
void __std__vector_edm__FwdPtr_reco__FFTAnyJet_reco__CaloJet_s_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >,std::allocator<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > > -------------------
void __std__vector_edm__FwdPtr_reco__FFTAnyJet_reco__CaloJet_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35956, type_35955), Reflex::Literal("operator="), operator_13515, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_3254, type_13501), Reflex::Literal("assign"), method_13516, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8294), Reflex::Literal("begin"), method_13517, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8295), Reflex::Literal("begin"), method_13518, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8294), Reflex::Literal("end"), method_13519, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8295), Reflex::Literal("end"), method_13520, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3254), Reflex::Literal("size"), method_13525, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3254), Reflex::Literal("max_size"), method_13526, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_3254, type_4655), Reflex::Literal("resize"), method_13527, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3254), Reflex::Literal("capacity"), method_13528, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("empty"), method_13529, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_3254), Reflex::Literal("reserve"), method_13530, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13499, type_3254), Reflex::Literal("operator[]"), operator_13531, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13501, type_3254), Reflex::Literal("operator[]"), operator_13532, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13499, type_3254), Reflex::Literal("at"), method_13534, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13501, type_3254), Reflex::Literal("at"), method_13535, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13499), Reflex::Literal("front"), method_13536, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13501), Reflex::Literal("front"), method_13537, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13499), Reflex::Literal("back"), method_13538, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13501), Reflex::Literal("back"), method_13539, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9343), Reflex::Literal("data"), method_13540, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13497), Reflex::Literal("data"), method_13541, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_13501), Reflex::Literal("push_back"), method_13542, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694), Reflex::Literal("pop_back"), method_13543, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8294, type_8294, type_13501), Reflex::Literal("insert"), method_13544, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_8294, type_3254, type_13501), Reflex::Literal("insert"), method_13545, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8294, type_8294), Reflex::Literal("erase"), method_13546, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8294, type_8294, type_8294), Reflex::Literal("erase"), method_13547, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_35956), Reflex::Literal("swap"), method_13548, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694), Reflex::Literal("clear"), method_13549, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<reco::FFTAnyJet<reco::CaloJet>,std::allocator<reco::FFTAnyJet<reco::CaloJet> > > -------------------------------
static void constructor_13640( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::FFTAnyJet<reco::CaloJet> >();
  else ::new(mem) ::std::vector<reco::FFTAnyJet<reco::CaloJet> >();
}

static void constructor_13641( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::FFTAnyJet<reco::CaloJet> >(*(const ::std::allocator<reco::FFTAnyJet<reco::CaloJet> >*)arg[0]);
  else ::new(mem) ::std::vector<reco::FFTAnyJet<reco::CaloJet> >(*(const ::std::allocator<reco::FFTAnyJet<reco::CaloJet> >*)arg[0]);
}

static void constructor_13642( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::FFTAnyJet<reco::CaloJet> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<reco::FFTAnyJet<reco::CaloJet> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::FFTAnyJet<reco::CaloJet> >(*(::std::size_t*)arg[0],
      *(const ::reco::FFTAnyJet<reco::CaloJet>*)arg[1]);
  else ::new(mem) ::std::vector<reco::FFTAnyJet<reco::CaloJet> >(*(::std::size_t*)arg[0],
      *(const ::reco::FFTAnyJet<reco::CaloJet>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::FFTAnyJet<reco::CaloJet> >(*(::std::size_t*)arg[0],
      *(const ::reco::FFTAnyJet<reco::CaloJet>*)arg[1],
      *(const ::std::allocator<reco::FFTAnyJet<reco::CaloJet> >*)arg[2]);
  else ::new(mem) ::std::vector<reco::FFTAnyJet<reco::CaloJet> >(*(::std::size_t*)arg[0],
      *(const ::reco::FFTAnyJet<reco::CaloJet>*)arg[1],
      *(const ::std::allocator<reco::FFTAnyJet<reco::CaloJet> >*)arg[2]);
  }
}

static void constructor_13643( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::FFTAnyJet<reco::CaloJet> >(*(const ::std::vector<reco::FFTAnyJet<reco::CaloJet> >*)arg[0]);
  else ::new(mem) ::std::vector<reco::FFTAnyJet<reco::CaloJet> >(*(const ::std::vector<reco::FFTAnyJet<reco::CaloJet> >*)arg[0]);
}

static void destructor_13644(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<reco::FFTAnyJet<reco::CaloJet> >*)o)->::std::vector<reco::FFTAnyJet<reco::CaloJet> >::~vector)();
}
static  void operator_13645( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::FFTAnyJet<reco::CaloJet> >*)o)->operator=)(*(const ::std::vector<reco::FFTAnyJet<reco::CaloJet> >*)arg[0]);
  else   (((::std::vector<reco::FFTAnyJet<reco::CaloJet> >*)o)->operator=)(*(const ::std::vector<reco::FFTAnyJet<reco::CaloJet> >*)arg[0]);
}

static  void method_13646( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::FFTAnyJet<reco::CaloJet> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::reco::FFTAnyJet<reco::CaloJet>*)arg[1]);
}

static  void method_13647( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::FFTAnyJet<reco::CaloJet>*,std::vector<reco::FFTAnyJet<reco::CaloJet> > >)((((::std::vector<reco::FFTAnyJet<reco::CaloJet> >*)o)->begin)());
  else   (((::std::vector<reco::FFTAnyJet<reco::CaloJet> >*)o)->begin)();
}

static  void method_13648( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const reco::FFTAnyJet<reco::CaloJet>*,std::vector<reco::FFTAnyJet<reco::CaloJet> > >)((((const ::std::vector<reco::FFTAnyJet<reco::CaloJet> >*)o)->begin)());
  else   (((const ::std::vector<reco::FFTAnyJet<reco::CaloJet> >*)o)->begin)();
}

static  void method_13649( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::FFTAnyJet<reco::CaloJet>*,std::vector<reco::FFTAnyJet<reco::CaloJet> > >)((((::std::vector<reco::FFTAnyJet<reco::CaloJet> >*)o)->end)());
  else   (((::std::vector<reco::FFTAnyJet<reco::CaloJet> >*)o)->end)();
}

static  void method_13650( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const reco::FFTAnyJet<reco::CaloJet>*,std::vector<reco::FFTAnyJet<reco::CaloJet> > >)((((const ::std::vector<reco::FFTAnyJet<reco::CaloJet> >*)o)->end)());
  else   (((const ::std::vector<reco::FFTAnyJet<reco::CaloJet> >*)o)->end)();
}

static  void method_13655( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<reco::FFTAnyJet<reco::CaloJet> >*)o)->size)());
  else   (((const ::std::vector<reco::FFTAnyJet<reco::CaloJet> >*)o)->size)();
}

static  void method_13656( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<reco::FFTAnyJet<reco::CaloJet> >*)o)->max_size)());
  else   (((const ::std::vector<reco::FFTAnyJet<reco::CaloJet> >*)o)->max_size)();
}

static  void method_13657( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<reco::FFTAnyJet<reco::CaloJet> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<reco::FFTAnyJet<reco::CaloJet> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::reco::FFTAnyJet<reco::CaloJet>*)arg[1]);
  }
}

static  void method_13658( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<reco::FFTAnyJet<reco::CaloJet> >*)o)->capacity)());
  else   (((const ::std::vector<reco::FFTAnyJet<reco::CaloJet> >*)o)->capacity)();
}

static  void method_13659( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<reco::FFTAnyJet<reco::CaloJet> >*)o)->empty)());
  else   (((const ::std::vector<reco::FFTAnyJet<reco::CaloJet> >*)o)->empty)();
}

static  void method_13660( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::FFTAnyJet<reco::CaloJet> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_13661( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::FFTAnyJet<reco::CaloJet> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<reco::FFTAnyJet<reco::CaloJet> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_13662( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::FFTAnyJet<reco::CaloJet> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<reco::FFTAnyJet<reco::CaloJet> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_13664( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::FFTAnyJet<reco::CaloJet> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<reco::FFTAnyJet<reco::CaloJet> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_13665( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::FFTAnyJet<reco::CaloJet> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<reco::FFTAnyJet<reco::CaloJet> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_13666( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::FFTAnyJet<reco::CaloJet> >*)o)->front)();
  else   (((::std::vector<reco::FFTAnyJet<reco::CaloJet> >*)o)->front)();
}

static  void method_13667( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::FFTAnyJet<reco::CaloJet> >*)o)->front)();
  else   (((const ::std::vector<reco::FFTAnyJet<reco::CaloJet> >*)o)->front)();
}

static  void method_13668( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::FFTAnyJet<reco::CaloJet> >*)o)->back)();
  else   (((::std::vector<reco::FFTAnyJet<reco::CaloJet> >*)o)->back)();
}

static  void method_13669( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::FFTAnyJet<reco::CaloJet> >*)o)->back)();
  else   (((const ::std::vector<reco::FFTAnyJet<reco::CaloJet> >*)o)->back)();
}

static  void method_13670( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<reco::FFTAnyJet<reco::CaloJet> >*)o)->data)());
  else   (((::std::vector<reco::FFTAnyJet<reco::CaloJet> >*)o)->data)();
}

static  void method_13671( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<reco::FFTAnyJet<reco::CaloJet> >*)o)->data)());
  else   (((const ::std::vector<reco::FFTAnyJet<reco::CaloJet> >*)o)->data)();
}

static  void method_13672( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::FFTAnyJet<reco::CaloJet> >*)o)->push_back)(*(const ::reco::FFTAnyJet<reco::CaloJet>*)arg[0]);
}

static  void method_13673( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<reco::FFTAnyJet<reco::CaloJet> >*)o)->pop_back)();
}

static  void method_13674( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::FFTAnyJet<reco::CaloJet>*,std::vector<reco::FFTAnyJet<reco::CaloJet> > >)((((::std::vector<reco::FFTAnyJet<reco::CaloJet> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<reco::FFTAnyJet<reco::CaloJet>*,std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)arg[0],
    *(const ::reco::FFTAnyJet<reco::CaloJet>*)arg[1]));
  else   (((::std::vector<reco::FFTAnyJet<reco::CaloJet> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<reco::FFTAnyJet<reco::CaloJet>*,std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)arg[0],
    *(const ::reco::FFTAnyJet<reco::CaloJet>*)arg[1]);
}

static  void method_13675( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::FFTAnyJet<reco::CaloJet> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<reco::FFTAnyJet<reco::CaloJet>*,std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::reco::FFTAnyJet<reco::CaloJet>*)arg[2]);
}

static  void method_13676( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::FFTAnyJet<reco::CaloJet>*,std::vector<reco::FFTAnyJet<reco::CaloJet> > >)((((::std::vector<reco::FFTAnyJet<reco::CaloJet> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::FFTAnyJet<reco::CaloJet>*,std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)arg[0]));
  else   (((::std::vector<reco::FFTAnyJet<reco::CaloJet> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::FFTAnyJet<reco::CaloJet>*,std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)arg[0]);
}

static  void method_13677( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::FFTAnyJet<reco::CaloJet>*,std::vector<reco::FFTAnyJet<reco::CaloJet> > >)((((::std::vector<reco::FFTAnyJet<reco::CaloJet> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::FFTAnyJet<reco::CaloJet>*,std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<reco::FFTAnyJet<reco::CaloJet>*,std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)arg[1]));
  else   (((::std::vector<reco::FFTAnyJet<reco::CaloJet> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::FFTAnyJet<reco::CaloJet>*,std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<reco::FFTAnyJet<reco::CaloJet>*,std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)arg[1]);
}

static  void method_13678( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::FFTAnyJet<reco::CaloJet> >*)o)->swap)(*(::std::vector<reco::FFTAnyJet<reco::CaloJet> >*)arg[0]);
}

static  void method_13679( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<reco::FFTAnyJet<reco::CaloJet> >*)o)->clear)();
}

static void method_newdel_2983( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<reco::FFTAnyJet<reco::CaloJet> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<reco::FFTAnyJet<reco::CaloJet> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<reco::FFTAnyJet<reco::CaloJet> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<reco::FFTAnyJet<reco::CaloJet> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<reco::FFTAnyJet<reco::CaloJet> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x107( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<reco::FFTAnyJet<reco::CaloJet>,std::allocator<reco::FFTAnyJet<reco::CaloJet> > >")), ::Reflex::BaseOffset< ::std::vector<reco::FFTAnyJet<reco::CaloJet> >,::std::_Vector_base<reco::FFTAnyJet<reco::CaloJet>,std::allocator<reco::FFTAnyJet<reco::CaloJet> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x108( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<reco::FFTAnyJet<reco::CaloJet> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<reco::FFTAnyJet<reco::CaloJet> > >::Generate();
}

//------Dictionary for class vector<reco::FFTAnyJet<reco::CaloJet>,std::allocator<reco::FFTAnyJet<reco::CaloJet> > > -------------------------------
void __std__vector_reco__FFTAnyJet_reco__CaloJet_s__db_datamem(Reflex::Class*);
void __std__vector_reco__FFTAnyJet_reco__CaloJet_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_reco__FFTAnyJet_reco__CaloJet_s__datamem_bld(&__std__vector_reco__FFTAnyJet_reco__CaloJet_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_reco__FFTAnyJet_reco__CaloJet_s__funcmem_bld(&__std__vector_reco__FFTAnyJet_reco__CaloJet_s__db_funcmem);
void __std__vector_reco__FFTAnyJet_reco__CaloJet_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<reco::FFTAnyJet<reco::CaloJet> >"), typeid(::std::vector<reco::FFTAnyJet<reco::CaloJet> >), sizeof(::std::vector<reco::FFTAnyJet<reco::CaloJet> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2504, ::Reflex::BaseOffset< ::std::vector<reco::FFTAnyJet<reco::CaloJet> >, ::std::_Vector_base<reco::FFTAnyJet<reco::CaloJet>,std::allocator<reco::FFTAnyJet<reco::CaloJet> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_7851, Reflex::Literal("std::vector<reco::FFTAnyJet<reco::CaloJet> >::_Alloc_value_type"))
  .AddTypedef(type_2504, Reflex::Literal("std::vector<reco::FFTAnyJet<reco::CaloJet> >::_Base"))
  .AddTypedef(type_3286, Reflex::Literal("std::vector<reco::FFTAnyJet<reco::CaloJet> >::_Tp_alloc_type"))
  .AddTypedef(type_8484, Reflex::Literal("std::vector<reco::FFTAnyJet<reco::CaloJet> >::_Alloc_traits"))
  .AddTypedef(type_7851, Reflex::Literal("std::vector<reco::FFTAnyJet<reco::CaloJet> >::value_type"))
  .AddTypedef(type_9723, Reflex::Literal("std::vector<reco::FFTAnyJet<reco::CaloJet> >::pointer"))
  .AddTypedef(type_13627, Reflex::Literal("std::vector<reco::FFTAnyJet<reco::CaloJet> >::const_pointer"))
  .AddTypedef(type_13629, Reflex::Literal("std::vector<reco::FFTAnyJet<reco::CaloJet> >::reference"))
  .AddTypedef(type_13631, Reflex::Literal("std::vector<reco::FFTAnyJet<reco::CaloJet> >::const_reference"))
  .AddTypedef(type_8335, Reflex::Literal("std::vector<reco::FFTAnyJet<reco::CaloJet> >::iterator"))
  .AddTypedef(type_8336, Reflex::Literal("std::vector<reco::FFTAnyJet<reco::CaloJet> >::const_iterator"))
  .AddTypedef(type_3547, Reflex::Literal("std::vector<reco::FFTAnyJet<reco::CaloJet> >::const_reverse_iterator"))
  .AddTypedef(type_3548, Reflex::Literal("std::vector<reco::FFTAnyJet<reco::CaloJet> >::reverse_iterator"))
  .AddTypedef(type_3254, Reflex::Literal("std::vector<reco::FFTAnyJet<reco::CaloJet> >::size_type"))
  .AddTypedef(type_3138, Reflex::Literal("std::vector<reco::FFTAnyJet<reco::CaloJet> >::difference_type"))
  .AddTypedef(type_3286, Reflex::Literal("std::vector<reco::FFTAnyJet<reco::CaloJet> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_13640, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_34792), Reflex::Literal("vector"), constructor_13641, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3254, type_13631, type_34792), Reflex::Literal("vector"), constructor_13642, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20822), Reflex::Literal("vector"), constructor_13643, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_13644, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2983, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x107, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x108, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_reco__FFTAnyJet_reco__CaloJet_s__funcmem_bld);
}

//------Delayed data member builder for class vector<reco::FFTAnyJet<reco::CaloJet>,std::allocator<reco::FFTAnyJet<reco::CaloJet> > > -------------------
void __std__vector_reco__FFTAnyJet_reco__CaloJet_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<reco::FFTAnyJet<reco::CaloJet>,std::allocator<reco::FFTAnyJet<reco::CaloJet> > > -------------------
void __std__vector_reco__FFTAnyJet_reco__CaloJet_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35961, type_20822), Reflex::Literal("operator="), operator_13645, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_3254, type_13631), Reflex::Literal("assign"), method_13646, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8335), Reflex::Literal("begin"), method_13647, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8336), Reflex::Literal("begin"), method_13648, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8335), Reflex::Literal("end"), method_13649, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8336), Reflex::Literal("end"), method_13650, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3254), Reflex::Literal("size"), method_13655, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3254), Reflex::Literal("max_size"), method_13656, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_3254, type_7851), Reflex::Literal("resize"), method_13657, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3254), Reflex::Literal("capacity"), method_13658, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("empty"), method_13659, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_3254), Reflex::Literal("reserve"), method_13660, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13629, type_3254), Reflex::Literal("operator[]"), operator_13661, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13631, type_3254), Reflex::Literal("operator[]"), operator_13662, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13629, type_3254), Reflex::Literal("at"), method_13664, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13631, type_3254), Reflex::Literal("at"), method_13665, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13629), Reflex::Literal("front"), method_13666, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13631), Reflex::Literal("front"), method_13667, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13629), Reflex::Literal("back"), method_13668, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13631), Reflex::Literal("back"), method_13669, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9723), Reflex::Literal("data"), method_13670, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13627), Reflex::Literal("data"), method_13671, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_13631), Reflex::Literal("push_back"), method_13672, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694), Reflex::Literal("pop_back"), method_13673, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8335, type_8335, type_13631), Reflex::Literal("insert"), method_13674, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_8335, type_3254, type_13631), Reflex::Literal("insert"), method_13675, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8335, type_8335), Reflex::Literal("erase"), method_13676, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8335, type_8335, type_8335), Reflex::Literal("erase"), method_13677, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_35961), Reflex::Literal("swap"), method_13678, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694), Reflex::Literal("clear"), method_13679, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class FwdPtr<reco::FFTAnyJet<reco::GenJet> > -------------------------------
static  void operator_22628( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >*)o)->operator=)(*(const ::edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >*)arg[0]);
  else   (((::edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >*)o)->operator=)(*(const ::edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >*)arg[0]);
}

static void constructor_22629( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >(*(const ::edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >*)arg[0]);
  else ::new(mem) ::edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >(*(const ::edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >*)arg[0]);
}

static void constructor_22630( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >();
  else ::new(mem) ::edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >();
}

static void destructor_22631(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >*)o)->::edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >::~FwdPtr)();
}
static  void operator_22632( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >*)o)->operator*)();
  else   (((const ::edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >*)o)->operator*)();
}

static  void operator_22633( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >*)o)->operator->)());
  else   (((const ::edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >*)o)->operator->)();
}

static  void method_22634( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >*)o)->get)());
  else   (((const ::edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >*)o)->get)();
}

static  void method_22635( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >*)o)->isNull)());
  else   (((const ::edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >*)o)->isNull)();
}

static  void method_22636( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >*)o)->isNonnull)());
  else   (((const ::edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >*)o)->isNonnull)();
}

static  void operator_22637( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >*)o)->operator!)());
  else   (((const ::edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >*)o)->operator!)();
}

static  void method_22638( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >*)o)->isAvailable)());
  else   (((const ::edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >*)o)->isAvailable)();
}

static  void method_22639( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >*)o)->isTransient)());
  else   (((const ::edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >*)o)->isTransient)();
}

static  void method_22640( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >*)o)->id)());
  else   (((const ::edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >*)o)->id)();
}

static  void method_22641( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >*)o)->productGetter)());
  else   (((const ::edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >*)o)->productGetter)();
}

static  void method_22642( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long)((((const ::edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >*)o)->key)());
  else   (((const ::edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >*)o)->key)();
}

static  void method_22643( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >*)o)->hasProductCache)());
  else   (((const ::edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >*)o)->hasProductCache)();
}

static  void method_22644( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >*)o)->refCore)();
  else   (((const ::edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >*)o)->refCore)();
}

static  void method_22645( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >*)o)->product)());
  else   (((const ::edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >*)o)->product)();
}

static  void method_22646( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >*)o)->ptr)();
  else   (((const ::edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >*)o)->ptr)();
}

static  void method_22647( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >*)o)->backPtr)();
  else   (((const ::edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >*)o)->backPtr)();
}

static  void method_22648( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >*)o)->Class_Version)());
  else   (((::edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >*)o)->Class_Version)();
}

static void method_newdel_4656( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class FwdPtr<reco::FFTAnyJet<reco::GenJet> > -------------------------------
void __edm__FwdPtr_reco__FFTAnyJet_reco__GenJet_s__db_datamem(Reflex::Class*);
void __edm__FwdPtr_reco__FFTAnyJet_reco__GenJet_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__FwdPtr_reco__FFTAnyJet_reco__GenJet_s__datamem_bld(&__edm__FwdPtr_reco__FFTAnyJet_reco__GenJet_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__FwdPtr_reco__FFTAnyJet_reco__GenJet_s__funcmem_bld(&__edm__FwdPtr_reco__FFTAnyJet_reco__GenJet_s__db_funcmem);
void __edm__FwdPtr_reco__FFTAnyJet_reco__GenJet_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >"), typeid(::edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >), sizeof(::edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >::Class_Version())
  .AddTypedef(type_358, Reflex::Literal("edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >::key_type"))
  .AddTypedef(type_7811, Reflex::Literal("edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13694, type_13696), Reflex::Literal("operator="), operator_22628, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13696), Reflex::Literal("FwdPtr"), constructor_22629, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("FwdPtr"), constructor_22630, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~FwdPtr"), destructor_22631, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4656, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__FwdPtr_reco__FFTAnyJet_reco__GenJet_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__FwdPtr_reco__FFTAnyJet_reco__GenJet_s__funcmem_bld);
}

//------Delayed data member builder for class FwdPtr<reco::FFTAnyJet<reco::GenJet> > -------------------
void __edm__FwdPtr_reco__FFTAnyJet_reco__GenJet_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4987, Reflex::Literal("ptr_"), OffsetOf(__shadow__::__edm__FwdPtr_reco__FFTAnyJet_reco__GenJet_s_, ptr_), ::Reflex::PRIVATE)
  .AddDataMember(type_4987, Reflex::Literal("backPtr_"), OffsetOf(__shadow__::__edm__FwdPtr_reco__FFTAnyJet_reco__GenJet_s_, backPtr_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class FwdPtr<reco::FFTAnyJet<reco::GenJet> > -------------------
void __edm__FwdPtr_reco__FFTAnyJet_reco__GenJet_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13826), Reflex::Literal("operator*"), operator_22632, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13822), Reflex::Literal("operator->"), operator_22633, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13822), Reflex::Literal("get"), method_22634, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isNull"), method_22635, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isNonnull"), method_22636, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("operator!"), operator_22637, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isAvailable"), method_22638, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isTransient"), method_22639, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4933), Reflex::Literal("id"), method_22640, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20675), Reflex::Literal("productGetter"), method_22641, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_358), Reflex::Literal("key"), method_22642, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("hasProductCache"), method_22643, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23940), Reflex::Literal("refCore"), method_22644, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4071), Reflex::Literal("product"), method_22645, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39232), Reflex::Literal("ptr"), method_22646, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39232), Reflex::Literal("backPtr"), method_22647, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_237), Reflex::Literal("Class_Version"), method_22648, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >,std::allocator<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > > -------------------------------
static void constructor_13705( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >();
  else ::new(mem) ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >();
}

static void constructor_13706( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >(*(const ::std::allocator<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >*)arg[0]);
  else ::new(mem) ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >(*(const ::std::allocator<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >*)arg[0]);
}

static void constructor_13707( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >(*(::std::size_t*)arg[0],
      *(const ::edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >*)arg[1]);
  else ::new(mem) ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >(*(::std::size_t*)arg[0],
      *(const ::edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >(*(::std::size_t*)arg[0],
      *(const ::edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >*)arg[1],
      *(const ::std::allocator<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >*)arg[2]);
  else ::new(mem) ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >(*(::std::size_t*)arg[0],
      *(const ::edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >*)arg[1],
      *(const ::std::allocator<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >*)arg[2]);
  }
}

static void constructor_13708( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >(*(const ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >*)arg[0]);
  else ::new(mem) ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >(*(const ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >*)arg[0]);
}

static void destructor_13709(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >*)o)->::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >::~vector)();
}
static  void operator_13710( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >*)o)->operator=)(*(const ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >*)arg[0]);
  else   (((::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >*)o)->operator=)(*(const ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >*)arg[0]);
}

static  void method_13711( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >*)arg[1]);
}

static  void method_13712( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >*,std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > >)((((::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >*)o)->begin)());
  else   (((::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >*)o)->begin)();
}

static  void method_13713( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >*,std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > >)((((const ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >*)o)->begin)());
  else   (((const ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >*)o)->begin)();
}

static  void method_13714( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >*,std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > >)((((::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >*)o)->end)());
  else   (((::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >*)o)->end)();
}

static  void method_13715( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >*,std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > >)((((const ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >*)o)->end)());
  else   (((const ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >*)o)->end)();
}

static  void method_13720( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >*)o)->size)());
  else   (((const ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >*)o)->size)();
}

static  void method_13721( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >*)o)->max_size)());
  else   (((const ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >*)o)->max_size)();
}

static  void method_13722( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >*)arg[1]);
  }
}

static  void method_13723( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >*)o)->capacity)());
  else   (((const ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >*)o)->capacity)();
}

static  void method_13724( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >*)o)->empty)());
  else   (((const ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >*)o)->empty)();
}

static  void method_13725( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_13726( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_13727( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_13729( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_13730( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_13731( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >*)o)->front)();
  else   (((::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >*)o)->front)();
}

static  void method_13732( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >*)o)->front)();
  else   (((const ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >*)o)->front)();
}

static  void method_13733( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >*)o)->back)();
  else   (((::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >*)o)->back)();
}

static  void method_13734( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >*)o)->back)();
  else   (((const ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >*)o)->back)();
}

static  void method_13735( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >*)o)->data)());
  else   (((::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >*)o)->data)();
}

static  void method_13736( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >*)o)->data)());
  else   (((const ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >*)o)->data)();
}

static  void method_13737( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >*)o)->push_back)(*(const ::edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >*)arg[0]);
}

static  void method_13738( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >*)o)->pop_back)();
}

static  void method_13739( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >*,std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > >)((((::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >*,std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > >*)arg[0],
    *(const ::edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >*)arg[1]));
  else   (((::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >*,std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > >*)arg[0],
    *(const ::edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >*)arg[1]);
}

static  void method_13740( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >*,std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >*)arg[2]);
}

static  void method_13741( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >*,std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > >)((((::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >*,std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > >*)arg[0]));
  else   (((::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >*,std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > >*)arg[0]);
}

static  void method_13742( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >*,std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > >)((((::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >*,std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >*,std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > >*)arg[1]));
  else   (((::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >*,std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >*,std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > >*)arg[1]);
}

static  void method_13743( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >*)o)->swap)(*(::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >*)arg[0]);
}

static  void method_13744( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >*)o)->clear)();
}

static void method_newdel_2986( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x111( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >,std::allocator<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > >")), ::Reflex::BaseOffset< ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >,::std::_Vector_base<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >,std::allocator<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x112( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > >::Generate();
  else ::Reflex::Proxy< ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > >::Generate();
}

//------Dictionary for class vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >,std::allocator<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > > -------------------------------
void __std__vector_edm__FwdPtr_reco__FFTAnyJet_reco__GenJet_s_s__db_datamem(Reflex::Class*);
void __std__vector_edm__FwdPtr_reco__FFTAnyJet_reco__GenJet_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_edm__FwdPtr_reco__FFTAnyJet_reco__GenJet_s_s__datamem_bld(&__std__vector_edm__FwdPtr_reco__FFTAnyJet_reco__GenJet_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_edm__FwdPtr_reco__FFTAnyJet_reco__GenJet_s_s__funcmem_bld(&__std__vector_edm__FwdPtr_reco__FFTAnyJet_reco__GenJet_s_s__db_funcmem);
void __std__vector_edm__FwdPtr_reco__FFTAnyJet_reco__GenJet_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >"), typeid(::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >), sizeof(::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2486, ::Reflex::BaseOffset< ::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >, ::std::_Vector_base<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >,std::allocator<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_4656, Reflex::Literal("std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >::_Alloc_value_type"))
  .AddTypedef(type_2486, Reflex::Literal("std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >::_Base"))
  .AddTypedef(type_3293, Reflex::Literal("std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >::_Tp_alloc_type"))
  .AddTypedef(type_8466, Reflex::Literal("std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >::_Alloc_traits"))
  .AddTypedef(type_4656, Reflex::Literal("std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >::value_type"))
  .AddTypedef(type_9381, Reflex::Literal("std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >::pointer"))
  .AddTypedef(type_13692, Reflex::Literal("std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >::const_pointer"))
  .AddTypedef(type_13694, Reflex::Literal("std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >::reference"))
  .AddTypedef(type_13696, Reflex::Literal("std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >::const_reference"))
  .AddTypedef(type_8298, Reflex::Literal("std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >::iterator"))
  .AddTypedef(type_8299, Reflex::Literal("std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >::const_iterator"))
  .AddTypedef(type_3511, Reflex::Literal("std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >::const_reverse_iterator"))
  .AddTypedef(type_3512, Reflex::Literal("std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >::reverse_iterator"))
  .AddTypedef(type_3254, Reflex::Literal("std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >::size_type"))
  .AddTypedef(type_3138, Reflex::Literal("std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >::difference_type"))
  .AddTypedef(type_3293, Reflex::Literal("std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_13705, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_34558), Reflex::Literal("vector"), constructor_13706, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3254, type_13696, type_34558), Reflex::Literal("vector"), constructor_13707, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35963), Reflex::Literal("vector"), constructor_13708, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_13709, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2986, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x111, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x112, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_edm__FwdPtr_reco__FFTAnyJet_reco__GenJet_s_s__funcmem_bld);
}

//------Delayed data member builder for class vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >,std::allocator<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > > -------------------
void __std__vector_edm__FwdPtr_reco__FFTAnyJet_reco__GenJet_s_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >,std::allocator<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > > -------------------
void __std__vector_edm__FwdPtr_reco__FFTAnyJet_reco__GenJet_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35964, type_35963), Reflex::Literal("operator="), operator_13710, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_3254, type_13696), Reflex::Literal("assign"), method_13711, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8298), Reflex::Literal("begin"), method_13712, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8299), Reflex::Literal("begin"), method_13713, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8298), Reflex::Literal("end"), method_13714, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8299), Reflex::Literal("end"), method_13715, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3254), Reflex::Literal("size"), method_13720, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3254), Reflex::Literal("max_size"), method_13721, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_3254, type_4656), Reflex::Literal("resize"), method_13722, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3254), Reflex::Literal("capacity"), method_13723, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("empty"), method_13724, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_3254), Reflex::Literal("reserve"), method_13725, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13694, type_3254), Reflex::Literal("operator[]"), operator_13726, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13696, type_3254), Reflex::Literal("operator[]"), operator_13727, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13694, type_3254), Reflex::Literal("at"), method_13729, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13696, type_3254), Reflex::Literal("at"), method_13730, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13694), Reflex::Literal("front"), method_13731, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13696), Reflex::Literal("front"), method_13732, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13694), Reflex::Literal("back"), method_13733, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13696), Reflex::Literal("back"), method_13734, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9381), Reflex::Literal("data"), method_13735, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13692), Reflex::Literal("data"), method_13736, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_13696), Reflex::Literal("push_back"), method_13737, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694), Reflex::Literal("pop_back"), method_13738, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8298, type_8298, type_13696), Reflex::Literal("insert"), method_13739, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_8298, type_3254, type_13696), Reflex::Literal("insert"), method_13740, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8298, type_8298), Reflex::Literal("erase"), method_13741, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8298, type_8298, type_8298), Reflex::Literal("erase"), method_13742, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_35964), Reflex::Literal("swap"), method_13743, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694), Reflex::Literal("clear"), method_13744, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class Ref<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >, reco::FFTAnyJet<reco::GenJet> > > -------------------------------
static  void operator_25412( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->operator=)(*(const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)arg[0]);
  else   (((::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->operator=)(*(const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)arg[0]);
}

static void constructor_25413( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >(*(const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)arg[0]);
  else ::new(mem) ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >(*(const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)arg[0]);
}

static void constructor_25414( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >();
  else ::new(mem) ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >();
}

static void constructor_25415( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >(*(const ::edm::Handle<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >(*(const ::edm::Handle<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >(*(const ::edm::Handle<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >(*(const ::edm::Handle<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_25416( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >(*(const ::edm::OrphanHandle<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >(*(const ::edm::OrphanHandle<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >(*(const ::edm::OrphanHandle<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >(*(const ::edm::OrphanHandle<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_25417( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >(*(const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >(*(const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >(*(const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >(*(const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_25418( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >((const ::std::vector<reco::FFTAnyJet<reco::GenJet> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >((const ::std::vector<reco::FFTAnyJet<reco::GenJet> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >((const ::std::vector<reco::FFTAnyJet<reco::GenJet> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >((const ::std::vector<reco::FFTAnyJet<reco::GenJet> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_25419( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >(*(const ::edm::TestHandle<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >(*(const ::edm::TestHandle<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >(*(const ::edm::TestHandle<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >(*(const ::edm::TestHandle<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_25420( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >(*(const ::edm::ProductID*)arg[0],
      *(unsigned int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >(*(const ::edm::ProductID*)arg[0],
      *(unsigned int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
}

static void constructor_25421( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >(*(const ::edm::ProductID*)arg[0],
      (const ::reco::FFTAnyJet<reco::GenJet>*)arg[1],
      *(unsigned int*)arg[2],
      (const ::std::vector<reco::FFTAnyJet<reco::GenJet> >*)arg[3]);
  else ::new(mem) ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >(*(const ::edm::ProductID*)arg[0],
      (const ::reco::FFTAnyJet<reco::GenJet>*)arg[1],
      *(unsigned int*)arg[2],
      (const ::std::vector<reco::FFTAnyJet<reco::GenJet> >*)arg[3]);
}

static void constructor_25422( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_25423( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >(*(const ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >(*(const ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)arg[0],
      *(unsigned int*)arg[1]);
}

static void destructor_25424(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >::~Ref)();
}
static  void operator_25425( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->operator*)();
  else   (((const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->operator*)();
}

static  void operator_25426( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->operator->)());
  else   (((const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->operator->)();
}

static  void method_25427( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->get)());
  else   (((const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->get)();
}

static  void method_25428( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->isNull)());
  else   (((const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->isNull)();
}

static  void method_25429( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->isNonnull)());
  else   (((const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->isNonnull)();
}

static  void operator_25430( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->operator!)());
  else   (((const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->operator!)();
}

static  void method_25431( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->id)());
  else   (((const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->id)();
}

static  void method_25432( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->productGetter)());
  else   (((const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->productGetter)();
}

static  void method_25433( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->product)());
  else   (((const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->product)();
}

static  void method_25434( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->key)());
  else   (((const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->key)();
}

static  void method_25435( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->index)());
  else   (((const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->index)();
}

static  void method_25436( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->hasProductCache)());
  else   (((const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->hasProductCache)();
}

static  void method_25437( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->isAvailable)());
  else   (((const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->isAvailable)();
}

static  void method_25438( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->isTransient)());
  else   (((const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->isTransient)();
}

static  void method_25439( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->refCore)();
  else   (((const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->refCore)();
}

static  void method_25440( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->Class_Version)());
  else   (((::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)o)->Class_Version)();
}

static void constructor_25441( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >(*(const ::edm::RefCore*)arg[0],
      *(const unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >(*(const ::edm::RefCore*)arg[0],
      *(const unsigned int*)arg[1]);
}

static void method_newdel_5021( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Ref<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >, reco::FFTAnyJet<reco::GenJet> > > -------------------------------
void __edm__Ref_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s__db_datamem(Reflex::Class*);
void __edm__Ref_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Ref_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s__datamem_bld(&__edm__Ref_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Ref_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s__funcmem_bld(&__edm__Ref_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s__db_funcmem);
void __edm__Ref_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >"), typeid(::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >), sizeof(::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >::Class_Version())
  .AddTypedef(type_7811, Reflex::Literal("edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >::T"))
  .AddTypedef(type_20829, Reflex::Literal("edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >::F"))
  .AddTypedef(type_22255, Reflex::Literal("edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >::VF"))
  .AddTypedef(type_22254, Reflex::Literal("edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >::VBF"))
  .AddTypedef(type_2988, Reflex::Literal("edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >::product_type"))
  .AddTypedef(type_7811, Reflex::Literal("edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >::value_type"))
  .AddTypedef(type_7811c, Reflex::Literal("edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >::element_type"))
  .AddTypedef(type_20829, Reflex::Literal("edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >::finder_type"))
  .AddTypedef(type_366, Reflex::Literal("edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >::argument_type"))
  .AddTypedef(type_366, Reflex::Literal("edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >::key_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39929, type_38861), Reflex::Literal("operator="), operator_25412, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_38861), Reflex::Literal("Ref"), constructor_25413, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Ref"), constructor_25414, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39842, type_366, type_1566), Reflex::Literal("Ref"), constructor_25415, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39843, type_366, type_1566), Reflex::Literal("Ref"), constructor_25416, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39284, type_366, type_1566), Reflex::Literal("Ref"), constructor_25417, 0, "refvector;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39285, type_366, type_1566), Reflex::Literal("Ref"), constructor_25418, 0, "iProduct;iItemKey;iSetNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39844, type_366, type_1566), Reflex::Literal("Ref"), constructor_25419, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20599, type_366, type_20675), Reflex::Literal("Ref"), constructor_25420, 0, "productID;itemKey;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20599, type_13822, type_366, type_39285), Reflex::Literal("Ref"), constructor_25421, 0, "iProductID;;iItemKey;iProduct", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20599), Reflex::Literal("Ref"), constructor_25422, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39841, type_366), Reflex::Literal("Ref"), constructor_25423, 0, "refProd;itemKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Ref"), destructor_25424, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23940, type_10985), Reflex::Literal("Ref"), constructor_25441, 0, "iRefCore;iKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_5021, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Ref_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Ref_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s__funcmem_bld);
}

//------Delayed data member builder for class Ref<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >, reco::FFTAnyJet<reco::GenJet> > > -------------------
void __edm__Ref_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4624, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__Ref_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_, product_), ::Reflex::PRIVATE | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class Ref<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >, reco::FFTAnyJet<reco::GenJet> > > -------------------
void __edm__Ref_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13826), Reflex::Literal("operator*"), operator_25425, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13822), Reflex::Literal("operator->"), operator_25426, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13822), Reflex::Literal("get"), method_25427, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isNull"), method_25428, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isNonnull"), method_25429, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("operator!"), operator_25430, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4933), Reflex::Literal("id"), method_25431, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20675), Reflex::Literal("productGetter"), method_25432, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39285), Reflex::Literal("product"), method_25433, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_366), Reflex::Literal("key"), method_25434, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_366), Reflex::Literal("index"), method_25435, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("hasProductCache"), method_25436, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isAvailable"), method_25437, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isTransient"), method_25438, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23940), Reflex::Literal("refCore"), method_25439, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_237), Reflex::Literal("Class_Version"), method_25440, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >, reco::FFTAnyJet<reco::CaloJet>, edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >, reco::FFTAnyJet<reco::CaloJet> > >,std::allocator<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >, reco::FFTAnyJet<reco::CaloJet>, edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >, reco::FFTAnyJet<reco::CaloJet> > > > > -------------------------------
static void constructor_13575( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >();
  else ::new(mem) ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >();
}

static void constructor_13576( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >(*(const ::std::allocator<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)arg[0]);
  else ::new(mem) ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >(*(const ::std::allocator<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)arg[0]);
}

static void constructor_13577( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >(*(::std::size_t*)arg[0],
      *(const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)arg[1]);
  else ::new(mem) ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >(*(::std::size_t*)arg[0],
      *(const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >(*(::std::size_t*)arg[0],
      *(const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)arg[1],
      *(const ::std::allocator<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)arg[2]);
  else ::new(mem) ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >(*(::std::size_t*)arg[0],
      *(const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)arg[1],
      *(const ::std::allocator<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)arg[2]);
  }
}

static void constructor_13578( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >(*(const ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)arg[0]);
  else ::new(mem) ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >(*(const ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)arg[0]);
}

static void destructor_13579(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >::~vector)();
}
static  void operator_13580( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->operator=)(*(const ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)arg[0]);
  else   (((::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->operator=)(*(const ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)arg[0]);
}

static  void method_13581( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)arg[1]);
}

static  void method_13582( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*,std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >)((((::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->begin)());
  else   (((::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->begin)();
}

static  void method_13583( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*,std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >)((((const ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->begin)());
  else   (((const ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->begin)();
}

static  void method_13584( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*,std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >)((((::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->end)());
  else   (((::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->end)();
}

static  void method_13585( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*,std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >)((((const ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->end)());
  else   (((const ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->end)();
}

static  void method_13590( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->size)());
  else   (((const ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->size)();
}

static  void method_13591( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->max_size)());
  else   (((const ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->max_size)();
}

static  void method_13592( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)arg[1]);
  }
}

static  void method_13593( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->capacity)());
  else   (((const ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->capacity)();
}

static  void method_13594( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->empty)());
  else   (((const ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->empty)();
}

static  void method_13595( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_13596( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_13597( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_13599( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_13600( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_13601( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->front)();
  else   (((::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->front)();
}

static  void method_13602( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->front)();
  else   (((const ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->front)();
}

static  void method_13603( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->back)();
  else   (((::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->back)();
}

static  void method_13604( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->back)();
  else   (((const ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->back)();
}

static  void method_13605( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->data)());
  else   (((::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->data)();
}

static  void method_13606( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->data)());
  else   (((const ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->data)();
}

static  void method_13607( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->push_back)(*(const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)arg[0]);
}

static  void method_13608( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->pop_back)();
}

static  void method_13609( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*,std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >)((((::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*,std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >*)arg[0],
    *(const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)arg[1]));
  else   (((::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*,std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >*)arg[0],
    *(const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)arg[1]);
}

static  void method_13610( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*,std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)arg[2]);
}

static  void method_13611( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*,std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >)((((::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*,std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >*)arg[0]));
  else   (((::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*,std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >*)arg[0]);
}

static  void method_13612( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*,std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >)((((::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*,std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*,std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >*)arg[1]));
  else   (((::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*,std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*,std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >*)arg[1]);
}

static  void method_13613( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->swap)(*(::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)arg[0]);
}

static  void method_13614( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->clear)();
}

static void method_newdel_2982( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x115( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >,std::allocator<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >")), ::Reflex::BaseOffset< ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >,::std::_Vector_base<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >,std::allocator<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x116( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >::Generate();
  else ::Reflex::Proxy< ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >::Generate();
}

//------Dictionary for class vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >, reco::FFTAnyJet<reco::CaloJet>, edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >, reco::FFTAnyJet<reco::CaloJet> > >,std::allocator<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >, reco::FFTAnyJet<reco::CaloJet>, edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >, reco::FFTAnyJet<reco::CaloJet> > > > > -------------------------------
void __std__vector_edm__FwdRef_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s__db_datamem(Reflex::Class*);
void __std__vector_edm__FwdRef_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_edm__FwdRef_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s__datamem_bld(&__std__vector_edm__FwdRef_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_edm__FwdRef_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s__funcmem_bld(&__std__vector_edm__FwdRef_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s__db_funcmem);
void __std__vector_edm__FwdRef_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >"), typeid(::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >), sizeof(::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2485, ::Reflex::BaseOffset< ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >, ::std::_Vector_base<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >,std::allocator<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_4774, Reflex::Literal("std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >::_Alloc_value_type"))
  .AddTypedef(type_2485, Reflex::Literal("std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >::_Base"))
  .AddTypedef(type_3285, Reflex::Literal("std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >::_Tp_alloc_type"))
  .AddTypedef(type_8465, Reflex::Literal("std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >::_Alloc_traits"))
  .AddTypedef(type_4774, Reflex::Literal("std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >::value_type"))
  .AddTypedef(type_9362, Reflex::Literal("std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >::pointer"))
  .AddTypedef(type_13562, Reflex::Literal("std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >::const_pointer"))
  .AddTypedef(type_13564, Reflex::Literal("std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >::reference"))
  .AddTypedef(type_13566, Reflex::Literal("std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >::const_reference"))
  .AddTypedef(type_8296, Reflex::Literal("std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >::iterator"))
  .AddTypedef(type_8297, Reflex::Literal("std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >::const_iterator"))
  .AddTypedef(type_3505, Reflex::Literal("std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >::const_reverse_iterator"))
  .AddTypedef(type_3506, Reflex::Literal("std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >::reverse_iterator"))
  .AddTypedef(type_3254, Reflex::Literal("std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >::size_type"))
  .AddTypedef(type_3138, Reflex::Literal("std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >::difference_type"))
  .AddTypedef(type_3285, Reflex::Literal("std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_13575, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_34545), Reflex::Literal("vector"), constructor_13576, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3254, type_13566, type_34545), Reflex::Literal("vector"), constructor_13577, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35958), Reflex::Literal("vector"), constructor_13578, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_13579, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2982, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x115, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x116, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_edm__FwdRef_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s__funcmem_bld);
}

//------Delayed data member builder for class vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >, reco::FFTAnyJet<reco::CaloJet>, edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >, reco::FFTAnyJet<reco::CaloJet> > >,std::allocator<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >, reco::FFTAnyJet<reco::CaloJet>, edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >, reco::FFTAnyJet<reco::CaloJet> > > > > -------------------
void __std__vector_edm__FwdRef_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >, reco::FFTAnyJet<reco::CaloJet>, edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >, reco::FFTAnyJet<reco::CaloJet> > >,std::allocator<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >, reco::FFTAnyJet<reco::CaloJet>, edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >, reco::FFTAnyJet<reco::CaloJet> > > > > -------------------
void __std__vector_edm__FwdRef_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35959, type_35958), Reflex::Literal("operator="), operator_13580, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_3254, type_13566), Reflex::Literal("assign"), method_13581, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8296), Reflex::Literal("begin"), method_13582, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8297), Reflex::Literal("begin"), method_13583, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8296), Reflex::Literal("end"), method_13584, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8297), Reflex::Literal("end"), method_13585, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3254), Reflex::Literal("size"), method_13590, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3254), Reflex::Literal("max_size"), method_13591, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_3254, type_4774), Reflex::Literal("resize"), method_13592, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3254), Reflex::Literal("capacity"), method_13593, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("empty"), method_13594, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_3254), Reflex::Literal("reserve"), method_13595, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13564, type_3254), Reflex::Literal("operator[]"), operator_13596, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13566, type_3254), Reflex::Literal("operator[]"), operator_13597, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13564, type_3254), Reflex::Literal("at"), method_13599, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13566, type_3254), Reflex::Literal("at"), method_13600, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13564), Reflex::Literal("front"), method_13601, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13566), Reflex::Literal("front"), method_13602, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13564), Reflex::Literal("back"), method_13603, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13566), Reflex::Literal("back"), method_13604, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9362), Reflex::Literal("data"), method_13605, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13562), Reflex::Literal("data"), method_13606, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_13566), Reflex::Literal("push_back"), method_13607, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694), Reflex::Literal("pop_back"), method_13608, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8296, type_8296, type_13566), Reflex::Literal("insert"), method_13609, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_8296, type_3254, type_13566), Reflex::Literal("insert"), method_13610, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8296, type_8296), Reflex::Literal("erase"), method_13611, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8296, type_8296, type_8296), Reflex::Literal("erase"), method_13612, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_35959), Reflex::Literal("swap"), method_13613, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694), Reflex::Literal("clear"), method_13614, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<reco::FFTAnyJet<reco::GenJet>,std::allocator<reco::FFTAnyJet<reco::GenJet> > > -------------------------------
static void constructor_13835( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::FFTAnyJet<reco::GenJet> >();
  else ::new(mem) ::std::vector<reco::FFTAnyJet<reco::GenJet> >();
}

static void constructor_13836( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::FFTAnyJet<reco::GenJet> >(*(const ::std::allocator<reco::FFTAnyJet<reco::GenJet> >*)arg[0]);
  else ::new(mem) ::std::vector<reco::FFTAnyJet<reco::GenJet> >(*(const ::std::allocator<reco::FFTAnyJet<reco::GenJet> >*)arg[0]);
}

static void constructor_13837( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::FFTAnyJet<reco::GenJet> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<reco::FFTAnyJet<reco::GenJet> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::FFTAnyJet<reco::GenJet> >(*(::std::size_t*)arg[0],
      *(const ::reco::FFTAnyJet<reco::GenJet>*)arg[1]);
  else ::new(mem) ::std::vector<reco::FFTAnyJet<reco::GenJet> >(*(::std::size_t*)arg[0],
      *(const ::reco::FFTAnyJet<reco::GenJet>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::FFTAnyJet<reco::GenJet> >(*(::std::size_t*)arg[0],
      *(const ::reco::FFTAnyJet<reco::GenJet>*)arg[1],
      *(const ::std::allocator<reco::FFTAnyJet<reco::GenJet> >*)arg[2]);
  else ::new(mem) ::std::vector<reco::FFTAnyJet<reco::GenJet> >(*(::std::size_t*)arg[0],
      *(const ::reco::FFTAnyJet<reco::GenJet>*)arg[1],
      *(const ::std::allocator<reco::FFTAnyJet<reco::GenJet> >*)arg[2]);
  }
}

static void constructor_13838( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::FFTAnyJet<reco::GenJet> >(*(const ::std::vector<reco::FFTAnyJet<reco::GenJet> >*)arg[0]);
  else ::new(mem) ::std::vector<reco::FFTAnyJet<reco::GenJet> >(*(const ::std::vector<reco::FFTAnyJet<reco::GenJet> >*)arg[0]);
}

static void destructor_13839(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<reco::FFTAnyJet<reco::GenJet> >*)o)->::std::vector<reco::FFTAnyJet<reco::GenJet> >::~vector)();
}
static  void operator_13840( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::FFTAnyJet<reco::GenJet> >*)o)->operator=)(*(const ::std::vector<reco::FFTAnyJet<reco::GenJet> >*)arg[0]);
  else   (((::std::vector<reco::FFTAnyJet<reco::GenJet> >*)o)->operator=)(*(const ::std::vector<reco::FFTAnyJet<reco::GenJet> >*)arg[0]);
}

static  void method_13841( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::FFTAnyJet<reco::GenJet> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::reco::FFTAnyJet<reco::GenJet>*)arg[1]);
}

static  void method_13842( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::FFTAnyJet<reco::GenJet>*,std::vector<reco::FFTAnyJet<reco::GenJet> > >)((((::std::vector<reco::FFTAnyJet<reco::GenJet> >*)o)->begin)());
  else   (((::std::vector<reco::FFTAnyJet<reco::GenJet> >*)o)->begin)();
}

static  void method_13843( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const reco::FFTAnyJet<reco::GenJet>*,std::vector<reco::FFTAnyJet<reco::GenJet> > >)((((const ::std::vector<reco::FFTAnyJet<reco::GenJet> >*)o)->begin)());
  else   (((const ::std::vector<reco::FFTAnyJet<reco::GenJet> >*)o)->begin)();
}

static  void method_13844( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::FFTAnyJet<reco::GenJet>*,std::vector<reco::FFTAnyJet<reco::GenJet> > >)((((::std::vector<reco::FFTAnyJet<reco::GenJet> >*)o)->end)());
  else   (((::std::vector<reco::FFTAnyJet<reco::GenJet> >*)o)->end)();
}

static  void method_13845( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const reco::FFTAnyJet<reco::GenJet>*,std::vector<reco::FFTAnyJet<reco::GenJet> > >)((((const ::std::vector<reco::FFTAnyJet<reco::GenJet> >*)o)->end)());
  else   (((const ::std::vector<reco::FFTAnyJet<reco::GenJet> >*)o)->end)();
}

static  void method_13850( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<reco::FFTAnyJet<reco::GenJet> >*)o)->size)());
  else   (((const ::std::vector<reco::FFTAnyJet<reco::GenJet> >*)o)->size)();
}

static  void method_13851( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<reco::FFTAnyJet<reco::GenJet> >*)o)->max_size)());
  else   (((const ::std::vector<reco::FFTAnyJet<reco::GenJet> >*)o)->max_size)();
}

static  void method_13852( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<reco::FFTAnyJet<reco::GenJet> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<reco::FFTAnyJet<reco::GenJet> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::reco::FFTAnyJet<reco::GenJet>*)arg[1]);
  }
}

static  void method_13853( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<reco::FFTAnyJet<reco::GenJet> >*)o)->capacity)());
  else   (((const ::std::vector<reco::FFTAnyJet<reco::GenJet> >*)o)->capacity)();
}

static  void method_13854( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<reco::FFTAnyJet<reco::GenJet> >*)o)->empty)());
  else   (((const ::std::vector<reco::FFTAnyJet<reco::GenJet> >*)o)->empty)();
}

static  void method_13855( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::FFTAnyJet<reco::GenJet> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_13856( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::FFTAnyJet<reco::GenJet> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<reco::FFTAnyJet<reco::GenJet> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_13857( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::FFTAnyJet<reco::GenJet> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<reco::FFTAnyJet<reco::GenJet> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_13859( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::FFTAnyJet<reco::GenJet> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<reco::FFTAnyJet<reco::GenJet> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_13860( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::FFTAnyJet<reco::GenJet> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<reco::FFTAnyJet<reco::GenJet> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_13861( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::FFTAnyJet<reco::GenJet> >*)o)->front)();
  else   (((::std::vector<reco::FFTAnyJet<reco::GenJet> >*)o)->front)();
}

static  void method_13862( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::FFTAnyJet<reco::GenJet> >*)o)->front)();
  else   (((const ::std::vector<reco::FFTAnyJet<reco::GenJet> >*)o)->front)();
}

static  void method_13863( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::FFTAnyJet<reco::GenJet> >*)o)->back)();
  else   (((::std::vector<reco::FFTAnyJet<reco::GenJet> >*)o)->back)();
}

static  void method_13864( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::FFTAnyJet<reco::GenJet> >*)o)->back)();
  else   (((const ::std::vector<reco::FFTAnyJet<reco::GenJet> >*)o)->back)();
}

static  void method_13865( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<reco::FFTAnyJet<reco::GenJet> >*)o)->data)());
  else   (((::std::vector<reco::FFTAnyJet<reco::GenJet> >*)o)->data)();
}

static  void method_13866( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<reco::FFTAnyJet<reco::GenJet> >*)o)->data)());
  else   (((const ::std::vector<reco::FFTAnyJet<reco::GenJet> >*)o)->data)();
}

static  void method_13867( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::FFTAnyJet<reco::GenJet> >*)o)->push_back)(*(const ::reco::FFTAnyJet<reco::GenJet>*)arg[0]);
}

static  void method_13868( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<reco::FFTAnyJet<reco::GenJet> >*)o)->pop_back)();
}

static  void method_13869( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::FFTAnyJet<reco::GenJet>*,std::vector<reco::FFTAnyJet<reco::GenJet> > >)((((::std::vector<reco::FFTAnyJet<reco::GenJet> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<reco::FFTAnyJet<reco::GenJet>*,std::vector<reco::FFTAnyJet<reco::GenJet> > >*)arg[0],
    *(const ::reco::FFTAnyJet<reco::GenJet>*)arg[1]));
  else   (((::std::vector<reco::FFTAnyJet<reco::GenJet> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<reco::FFTAnyJet<reco::GenJet>*,std::vector<reco::FFTAnyJet<reco::GenJet> > >*)arg[0],
    *(const ::reco::FFTAnyJet<reco::GenJet>*)arg[1]);
}

static  void method_13870( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::FFTAnyJet<reco::GenJet> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<reco::FFTAnyJet<reco::GenJet>*,std::vector<reco::FFTAnyJet<reco::GenJet> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::reco::FFTAnyJet<reco::GenJet>*)arg[2]);
}

static  void method_13871( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::FFTAnyJet<reco::GenJet>*,std::vector<reco::FFTAnyJet<reco::GenJet> > >)((((::std::vector<reco::FFTAnyJet<reco::GenJet> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::FFTAnyJet<reco::GenJet>*,std::vector<reco::FFTAnyJet<reco::GenJet> > >*)arg[0]));
  else   (((::std::vector<reco::FFTAnyJet<reco::GenJet> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::FFTAnyJet<reco::GenJet>*,std::vector<reco::FFTAnyJet<reco::GenJet> > >*)arg[0]);
}

static  void method_13872( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::FFTAnyJet<reco::GenJet>*,std::vector<reco::FFTAnyJet<reco::GenJet> > >)((((::std::vector<reco::FFTAnyJet<reco::GenJet> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::FFTAnyJet<reco::GenJet>*,std::vector<reco::FFTAnyJet<reco::GenJet> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<reco::FFTAnyJet<reco::GenJet>*,std::vector<reco::FFTAnyJet<reco::GenJet> > >*)arg[1]));
  else   (((::std::vector<reco::FFTAnyJet<reco::GenJet> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::FFTAnyJet<reco::GenJet>*,std::vector<reco::FFTAnyJet<reco::GenJet> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<reco::FFTAnyJet<reco::GenJet>*,std::vector<reco::FFTAnyJet<reco::GenJet> > >*)arg[1]);
}

static  void method_13873( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::FFTAnyJet<reco::GenJet> >*)o)->swap)(*(::std::vector<reco::FFTAnyJet<reco::GenJet> >*)arg[0]);
}

static  void method_13874( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<reco::FFTAnyJet<reco::GenJet> >*)o)->clear)();
}

static void method_newdel_2988( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<reco::FFTAnyJet<reco::GenJet> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<reco::FFTAnyJet<reco::GenJet> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<reco::FFTAnyJet<reco::GenJet> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<reco::FFTAnyJet<reco::GenJet> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<reco::FFTAnyJet<reco::GenJet> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x118( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<reco::FFTAnyJet<reco::GenJet>,std::allocator<reco::FFTAnyJet<reco::GenJet> > >")), ::Reflex::BaseOffset< ::std::vector<reco::FFTAnyJet<reco::GenJet> >,::std::_Vector_base<reco::FFTAnyJet<reco::GenJet>,std::allocator<reco::FFTAnyJet<reco::GenJet> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x119( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<reco::FFTAnyJet<reco::GenJet> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<reco::FFTAnyJet<reco::GenJet> > >::Generate();
}

//------Dictionary for class vector<reco::FFTAnyJet<reco::GenJet>,std::allocator<reco::FFTAnyJet<reco::GenJet> > > -------------------------------
void __std__vector_reco__FFTAnyJet_reco__GenJet_s__db_datamem(Reflex::Class*);
void __std__vector_reco__FFTAnyJet_reco__GenJet_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_reco__FFTAnyJet_reco__GenJet_s__datamem_bld(&__std__vector_reco__FFTAnyJet_reco__GenJet_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_reco__FFTAnyJet_reco__GenJet_s__funcmem_bld(&__std__vector_reco__FFTAnyJet_reco__GenJet_s__db_funcmem);
void __std__vector_reco__FFTAnyJet_reco__GenJet_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<reco::FFTAnyJet<reco::GenJet> >"), typeid(::std::vector<reco::FFTAnyJet<reco::GenJet> >), sizeof(::std::vector<reco::FFTAnyJet<reco::GenJet> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2503, ::Reflex::BaseOffset< ::std::vector<reco::FFTAnyJet<reco::GenJet> >, ::std::_Vector_base<reco::FFTAnyJet<reco::GenJet>,std::allocator<reco::FFTAnyJet<reco::GenJet> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_7811, Reflex::Literal("std::vector<reco::FFTAnyJet<reco::GenJet> >::_Alloc_value_type"))
  .AddTypedef(type_2503, Reflex::Literal("std::vector<reco::FFTAnyJet<reco::GenJet> >::_Base"))
  .AddTypedef(type_3295, Reflex::Literal("std::vector<reco::FFTAnyJet<reco::GenJet> >::_Tp_alloc_type"))
  .AddTypedef(type_8483, Reflex::Literal("std::vector<reco::FFTAnyJet<reco::GenJet> >::_Alloc_traits"))
  .AddTypedef(type_7811, Reflex::Literal("std::vector<reco::FFTAnyJet<reco::GenJet> >::value_type"))
  .AddTypedef(type_9704, Reflex::Literal("std::vector<reco::FFTAnyJet<reco::GenJet> >::pointer"))
  .AddTypedef(type_13822, Reflex::Literal("std::vector<reco::FFTAnyJet<reco::GenJet> >::const_pointer"))
  .AddTypedef(type_13824, Reflex::Literal("std::vector<reco::FFTAnyJet<reco::GenJet> >::reference"))
  .AddTypedef(type_13826, Reflex::Literal("std::vector<reco::FFTAnyJet<reco::GenJet> >::const_reference"))
  .AddTypedef(type_8333, Reflex::Literal("std::vector<reco::FFTAnyJet<reco::GenJet> >::iterator"))
  .AddTypedef(type_8334, Reflex::Literal("std::vector<reco::FFTAnyJet<reco::GenJet> >::const_iterator"))
  .AddTypedef(type_3545, Reflex::Literal("std::vector<reco::FFTAnyJet<reco::GenJet> >::const_reverse_iterator"))
  .AddTypedef(type_3546, Reflex::Literal("std::vector<reco::FFTAnyJet<reco::GenJet> >::reverse_iterator"))
  .AddTypedef(type_3254, Reflex::Literal("std::vector<reco::FFTAnyJet<reco::GenJet> >::size_type"))
  .AddTypedef(type_3138, Reflex::Literal("std::vector<reco::FFTAnyJet<reco::GenJet> >::difference_type"))
  .AddTypedef(type_3295, Reflex::Literal("std::vector<reco::FFTAnyJet<reco::GenJet> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_13835, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_34779), Reflex::Literal("vector"), constructor_13836, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3254, type_13826, type_34779), Reflex::Literal("vector"), constructor_13837, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20834), Reflex::Literal("vector"), constructor_13838, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_13839, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2988, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x118, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x119, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_reco__FFTAnyJet_reco__GenJet_s__funcmem_bld);
}

//------Delayed data member builder for class vector<reco::FFTAnyJet<reco::GenJet>,std::allocator<reco::FFTAnyJet<reco::GenJet> > > -------------------
void __std__vector_reco__FFTAnyJet_reco__GenJet_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<reco::FFTAnyJet<reco::GenJet>,std::allocator<reco::FFTAnyJet<reco::GenJet> > > -------------------
void __std__vector_reco__FFTAnyJet_reco__GenJet_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35969, type_20834), Reflex::Literal("operator="), operator_13840, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_3254, type_13826), Reflex::Literal("assign"), method_13841, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8333), Reflex::Literal("begin"), method_13842, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8334), Reflex::Literal("begin"), method_13843, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8333), Reflex::Literal("end"), method_13844, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8334), Reflex::Literal("end"), method_13845, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3254), Reflex::Literal("size"), method_13850, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3254), Reflex::Literal("max_size"), method_13851, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_3254, type_7811), Reflex::Literal("resize"), method_13852, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3254), Reflex::Literal("capacity"), method_13853, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("empty"), method_13854, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_3254), Reflex::Literal("reserve"), method_13855, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13824, type_3254), Reflex::Literal("operator[]"), operator_13856, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13826, type_3254), Reflex::Literal("operator[]"), operator_13857, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13824, type_3254), Reflex::Literal("at"), method_13859, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13826, type_3254), Reflex::Literal("at"), method_13860, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13824), Reflex::Literal("front"), method_13861, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13826), Reflex::Literal("front"), method_13862, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13824), Reflex::Literal("back"), method_13863, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13826), Reflex::Literal("back"), method_13864, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9704), Reflex::Literal("data"), method_13865, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13822), Reflex::Literal("data"), method_13866, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_13826), Reflex::Literal("push_back"), method_13867, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694), Reflex::Literal("pop_back"), method_13868, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8333, type_8333, type_13826), Reflex::Literal("insert"), method_13869, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_8333, type_3254, type_13826), Reflex::Literal("insert"), method_13870, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8333, type_8333), Reflex::Literal("erase"), method_13871, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8333, type_8333, type_8333), Reflex::Literal("erase"), method_13872, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_35969), Reflex::Literal("swap"), method_13873, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694), Reflex::Literal("clear"), method_13874, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class RefProd<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > > > -------------------------------
static  void operator_24414( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefProd<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->operator=)(*(const ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)arg[0]);
  else   (((::edm::RefProd<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->operator=)(*(const ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)arg[0]);
}

static void constructor_24415( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::GenJet> > >(*(const ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::GenJet> > >(*(const ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)arg[0]);
}

static void constructor_24416( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::GenJet> > >();
  else ::new(mem) ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::GenJet> > >();
}

static void constructor_24417( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::GenJet> > >(*(const ::edm::Handle<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::GenJet> > >(*(const ::edm::Handle<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)arg[0]);
}

static void constructor_24418( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::GenJet> > >(*(const ::edm::OrphanHandle<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::GenJet> > >(*(const ::edm::OrphanHandle<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)arg[0]);
}

static void constructor_24419( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::GenJet> > >((const ::std::vector<reco::FFTAnyJet<reco::GenJet> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::GenJet> > >((const ::std::vector<reco::FFTAnyJet<reco::GenJet> >*)arg[0]);
}

static void constructor_24420( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::GenJet> > >(*(const ::edm::TestHandle<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::GenJet> > >(*(const ::edm::TestHandle<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)arg[0]);
}

static void constructor_24421( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::GenJet> > >(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
  else ::new(mem) ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::GenJet> > >(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
}

static void destructor_24422(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefProd<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->::edm::RefProd<std::vector<reco::FFTAnyJet<reco::GenJet> > >::~RefProd)();
}
static  void operator_24423( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->operator*)();
  else   (((const ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->operator*)();
}

static  void operator_24424( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->operator->)());
  else   (((const ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->operator->)();
}

static  void method_24425( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->get)());
  else   (((const ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->get)();
}

static  void method_24426( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->product)());
  else   (((const ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->product)();
}

static  void method_24427( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->refCore)();
  else   (((const ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->refCore)();
}

static  void method_24428( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->isNull)());
  else   (((const ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->isNull)();
}

static  void method_24429( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->isNonnull)());
  else   (((const ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->isNonnull)();
}

static  void operator_24430( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->operator!)());
  else   (((const ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->operator!)();
}

static  void method_24431( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->id)());
  else   (((const ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->id)();
}

static  void method_24432( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->productGetter)());
  else   (((const ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->productGetter)();
}

static  void method_24433( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->hasCache)());
  else   (((const ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->hasCache)();
}

static  void method_24434( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->hasProductCache)());
  else   (((const ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->hasProductCache)();
}

static  void method_24435( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->isAvailable)());
  else   (((const ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->isAvailable)();
}

static  void method_24436( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->isTransient)());
  else   (((const ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->isTransient)();
}

static  void method_24437( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefProd<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->swap)(*(::edm::RefProd<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)arg[0]);
}

static  void method_24438( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefProd<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->Class_Version)());
  else   (((::edm::RefProd<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->Class_Version)();
}

static void method_newdel_4955( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::GenJet> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::GenJet> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::GenJet> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::GenJet> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::GenJet> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefProd<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > > > -------------------------------
void __edm__RefProd_std__vector_reco__FFTAnyJet_reco__GenJet_s_s__db_datamem(Reflex::Class*);
void __edm__RefProd_std__vector_reco__FFTAnyJet_reco__GenJet_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefProd_std__vector_reco__FFTAnyJet_reco__GenJet_s_s__datamem_bld(&__edm__RefProd_std__vector_reco__FFTAnyJet_reco__GenJet_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefProd_std__vector_reco__FFTAnyJet_reco__GenJet_s_s__funcmem_bld(&__edm__RefProd_std__vector_reco__FFTAnyJet_reco__GenJet_s_s__db_funcmem);
void __edm__RefProd_std__vector_reco__FFTAnyJet_reco__GenJet_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefProd<std::vector<reco::FFTAnyJet<reco::GenJet> > >"), typeid(::edm::RefProd<std::vector<reco::FFTAnyJet<reco::GenJet> > >), sizeof(::edm::RefProd<std::vector<reco::FFTAnyJet<reco::GenJet> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::GenJet> > >::Class_Version())
  .AddTypedef(type_2988, Reflex::Literal("edm::RefProd<std::vector<reco::FFTAnyJet<reco::GenJet> > >::product_type"))
  .AddTypedef(type_2988, Reflex::Literal("edm::RefProd<std::vector<reco::FFTAnyJet<reco::GenJet> > >::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39840, type_39841), Reflex::Literal("operator="), operator_24414, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39841), Reflex::Literal("RefProd"), constructor_24415, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefProd"), constructor_24416, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39842), Reflex::Literal("RefProd"), constructor_24417, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39843), Reflex::Literal("RefProd"), constructor_24418, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39285), Reflex::Literal("RefProd"), constructor_24419, 0, "iProduct", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39844), Reflex::Literal("RefProd"), constructor_24420, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20599, type_20675), Reflex::Literal("RefProd"), constructor_24421, 0, "productID;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefProd"), destructor_24422, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4955, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefProd_std__vector_reco__FFTAnyJet_reco__GenJet_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefProd_std__vector_reco__FFTAnyJet_reco__GenJet_s_s__funcmem_bld);
}

//------Delayed data member builder for class RefProd<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > > > -------------------
void __edm__RefProd_std__vector_reco__FFTAnyJet_reco__GenJet_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4935, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__RefProd_std__vector_reco__FFTAnyJet_reco__GenJet_s_s_, product_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefProd<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > > > -------------------
void __edm__RefProd_std__vector_reco__FFTAnyJet_reco__GenJet_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20834), Reflex::Literal("operator*"), operator_24423, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39285), Reflex::Literal("operator->"), operator_24424, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39285), Reflex::Literal("get"), method_24425, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39285), Reflex::Literal("product"), method_24426, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23940), Reflex::Literal("refCore"), method_24427, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isNull"), method_24428, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isNonnull"), method_24429, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("operator!"), operator_24430, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4933), Reflex::Literal("id"), method_24431, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20675), Reflex::Literal("productGetter"), method_24432, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("hasCache"), method_24433, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("hasProductCache"), method_24434, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isAvailable"), method_24435, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isTransient"), method_24436, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_39840), Reflex::Literal("swap"), method_24437, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_237), Reflex::Literal("Class_Version"), method_24438, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class vector<reco::CATopJetTagInfo,std::allocator<reco::CATopJetTagInfo> > -------------------------------
static void constructor_13252( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::CATopJetTagInfo>();
  else ::new(mem) ::std::vector<reco::CATopJetTagInfo>();
}

static void constructor_13253( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::CATopJetTagInfo>(*(const ::std::allocator<reco::CATopJetTagInfo>*)arg[0]);
  else ::new(mem) ::std::vector<reco::CATopJetTagInfo>(*(const ::std::allocator<reco::CATopJetTagInfo>*)arg[0]);
}

static void constructor_13254( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::CATopJetTagInfo>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<reco::CATopJetTagInfo>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::CATopJetTagInfo>(*(::std::size_t*)arg[0],
      *(const ::reco::CATopJetTagInfo*)arg[1]);
  else ::new(mem) ::std::vector<reco::CATopJetTagInfo>(*(::std::size_t*)arg[0],
      *(const ::reco::CATopJetTagInfo*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::CATopJetTagInfo>(*(::std::size_t*)arg[0],
      *(const ::reco::CATopJetTagInfo*)arg[1],
      *(const ::std::allocator<reco::CATopJetTagInfo>*)arg[2]);
  else ::new(mem) ::std::vector<reco::CATopJetTagInfo>(*(::std::size_t*)arg[0],
      *(const ::reco::CATopJetTagInfo*)arg[1],
      *(const ::std::allocator<reco::CATopJetTagInfo>*)arg[2]);
  }
}

static void constructor_13255( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::CATopJetTagInfo>(*(const ::std::vector<reco::CATopJetTagInfo>*)arg[0]);
  else ::new(mem) ::std::vector<reco::CATopJetTagInfo>(*(const ::std::vector<reco::CATopJetTagInfo>*)arg[0]);
}

static void destructor_13256(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<reco::CATopJetTagInfo>*)o)->::std::vector<reco::CATopJetTagInfo>::~vector)();
}
static  void operator_13257( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::CATopJetTagInfo>*)o)->operator=)(*(const ::std::vector<reco::CATopJetTagInfo>*)arg[0]);
  else   (((::std::vector<reco::CATopJetTagInfo>*)o)->operator=)(*(const ::std::vector<reco::CATopJetTagInfo>*)arg[0]);
}

static  void method_13258( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::CATopJetTagInfo>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::reco::CATopJetTagInfo*)arg[1]);
}

static  void method_13259( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::CATopJetTagInfo*,std::vector<reco::CATopJetTagInfo> >)((((::std::vector<reco::CATopJetTagInfo>*)o)->begin)());
  else   (((::std::vector<reco::CATopJetTagInfo>*)o)->begin)();
}

static  void method_13260( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const reco::CATopJetTagInfo*,std::vector<reco::CATopJetTagInfo> >)((((const ::std::vector<reco::CATopJetTagInfo>*)o)->begin)());
  else   (((const ::std::vector<reco::CATopJetTagInfo>*)o)->begin)();
}

static  void method_13261( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::CATopJetTagInfo*,std::vector<reco::CATopJetTagInfo> >)((((::std::vector<reco::CATopJetTagInfo>*)o)->end)());
  else   (((::std::vector<reco::CATopJetTagInfo>*)o)->end)();
}

static  void method_13262( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const reco::CATopJetTagInfo*,std::vector<reco::CATopJetTagInfo> >)((((const ::std::vector<reco::CATopJetTagInfo>*)o)->end)());
  else   (((const ::std::vector<reco::CATopJetTagInfo>*)o)->end)();
}

static  void method_13267( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<reco::CATopJetTagInfo>*)o)->size)());
  else   (((const ::std::vector<reco::CATopJetTagInfo>*)o)->size)();
}

static  void method_13268( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<reco::CATopJetTagInfo>*)o)->max_size)());
  else   (((const ::std::vector<reco::CATopJetTagInfo>*)o)->max_size)();
}

static  void method_13269( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<reco::CATopJetTagInfo>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<reco::CATopJetTagInfo>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::reco::CATopJetTagInfo*)arg[1]);
  }
}

static  void method_13270( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<reco::CATopJetTagInfo>*)o)->capacity)());
  else   (((const ::std::vector<reco::CATopJetTagInfo>*)o)->capacity)();
}

static  void method_13271( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<reco::CATopJetTagInfo>*)o)->empty)());
  else   (((const ::std::vector<reco::CATopJetTagInfo>*)o)->empty)();
}

static  void method_13272( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::CATopJetTagInfo>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_13273( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::CATopJetTagInfo>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<reco::CATopJetTagInfo>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_13274( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::CATopJetTagInfo>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<reco::CATopJetTagInfo>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_13276( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::CATopJetTagInfo>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<reco::CATopJetTagInfo>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_13277( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::CATopJetTagInfo>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<reco::CATopJetTagInfo>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_13278( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::CATopJetTagInfo>*)o)->front)();
  else   (((::std::vector<reco::CATopJetTagInfo>*)o)->front)();
}

static  void method_13279( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::CATopJetTagInfo>*)o)->front)();
  else   (((const ::std::vector<reco::CATopJetTagInfo>*)o)->front)();
}

static  void method_13280( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::CATopJetTagInfo>*)o)->back)();
  else   (((::std::vector<reco::CATopJetTagInfo>*)o)->back)();
}

static  void method_13281( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::CATopJetTagInfo>*)o)->back)();
  else   (((const ::std::vector<reco::CATopJetTagInfo>*)o)->back)();
}

static  void method_13282( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<reco::CATopJetTagInfo>*)o)->data)());
  else   (((::std::vector<reco::CATopJetTagInfo>*)o)->data)();
}

static  void method_13283( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<reco::CATopJetTagInfo>*)o)->data)());
  else   (((const ::std::vector<reco::CATopJetTagInfo>*)o)->data)();
}

static  void method_13284( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::CATopJetTagInfo>*)o)->push_back)(*(const ::reco::CATopJetTagInfo*)arg[0]);
}

static  void method_13285( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<reco::CATopJetTagInfo>*)o)->pop_back)();
}

static  void method_13286( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::CATopJetTagInfo*,std::vector<reco::CATopJetTagInfo> >)((((::std::vector<reco::CATopJetTagInfo>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<reco::CATopJetTagInfo*,std::vector<reco::CATopJetTagInfo> >*)arg[0],
    *(const ::reco::CATopJetTagInfo*)arg[1]));
  else   (((::std::vector<reco::CATopJetTagInfo>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<reco::CATopJetTagInfo*,std::vector<reco::CATopJetTagInfo> >*)arg[0],
    *(const ::reco::CATopJetTagInfo*)arg[1]);
}

static  void method_13287( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::CATopJetTagInfo>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<reco::CATopJetTagInfo*,std::vector<reco::CATopJetTagInfo> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::reco::CATopJetTagInfo*)arg[2]);
}

static  void method_13288( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::CATopJetTagInfo*,std::vector<reco::CATopJetTagInfo> >)((((::std::vector<reco::CATopJetTagInfo>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::CATopJetTagInfo*,std::vector<reco::CATopJetTagInfo> >*)arg[0]));
  else   (((::std::vector<reco::CATopJetTagInfo>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::CATopJetTagInfo*,std::vector<reco::CATopJetTagInfo> >*)arg[0]);
}

static  void method_13289( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::CATopJetTagInfo*,std::vector<reco::CATopJetTagInfo> >)((((::std::vector<reco::CATopJetTagInfo>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::CATopJetTagInfo*,std::vector<reco::CATopJetTagInfo> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<reco::CATopJetTagInfo*,std::vector<reco::CATopJetTagInfo> >*)arg[1]));
  else   (((::std::vector<reco::CATopJetTagInfo>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::CATopJetTagInfo*,std::vector<reco::CATopJetTagInfo> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<reco::CATopJetTagInfo*,std::vector<reco::CATopJetTagInfo> >*)arg[1]);
}

static  void method_13290( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::CATopJetTagInfo>*)o)->swap)(*(::std::vector<reco::CATopJetTagInfo>*)arg[0]);
}

static  void method_13291( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<reco::CATopJetTagInfo>*)o)->clear)();
}

static void method_newdel_2973( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<reco::CATopJetTagInfo> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<reco::CATopJetTagInfo> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<reco::CATopJetTagInfo> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<reco::CATopJetTagInfo> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<reco::CATopJetTagInfo> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x122( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<reco::CATopJetTagInfo,std::allocator<reco::CATopJetTagInfo> >")), ::Reflex::BaseOffset< ::std::vector<reco::CATopJetTagInfo>,::std::_Vector_base<reco::CATopJetTagInfo,std::allocator<reco::CATopJetTagInfo> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x123( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<reco::CATopJetTagInfo> >::Generate();
  else ::Reflex::Proxy< ::std::vector<reco::CATopJetTagInfo> >::Generate();
}

//------Dictionary for class vector<reco::CATopJetTagInfo,std::allocator<reco::CATopJetTagInfo> > -------------------------------
void __std__vector_reco__CATopJetTagInfo__db_datamem(Reflex::Class*);
void __std__vector_reco__CATopJetTagInfo__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_reco__CATopJetTagInfo__datamem_bld(&__std__vector_reco__CATopJetTagInfo__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_reco__CATopJetTagInfo__funcmem_bld(&__std__vector_reco__CATopJetTagInfo__db_funcmem);
void __std__vector_reco__CATopJetTagInfo__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<reco::CATopJetTagInfo>"), typeid(::std::vector<reco::CATopJetTagInfo>), sizeof(::std::vector<reco::CATopJetTagInfo>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2498, ::Reflex::BaseOffset< ::std::vector<reco::CATopJetTagInfo>, ::std::_Vector_base<reco::CATopJetTagInfo,std::allocator<reco::CATopJetTagInfo> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_7813, Reflex::Literal("std::vector<reco::CATopJetTagInfo>::_Alloc_value_type"))
  .AddTypedef(type_2498, Reflex::Literal("std::vector<reco::CATopJetTagInfo>::_Base"))
  .AddTypedef(type_3272, Reflex::Literal("std::vector<reco::CATopJetTagInfo>::_Tp_alloc_type"))
  .AddTypedef(type_8478, Reflex::Literal("std::vector<reco::CATopJetTagInfo>::_Alloc_traits"))
  .AddTypedef(type_7813, Reflex::Literal("std::vector<reco::CATopJetTagInfo>::value_type"))
  .AddTypedef(type_9609, Reflex::Literal("std::vector<reco::CATopJetTagInfo>::pointer"))
  .AddTypedef(type_13239, Reflex::Literal("std::vector<reco::CATopJetTagInfo>::const_pointer"))
  .AddTypedef(type_13241, Reflex::Literal("std::vector<reco::CATopJetTagInfo>::reference"))
  .AddTypedef(type_13243, Reflex::Literal("std::vector<reco::CATopJetTagInfo>::const_reference"))
  .AddTypedef(type_8323, Reflex::Literal("std::vector<reco::CATopJetTagInfo>::iterator"))
  .AddTypedef(type_8324, Reflex::Literal("std::vector<reco::CATopJetTagInfo>::const_iterator"))
  .AddTypedef(type_3535, Reflex::Literal("std::vector<reco::CATopJetTagInfo>::const_reverse_iterator"))
  .AddTypedef(type_3536, Reflex::Literal("std::vector<reco::CATopJetTagInfo>::reverse_iterator"))
  .AddTypedef(type_3254, Reflex::Literal("std::vector<reco::CATopJetTagInfo>::size_type"))
  .AddTypedef(type_3138, Reflex::Literal("std::vector<reco::CATopJetTagInfo>::difference_type"))
  .AddTypedef(type_3272, Reflex::Literal("std::vector<reco::CATopJetTagInfo>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_13252, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_34714), Reflex::Literal("vector"), constructor_13253, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3254, type_13243, type_34714), Reflex::Literal("vector"), constructor_13254, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20810), Reflex::Literal("vector"), constructor_13255, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_13256, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2973, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x122, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x123, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_reco__CATopJetTagInfo__funcmem_bld);
}

//------Delayed data member builder for class vector<reco::CATopJetTagInfo,std::allocator<reco::CATopJetTagInfo> > -------------------
void __std__vector_reco__CATopJetTagInfo__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<reco::CATopJetTagInfo,std::allocator<reco::CATopJetTagInfo> > -------------------
void __std__vector_reco__CATopJetTagInfo__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35946, type_20810), Reflex::Literal("operator="), operator_13257, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_3254, type_13243), Reflex::Literal("assign"), method_13258, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8323), Reflex::Literal("begin"), method_13259, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8324), Reflex::Literal("begin"), method_13260, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8323), Reflex::Literal("end"), method_13261, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8324), Reflex::Literal("end"), method_13262, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3254), Reflex::Literal("size"), method_13267, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3254), Reflex::Literal("max_size"), method_13268, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_3254, type_7813), Reflex::Literal("resize"), method_13269, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3254), Reflex::Literal("capacity"), method_13270, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("empty"), method_13271, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_3254), Reflex::Literal("reserve"), method_13272, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13241, type_3254), Reflex::Literal("operator[]"), operator_13273, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13243, type_3254), Reflex::Literal("operator[]"), operator_13274, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13241, type_3254), Reflex::Literal("at"), method_13276, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13243, type_3254), Reflex::Literal("at"), method_13277, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13241), Reflex::Literal("front"), method_13278, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13243), Reflex::Literal("front"), method_13279, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13241), Reflex::Literal("back"), method_13280, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13243), Reflex::Literal("back"), method_13281, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9609), Reflex::Literal("data"), method_13282, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13239), Reflex::Literal("data"), method_13283, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_13243), Reflex::Literal("push_back"), method_13284, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694), Reflex::Literal("pop_back"), method_13285, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8323, type_8323, type_13243), Reflex::Literal("insert"), method_13286, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_8323, type_3254, type_13243), Reflex::Literal("insert"), method_13287, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8323, type_8323), Reflex::Literal("erase"), method_13288, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8323, type_8323, type_8323), Reflex::Literal("erase"), method_13289, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_35946), Reflex::Literal("swap"), method_13290, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694), Reflex::Literal("clear"), method_13291, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class RefProd<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> > > -------------------------------
static  void operator_24327( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)o)->operator=)(*(const ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)arg[0]);
  else   (((::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)o)->operator=)(*(const ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)arg[0]);
}

static void constructor_24328( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >(*(const ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >(*(const ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)arg[0]);
}

static void constructor_24329( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >();
  else ::new(mem) ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >();
}

static void constructor_24330( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >(*(const ::edm::Handle<std::vector<reco::CATopJetTagInfo> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >(*(const ::edm::Handle<std::vector<reco::CATopJetTagInfo> >*)arg[0]);
}

static void constructor_24331( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >(*(const ::edm::OrphanHandle<std::vector<reco::CATopJetTagInfo> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >(*(const ::edm::OrphanHandle<std::vector<reco::CATopJetTagInfo> >*)arg[0]);
}

static void constructor_24332( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >((const ::std::vector<reco::CATopJetTagInfo>*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >((const ::std::vector<reco::CATopJetTagInfo>*)arg[0]);
}

static void constructor_24333( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >(*(const ::edm::TestHandle<std::vector<reco::CATopJetTagInfo> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >(*(const ::edm::TestHandle<std::vector<reco::CATopJetTagInfo> >*)arg[0]);
}

static void constructor_24334( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
  else ::new(mem) ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
}

static void destructor_24335(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)o)->::edm::RefProd<std::vector<reco::CATopJetTagInfo> >::~RefProd)();
}
static  void operator_24336( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)o)->operator*)();
  else   (((const ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)o)->operator*)();
}

static  void operator_24337( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)o)->operator->)());
  else   (((const ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)o)->operator->)();
}

static  void method_24338( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)o)->get)());
  else   (((const ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)o)->get)();
}

static  void method_24339( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)o)->product)());
  else   (((const ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)o)->product)();
}

static  void method_24340( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)o)->refCore)();
  else   (((const ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)o)->refCore)();
}

static  void method_24341( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)o)->isNull)());
  else   (((const ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)o)->isNull)();
}

static  void method_24342( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)o)->isNonnull)());
  else   (((const ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)o)->isNonnull)();
}

static  void operator_24343( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)o)->operator!)());
  else   (((const ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)o)->operator!)();
}

static  void method_24344( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)o)->id)());
  else   (((const ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)o)->id)();
}

static  void method_24345( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)o)->productGetter)());
  else   (((const ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)o)->productGetter)();
}

static  void method_24346( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)o)->hasCache)());
  else   (((const ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)o)->hasCache)();
}

static  void method_24347( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)o)->hasProductCache)());
  else   (((const ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)o)->hasProductCache)();
}

static  void method_24348( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)o)->isAvailable)());
  else   (((const ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)o)->isAvailable)();
}

static  void method_24349( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)o)->isTransient)());
  else   (((const ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)o)->isTransient)();
}

static  void method_24350( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)o)->swap)(*(::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)arg[0]);
}

static  void method_24351( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)o)->Class_Version)());
  else   (((::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)o)->Class_Version)();
}

static void method_newdel_4952( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<reco::CATopJetTagInfo> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<reco::CATopJetTagInfo> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<reco::CATopJetTagInfo> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<reco::CATopJetTagInfo> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<reco::CATopJetTagInfo> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefProd<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> > > -------------------------------
void __edm__RefProd_std__vector_reco__CATopJetTagInfo_s__db_datamem(Reflex::Class*);
void __edm__RefProd_std__vector_reco__CATopJetTagInfo_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefProd_std__vector_reco__CATopJetTagInfo_s__datamem_bld(&__edm__RefProd_std__vector_reco__CATopJetTagInfo_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefProd_std__vector_reco__CATopJetTagInfo_s__funcmem_bld(&__edm__RefProd_std__vector_reco__CATopJetTagInfo_s__db_funcmem);
void __edm__RefProd_std__vector_reco__CATopJetTagInfo_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefProd<std::vector<reco::CATopJetTagInfo> >"), typeid(::edm::RefProd<std::vector<reco::CATopJetTagInfo> >), sizeof(::edm::RefProd<std::vector<reco::CATopJetTagInfo> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >::Class_Version())
  .AddTypedef(type_2973, Reflex::Literal("edm::RefProd<std::vector<reco::CATopJetTagInfo> >::product_type"))
  .AddTypedef(type_2973, Reflex::Literal("edm::RefProd<std::vector<reco::CATopJetTagInfo> >::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39825, type_39826), Reflex::Literal("operator="), operator_24327, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39826), Reflex::Literal("RefProd"), constructor_24328, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefProd"), constructor_24329, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39827), Reflex::Literal("RefProd"), constructor_24330, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39828), Reflex::Literal("RefProd"), constructor_24331, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39273), Reflex::Literal("RefProd"), constructor_24332, 0, "iProduct", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39829), Reflex::Literal("RefProd"), constructor_24333, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20599, type_20675), Reflex::Literal("RefProd"), constructor_24334, 0, "productID;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefProd"), destructor_24335, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4952, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefProd_std__vector_reco__CATopJetTagInfo_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefProd_std__vector_reco__CATopJetTagInfo_s__funcmem_bld);
}

//------Delayed data member builder for class RefProd<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> > > -------------------
void __edm__RefProd_std__vector_reco__CATopJetTagInfo_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4935, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__RefProd_std__vector_reco__CATopJetTagInfo_s_, product_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefProd<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> > > -------------------
void __edm__RefProd_std__vector_reco__CATopJetTagInfo_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20810), Reflex::Literal("operator*"), operator_24336, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39273), Reflex::Literal("operator->"), operator_24337, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39273), Reflex::Literal("get"), method_24338, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39273), Reflex::Literal("product"), method_24339, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23940), Reflex::Literal("refCore"), method_24340, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isNull"), method_24341, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isNonnull"), method_24342, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("operator!"), operator_24343, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4933), Reflex::Literal("id"), method_24344, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20675), Reflex::Literal("productGetter"), method_24345, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("hasCache"), method_24346, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("hasProductCache"), method_24347, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isAvailable"), method_24348, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isTransient"), method_24349, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_39825), Reflex::Literal("swap"), method_24350, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_237), Reflex::Literal("Class_Version"), method_24351, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefProd<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > > > -------------------------------
static  void operator_24356( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefProd<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->operator=)(*(const ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)arg[0]);
  else   (((::edm::RefProd<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->operator=)(*(const ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)arg[0]);
}

static void constructor_24357( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::CaloJet> > >(*(const ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::CaloJet> > >(*(const ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)arg[0]);
}

static void constructor_24358( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::CaloJet> > >();
  else ::new(mem) ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::CaloJet> > >();
}

static void constructor_24359( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::CaloJet> > >(*(const ::edm::Handle<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::CaloJet> > >(*(const ::edm::Handle<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)arg[0]);
}

static void constructor_24360( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::CaloJet> > >(*(const ::edm::OrphanHandle<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::CaloJet> > >(*(const ::edm::OrphanHandle<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)arg[0]);
}

static void constructor_24361( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::CaloJet> > >((const ::std::vector<reco::FFTAnyJet<reco::CaloJet> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::CaloJet> > >((const ::std::vector<reco::FFTAnyJet<reco::CaloJet> >*)arg[0]);
}

static void constructor_24362( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::CaloJet> > >(*(const ::edm::TestHandle<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::CaloJet> > >(*(const ::edm::TestHandle<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)arg[0]);
}

static void constructor_24363( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::CaloJet> > >(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
  else ::new(mem) ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::CaloJet> > >(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
}

static void destructor_24364(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefProd<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->::edm::RefProd<std::vector<reco::FFTAnyJet<reco::CaloJet> > >::~RefProd)();
}
static  void operator_24365( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->operator*)();
  else   (((const ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->operator*)();
}

static  void operator_24366( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->operator->)());
  else   (((const ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->operator->)();
}

static  void method_24367( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->get)());
  else   (((const ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->get)();
}

static  void method_24368( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->product)());
  else   (((const ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->product)();
}

static  void method_24369( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->refCore)();
  else   (((const ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->refCore)();
}

static  void method_24370( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->isNull)());
  else   (((const ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->isNull)();
}

static  void method_24371( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->isNonnull)());
  else   (((const ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->isNonnull)();
}

static  void operator_24372( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->operator!)());
  else   (((const ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->operator!)();
}

static  void method_24373( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->id)());
  else   (((const ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->id)();
}

static  void method_24374( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->productGetter)());
  else   (((const ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->productGetter)();
}

static  void method_24375( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->hasCache)());
  else   (((const ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->hasCache)();
}

static  void method_24376( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->hasProductCache)());
  else   (((const ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->hasProductCache)();
}

static  void method_24377( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->isAvailable)());
  else   (((const ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->isAvailable)();
}

static  void method_24378( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->isTransient)());
  else   (((const ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->isTransient)();
}

static  void method_24379( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefProd<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->swap)(*(::edm::RefProd<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)arg[0]);
}

static  void method_24380( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefProd<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->Class_Version)());
  else   (((::edm::RefProd<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->Class_Version)();
}

static void method_newdel_4953( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::CaloJet> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::CaloJet> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::CaloJet> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::CaloJet> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::CaloJet> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefProd<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > > > -------------------------------
void __edm__RefProd_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s__db_datamem(Reflex::Class*);
void __edm__RefProd_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefProd_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s__datamem_bld(&__edm__RefProd_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefProd_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s__funcmem_bld(&__edm__RefProd_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s__db_funcmem);
void __edm__RefProd_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefProd<std::vector<reco::FFTAnyJet<reco::CaloJet> > >"), typeid(::edm::RefProd<std::vector<reco::FFTAnyJet<reco::CaloJet> > >), sizeof(::edm::RefProd<std::vector<reco::FFTAnyJet<reco::CaloJet> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::CaloJet> > >::Class_Version())
  .AddTypedef(type_2983, Reflex::Literal("edm::RefProd<std::vector<reco::FFTAnyJet<reco::CaloJet> > >::product_type"))
  .AddTypedef(type_2983, Reflex::Literal("edm::RefProd<std::vector<reco::FFTAnyJet<reco::CaloJet> > >::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39830, type_39831), Reflex::Literal("operator="), operator_24356, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39831), Reflex::Literal("RefProd"), constructor_24357, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefProd"), constructor_24358, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39832), Reflex::Literal("RefProd"), constructor_24359, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39833), Reflex::Literal("RefProd"), constructor_24360, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39280), Reflex::Literal("RefProd"), constructor_24361, 0, "iProduct", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39834), Reflex::Literal("RefProd"), constructor_24362, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20599, type_20675), Reflex::Literal("RefProd"), constructor_24363, 0, "productID;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefProd"), destructor_24364, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4953, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefProd_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefProd_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s__funcmem_bld);
}

//------Delayed data member builder for class RefProd<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > > > -------------------
void __edm__RefProd_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4935, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__RefProd_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s_, product_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefProd<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > > > -------------------
void __edm__RefProd_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20822), Reflex::Literal("operator*"), operator_24365, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39280), Reflex::Literal("operator->"), operator_24366, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39280), Reflex::Literal("get"), method_24367, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39280), Reflex::Literal("product"), method_24368, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23940), Reflex::Literal("refCore"), method_24369, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isNull"), method_24370, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isNonnull"), method_24371, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("operator!"), operator_24372, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4933), Reflex::Literal("id"), method_24373, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20675), Reflex::Literal("productGetter"), method_24374, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("hasCache"), method_24375, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("hasProductCache"), method_24376, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isAvailable"), method_24377, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isTransient"), method_24378, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_39830), Reflex::Literal("swap"), method_24379, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_237), Reflex::Literal("Class_Version"), method_24380, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >, reco::FFTAnyJet<reco::CaloJet> > > -------------------------------
static void destructor_22746(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->::edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >::~RefVector)();
}
static void constructor_22747( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >();
  else ::new(mem) ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >();
}

static void constructor_22748( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >(*(const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)arg[0]);
  else ::new(mem) ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >(*(const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)arg[0]);
}

static void constructor_22749( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >(*(const ::edm::ProductID*)arg[0]);
}

static  void method_22750( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->push_back)(*(const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)arg[0]);
}

static  void operator_22751( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >)((((const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->operator[])(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_22752( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >)((((const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->at)(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_22753( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->refVector)();
  else   (((const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->refVector)();
}

static  void method_22754( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->empty)());
  else   (((const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->empty)();
}

static  void method_22755( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->size)());
  else   (((const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->size)();
}

static  void method_22756( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->capacity)());
  else   (((const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->capacity)();
}

static  void method_22757( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void method_22758( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >)((((const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->begin)());
  else   (((const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->begin)();
}

static  void method_22759( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >)((((const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->end)());
  else   (((const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->end)();
}

static  void method_22760( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->id)());
  else   (((const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->id)();
}

static  void method_22761( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->productGetter)());
  else   (((const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->productGetter)();
}

static  void method_22762( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->isNull)());
  else   (((const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->isNull)();
}

static  void method_22763( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->isNonnull)());
  else   (((const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->isNonnull)();
}

static  void operator_22764( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->operator!)());
  else   (((const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->operator!)();
}

static  void method_22765( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->product)());
  else   (((const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->product)();
}

static  void method_22766( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->isAvailable)());
  else   (((const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->isAvailable)();
}

static  void method_22767( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->isTransient)());
  else   (((const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->isTransient)();
}

static  void method_22768( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >)((((::edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->erase)(*(const ::edm::RefVectorIterator<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)arg[0]));
  else   (((::edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->erase)(*(const ::edm::RefVectorIterator<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)arg[0]);
}

static  void method_22769( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->clear)();
}

static  void method_22770( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->swap)(*(::edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)arg[0]);
}

static  void operator_22771( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->operator=)(*(const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)arg[0]);
  else   (((::edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->operator=)(*(const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)arg[0]);
}

static  void method_22772( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->hasProductCache)());
  else   (((const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->hasProductCache)();
}

static  void method_22773( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::edm::helper_vector*)arg[2]);
}

static  void method_22774( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->Class_Version)());
  else   (((::edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->Class_Version)();
}

static void method_newdel_4671( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >, reco::FFTAnyJet<reco::CaloJet> > > -------------------------------
void __edm__RefVector_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s__db_datamem(Reflex::Class*);
void __edm__RefVector_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefVector_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s__datamem_bld(&__edm__RefVector_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefVector_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s__funcmem_bld(&__edm__RefVector_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s__db_funcmem);
void __edm__RefVector_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >"), typeid(::edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >), sizeof(::edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >::Class_Version())
  .AddTypedef(type_2983, Reflex::Literal("edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >::collection_type"))
  .AddTypedef(type_7851, Reflex::Literal("edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >::member_type"))
  .AddTypedef(type_20817, Reflex::Literal("edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >::finder_type"))
  .AddTypedef(type_4613, Reflex::Literal("edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >::iterator"))
  .AddTypedef(type_4613, Reflex::Literal("edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >::const_iterator"))
  .AddTypedef(type_5019, Reflex::Literal("edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >::value_type"))
  .AddTypedef(type_5019c, Reflex::Literal("edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >::const_reference"))
  .AddTypedef(type_5019c, Reflex::Literal("edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >::reference"))
  .AddTypedef(type_366, Reflex::Literal("edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >::key_type"))
  .AddTypedef(type_2972, Reflex::Literal("edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >::KeyVec"))
  .AddTypedef(type_3254, Reflex::Literal("edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >::size_type"))
  .AddTypedef(type_4039, Reflex::Literal("edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >::contents_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefVector"), destructor_22746, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefVector"), constructor_22747, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39279), Reflex::Literal("RefVector"), constructor_22748, 0, "rh", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20599), Reflex::Literal("RefVector"), constructor_22749, 0, "iId", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4671, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefVector_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefVector_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s__funcmem_bld);
}

//------Delayed data member builder for class RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >, reco::FFTAnyJet<reco::CaloJet> > > -------------------
void __edm__RefVector_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4039, Reflex::Literal("refVector_"), OffsetOf(__shadow__::__edm__RefVector_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_, refVector_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >, reco::FFTAnyJet<reco::CaloJet> > > -------------------
void __edm__RefVector_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_38847), Reflex::Literal("push_back"), method_22750, 0, "ref", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5019c, type_3254), Reflex::Literal("operator[]"), operator_22751, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5019c, type_3254), Reflex::Literal("at"), method_22752, 0, "idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20674), Reflex::Literal("refVector"), method_22753, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("empty"), method_22754, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3254), Reflex::Literal("size"), method_22755, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3254), Reflex::Literal("capacity"), method_22756, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_3254), Reflex::Literal("reserve"), method_22757, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4613), Reflex::Literal("begin"), method_22758, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4613), Reflex::Literal("end"), method_22759, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4933), Reflex::Literal("id"), method_22760, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20675), Reflex::Literal("productGetter"), method_22761, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isNull"), method_22762, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isNonnull"), method_22763, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("operator!"), operator_22764, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39280), Reflex::Literal("product"), method_22765, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isAvailable"), method_22766, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isTransient"), method_22767, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4613, type_39281), Reflex::Literal("erase"), method_22768, 0, "pos", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694), Reflex::Literal("clear"), method_22769, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_39282), Reflex::Literal("swap"), method_22770, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39282, type_39279), Reflex::Literal("operator="), operator_22771, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("hasProductCache"), method_22772, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20599, type_20679, type_20680), Reflex::Literal("fillView"), method_22773, 0, ";pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_237), Reflex::Literal("Class_Version"), method_22774, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >, reco::FFTAnyJet<reco::GenJet>, edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >, reco::FFTAnyJet<reco::GenJet> > >,std::allocator<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >, reco::FFTAnyJet<reco::GenJet>, edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >, reco::FFTAnyJet<reco::GenJet> > > > > -------------------------------
static void constructor_13770( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >();
  else ::new(mem) ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >();
}

static void constructor_13771( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >(*(const ::std::allocator<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)arg[0]);
  else ::new(mem) ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >(*(const ::std::allocator<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)arg[0]);
}

static void constructor_13772( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >(*(::std::size_t*)arg[0],
      *(const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)arg[1]);
  else ::new(mem) ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >(*(::std::size_t*)arg[0],
      *(const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >(*(::std::size_t*)arg[0],
      *(const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)arg[1],
      *(const ::std::allocator<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)arg[2]);
  else ::new(mem) ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >(*(::std::size_t*)arg[0],
      *(const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)arg[1],
      *(const ::std::allocator<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)arg[2]);
  }
}

static void constructor_13773( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >(*(const ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)arg[0]);
  else ::new(mem) ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >(*(const ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)arg[0]);
}

static void destructor_13774(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >::~vector)();
}
static  void operator_13775( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->operator=)(*(const ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)arg[0]);
  else   (((::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->operator=)(*(const ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)arg[0]);
}

static  void method_13776( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)arg[1]);
}

static  void method_13777( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*,std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >)((((::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->begin)());
  else   (((::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->begin)();
}

static  void method_13778( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*,std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >)((((const ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->begin)());
  else   (((const ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->begin)();
}

static  void method_13779( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*,std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >)((((::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->end)());
  else   (((::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->end)();
}

static  void method_13780( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*,std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >)((((const ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->end)());
  else   (((const ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->end)();
}

static  void method_13785( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->size)());
  else   (((const ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->size)();
}

static  void method_13786( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->max_size)());
  else   (((const ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->max_size)();
}

static  void method_13787( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)arg[1]);
  }
}

static  void method_13788( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->capacity)());
  else   (((const ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->capacity)();
}

static  void method_13789( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->empty)());
  else   (((const ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->empty)();
}

static  void method_13790( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_13791( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_13792( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_13794( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_13795( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_13796( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->front)();
  else   (((::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->front)();
}

static  void method_13797( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->front)();
  else   (((const ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->front)();
}

static  void method_13798( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->back)();
  else   (((::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->back)();
}

static  void method_13799( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->back)();
  else   (((const ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->back)();
}

static  void method_13800( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->data)());
  else   (((::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->data)();
}

static  void method_13801( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->data)());
  else   (((const ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->data)();
}

static  void method_13802( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->push_back)(*(const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)arg[0]);
}

static  void method_13803( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->pop_back)();
}

static  void method_13804( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*,std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >)((((::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*,std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >*)arg[0],
    *(const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)arg[1]));
  else   (((::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*,std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >*)arg[0],
    *(const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)arg[1]);
}

static  void method_13805( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*,std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)arg[2]);
}

static  void method_13806( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*,std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >)((((::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*,std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >*)arg[0]));
  else   (((::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*,std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >*)arg[0]);
}

static  void method_13807( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*,std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >)((((::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*,std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*,std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >*)arg[1]));
  else   (((::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*,std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*,std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >*)arg[1]);
}

static  void method_13808( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->swap)(*(::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)arg[0]);
}

static  void method_13809( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->clear)();
}

static void method_newdel_2987( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x128( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >,std::allocator<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >")), ::Reflex::BaseOffset< ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >,::std::_Vector_base<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >,std::allocator<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x129( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >::Generate();
  else ::Reflex::Proxy< ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >::Generate();
}

//------Dictionary for class vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >, reco::FFTAnyJet<reco::GenJet>, edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >, reco::FFTAnyJet<reco::GenJet> > >,std::allocator<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >, reco::FFTAnyJet<reco::GenJet>, edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >, reco::FFTAnyJet<reco::GenJet> > > > > -------------------------------
void __std__vector_edm__FwdRef_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s__db_datamem(Reflex::Class*);
void __std__vector_edm__FwdRef_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_edm__FwdRef_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s__datamem_bld(&__std__vector_edm__FwdRef_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_edm__FwdRef_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s__funcmem_bld(&__std__vector_edm__FwdRef_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s__db_funcmem);
void __std__vector_edm__FwdRef_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >"), typeid(::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >), sizeof(::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2487, ::Reflex::BaseOffset< ::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >, ::std::_Vector_base<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >,std::allocator<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_4775, Reflex::Literal("std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >::_Alloc_value_type"))
  .AddTypedef(type_2487, Reflex::Literal("std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >::_Base"))
  .AddTypedef(type_3294, Reflex::Literal("std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >::_Tp_alloc_type"))
  .AddTypedef(type_8467, Reflex::Literal("std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >::_Alloc_traits"))
  .AddTypedef(type_4775, Reflex::Literal("std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >::value_type"))
  .AddTypedef(type_9400, Reflex::Literal("std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >::pointer"))
  .AddTypedef(type_13757, Reflex::Literal("std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >::const_pointer"))
  .AddTypedef(type_13759, Reflex::Literal("std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >::reference"))
  .AddTypedef(type_13761, Reflex::Literal("std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >::const_reference"))
  .AddTypedef(type_8300, Reflex::Literal("std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >::iterator"))
  .AddTypedef(type_8301, Reflex::Literal("std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >::const_iterator"))
  .AddTypedef(type_3513, Reflex::Literal("std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >::const_reverse_iterator"))
  .AddTypedef(type_3514, Reflex::Literal("std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >::reverse_iterator"))
  .AddTypedef(type_3254, Reflex::Literal("std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >::size_type"))
  .AddTypedef(type_3138, Reflex::Literal("std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >::difference_type"))
  .AddTypedef(type_3294, Reflex::Literal("std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_13770, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_34571), Reflex::Literal("vector"), constructor_13771, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3254, type_13761, type_34571), Reflex::Literal("vector"), constructor_13772, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35966), Reflex::Literal("vector"), constructor_13773, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_13774, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2987, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x128, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x129, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_edm__FwdRef_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s__funcmem_bld);
}

//------Delayed data member builder for class vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >, reco::FFTAnyJet<reco::GenJet>, edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >, reco::FFTAnyJet<reco::GenJet> > >,std::allocator<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >, reco::FFTAnyJet<reco::GenJet>, edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >, reco::FFTAnyJet<reco::GenJet> > > > > -------------------
void __std__vector_edm__FwdRef_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >, reco::FFTAnyJet<reco::GenJet>, edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >, reco::FFTAnyJet<reco::GenJet> > >,std::allocator<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >, reco::FFTAnyJet<reco::GenJet>, edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >, reco::FFTAnyJet<reco::GenJet> > > > > -------------------
void __std__vector_edm__FwdRef_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35967, type_35966), Reflex::Literal("operator="), operator_13775, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_3254, type_13761), Reflex::Literal("assign"), method_13776, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8300), Reflex::Literal("begin"), method_13777, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8301), Reflex::Literal("begin"), method_13778, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8300), Reflex::Literal("end"), method_13779, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8301), Reflex::Literal("end"), method_13780, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3254), Reflex::Literal("size"), method_13785, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3254), Reflex::Literal("max_size"), method_13786, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_3254, type_4775), Reflex::Literal("resize"), method_13787, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3254), Reflex::Literal("capacity"), method_13788, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("empty"), method_13789, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_3254), Reflex::Literal("reserve"), method_13790, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13759, type_3254), Reflex::Literal("operator[]"), operator_13791, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13761, type_3254), Reflex::Literal("operator[]"), operator_13792, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13759, type_3254), Reflex::Literal("at"), method_13794, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13761, type_3254), Reflex::Literal("at"), method_13795, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13759), Reflex::Literal("front"), method_13796, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13761), Reflex::Literal("front"), method_13797, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13759), Reflex::Literal("back"), method_13798, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13761), Reflex::Literal("back"), method_13799, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9400), Reflex::Literal("data"), method_13800, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13757), Reflex::Literal("data"), method_13801, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_13761), Reflex::Literal("push_back"), method_13802, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694), Reflex::Literal("pop_back"), method_13803, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8300, type_8300, type_13761), Reflex::Literal("insert"), method_13804, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_8300, type_3254, type_13761), Reflex::Literal("insert"), method_13805, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8300, type_8300), Reflex::Literal("erase"), method_13806, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8300, type_8300, type_8300), Reflex::Literal("erase"), method_13807, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_35967), Reflex::Literal("swap"), method_13808, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694), Reflex::Literal("clear"), method_13809, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class Ref<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> >,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> >, reco::CATopJetTagInfo> > -------------------------------
static  void operator_25286( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->operator=)(*(const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)arg[0]);
  else   (((::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->operator=)(*(const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)arg[0]);
}

static void constructor_25287( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >(*(const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)arg[0]);
  else ::new(mem) ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >(*(const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)arg[0]);
}

static void constructor_25288( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >();
  else ::new(mem) ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >();
}

static void constructor_25289( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >(*(const ::edm::Handle<std::vector<reco::CATopJetTagInfo> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >(*(const ::edm::Handle<std::vector<reco::CATopJetTagInfo> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >(*(const ::edm::Handle<std::vector<reco::CATopJetTagInfo> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >(*(const ::edm::Handle<std::vector<reco::CATopJetTagInfo> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_25290( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >(*(const ::edm::OrphanHandle<std::vector<reco::CATopJetTagInfo> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >(*(const ::edm::OrphanHandle<std::vector<reco::CATopJetTagInfo> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >(*(const ::edm::OrphanHandle<std::vector<reco::CATopJetTagInfo> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >(*(const ::edm::OrphanHandle<std::vector<reco::CATopJetTagInfo> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_25291( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >(*(const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >(*(const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >(*(const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >(*(const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_25292( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >((const ::std::vector<reco::CATopJetTagInfo>*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >((const ::std::vector<reco::CATopJetTagInfo>*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >((const ::std::vector<reco::CATopJetTagInfo>*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >((const ::std::vector<reco::CATopJetTagInfo>*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_25293( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >(*(const ::edm::TestHandle<std::vector<reco::CATopJetTagInfo> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >(*(const ::edm::TestHandle<std::vector<reco::CATopJetTagInfo> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >(*(const ::edm::TestHandle<std::vector<reco::CATopJetTagInfo> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >(*(const ::edm::TestHandle<std::vector<reco::CATopJetTagInfo> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_25294( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >(*(const ::edm::ProductID*)arg[0],
      *(unsigned int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >(*(const ::edm::ProductID*)arg[0],
      *(unsigned int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
}

static void constructor_25295( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >(*(const ::edm::ProductID*)arg[0],
      (const ::reco::CATopJetTagInfo*)arg[1],
      *(unsigned int*)arg[2],
      (const ::std::vector<reco::CATopJetTagInfo>*)arg[3]);
  else ::new(mem) ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >(*(const ::edm::ProductID*)arg[0],
      (const ::reco::CATopJetTagInfo*)arg[1],
      *(unsigned int*)arg[2],
      (const ::std::vector<reco::CATopJetTagInfo>*)arg[3]);
}

static void constructor_25296( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_25297( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >(*(const ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >(*(const ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)arg[0],
      *(unsigned int*)arg[1]);
}

static void destructor_25298(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >::~Ref)();
}
static  void operator_25299( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->operator*)();
  else   (((const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->operator*)();
}

static  void operator_25300( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->operator->)());
  else   (((const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->operator->)();
}

static  void method_25301( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->get)());
  else   (((const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->get)();
}

static  void method_25302( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->isNull)());
  else   (((const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->isNull)();
}

static  void method_25303( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->isNonnull)());
  else   (((const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->isNonnull)();
}

static  void operator_25304( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->operator!)());
  else   (((const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->operator!)();
}

static  void method_25305( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->id)());
  else   (((const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->id)();
}

static  void method_25306( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->productGetter)());
  else   (((const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->productGetter)();
}

static  void method_25307( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->product)());
  else   (((const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->product)();
}

static  void method_25308( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->key)());
  else   (((const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->key)();
}

static  void method_25309( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->index)());
  else   (((const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->index)();
}

static  void method_25310( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->hasProductCache)());
  else   (((const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->hasProductCache)();
}

static  void method_25311( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->isAvailable)());
  else   (((const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->isAvailable)();
}

static  void method_25312( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->isTransient)());
  else   (((const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->isTransient)();
}

static  void method_25313( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->refCore)();
  else   (((const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->refCore)();
}

static  void method_25314( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->Class_Version)());
  else   (((::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->Class_Version)();
}

static void constructor_25315( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >(*(const ::edm::RefCore*)arg[0],
      *(const unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >(*(const ::edm::RefCore*)arg[0],
      *(const unsigned int*)arg[1]);
}

static void method_newdel_5018( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Ref<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> >,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> >, reco::CATopJetTagInfo> > -------------------------------
void __edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s__db_datamem(Reflex::Class*);
void __edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s__datamem_bld(&__edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s__funcmem_bld(&__edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s__db_funcmem);
void __edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >"), typeid(::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >), sizeof(::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >::Class_Version())
  .AddTypedef(type_7813, Reflex::Literal("edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >::T"))
  .AddTypedef(type_20805, Reflex::Literal("edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >::F"))
  .AddTypedef(type_22251, Reflex::Literal("edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >::VF"))
  .AddTypedef(type_22250, Reflex::Literal("edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >::VBF"))
  .AddTypedef(type_2973, Reflex::Literal("edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >::product_type"))
  .AddTypedef(type_7813, Reflex::Literal("edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >::value_type"))
  .AddTypedef(type_7813c, Reflex::Literal("edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >::element_type"))
  .AddTypedef(type_20805, Reflex::Literal("edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >::finder_type"))
  .AddTypedef(type_366, Reflex::Literal("edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >::argument_type"))
  .AddTypedef(type_366, Reflex::Literal("edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >::key_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39927, type_39272), Reflex::Literal("operator="), operator_25286, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39272), Reflex::Literal("Ref"), constructor_25287, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Ref"), constructor_25288, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39827, type_366, type_1566), Reflex::Literal("Ref"), constructor_25289, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39828, type_366, type_1566), Reflex::Literal("Ref"), constructor_25290, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39271, type_366, type_1566), Reflex::Literal("Ref"), constructor_25291, 0, "refvector;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39273, type_366, type_1566), Reflex::Literal("Ref"), constructor_25292, 0, "iProduct;iItemKey;iSetNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39829, type_366, type_1566), Reflex::Literal("Ref"), constructor_25293, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20599, type_366, type_20675), Reflex::Literal("Ref"), constructor_25294, 0, "productID;itemKey;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20599, type_13239, type_366, type_39273), Reflex::Literal("Ref"), constructor_25295, 0, "iProductID;;iItemKey;iProduct", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20599), Reflex::Literal("Ref"), constructor_25296, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39826, type_366), Reflex::Literal("Ref"), constructor_25297, 0, "refProd;itemKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Ref"), destructor_25298, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23940, type_10985), Reflex::Literal("Ref"), constructor_25315, 0, "iRefCore;iKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_5018, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s__funcmem_bld);
}

//------Delayed data member builder for class Ref<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> >,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> >, reco::CATopJetTagInfo> > -------------------
void __edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4624, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_, product_), ::Reflex::PRIVATE | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class Ref<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> >,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> >, reco::CATopJetTagInfo> > -------------------
void __edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13243), Reflex::Literal("operator*"), operator_25299, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13239), Reflex::Literal("operator->"), operator_25300, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13239), Reflex::Literal("get"), method_25301, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isNull"), method_25302, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isNonnull"), method_25303, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("operator!"), operator_25304, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4933), Reflex::Literal("id"), method_25305, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20675), Reflex::Literal("productGetter"), method_25306, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39273), Reflex::Literal("product"), method_25307, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_366), Reflex::Literal("key"), method_25308, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_366), Reflex::Literal("index"), method_25309, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("hasProductCache"), method_25310, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isAvailable"), method_25311, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isTransient"), method_25312, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23940), Reflex::Literal("refCore"), method_25313, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_237), Reflex::Literal("Class_Version"), method_25314, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Ref<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >, reco::FFTAnyJet<reco::CaloJet> > > -------------------------------
static  void operator_25328( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->operator=)(*(const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)arg[0]);
  else   (((::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->operator=)(*(const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)arg[0]);
}

static void constructor_25329( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >(*(const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)arg[0]);
  else ::new(mem) ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >(*(const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)arg[0]);
}

static void constructor_25330( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >();
  else ::new(mem) ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >();
}

static void constructor_25331( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >(*(const ::edm::Handle<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >(*(const ::edm::Handle<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >(*(const ::edm::Handle<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >(*(const ::edm::Handle<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_25332( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >(*(const ::edm::OrphanHandle<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >(*(const ::edm::OrphanHandle<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >(*(const ::edm::OrphanHandle<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >(*(const ::edm::OrphanHandle<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_25333( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >(*(const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >(*(const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >(*(const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >(*(const ::edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_25334( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >((const ::std::vector<reco::FFTAnyJet<reco::CaloJet> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >((const ::std::vector<reco::FFTAnyJet<reco::CaloJet> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >((const ::std::vector<reco::FFTAnyJet<reco::CaloJet> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >((const ::std::vector<reco::FFTAnyJet<reco::CaloJet> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_25335( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >(*(const ::edm::TestHandle<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >(*(const ::edm::TestHandle<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >(*(const ::edm::TestHandle<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >(*(const ::edm::TestHandle<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_25336( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >(*(const ::edm::ProductID*)arg[0],
      *(unsigned int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >(*(const ::edm::ProductID*)arg[0],
      *(unsigned int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
}

static void constructor_25337( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >(*(const ::edm::ProductID*)arg[0],
      (const ::reco::FFTAnyJet<reco::CaloJet>*)arg[1],
      *(unsigned int*)arg[2],
      (const ::std::vector<reco::FFTAnyJet<reco::CaloJet> >*)arg[3]);
  else ::new(mem) ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >(*(const ::edm::ProductID*)arg[0],
      (const ::reco::FFTAnyJet<reco::CaloJet>*)arg[1],
      *(unsigned int*)arg[2],
      (const ::std::vector<reco::FFTAnyJet<reco::CaloJet> >*)arg[3]);
}

static void constructor_25338( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_25339( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >(*(const ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >(*(const ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)arg[0],
      *(unsigned int*)arg[1]);
}

static void destructor_25340(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >::~Ref)();
}
static  void operator_25341( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->operator*)();
  else   (((const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->operator*)();
}

static  void operator_25342( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->operator->)());
  else   (((const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->operator->)();
}

static  void method_25343( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->get)());
  else   (((const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->get)();
}

static  void method_25344( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->isNull)());
  else   (((const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->isNull)();
}

static  void method_25345( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->isNonnull)());
  else   (((const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->isNonnull)();
}

static  void operator_25346( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->operator!)());
  else   (((const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->operator!)();
}

static  void method_25347( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->id)());
  else   (((const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->id)();
}

static  void method_25348( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->productGetter)());
  else   (((const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->productGetter)();
}

static  void method_25349( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->product)());
  else   (((const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->product)();
}

static  void method_25350( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->key)());
  else   (((const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->key)();
}

static  void method_25351( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->index)());
  else   (((const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->index)();
}

static  void method_25352( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->hasProductCache)());
  else   (((const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->hasProductCache)();
}

static  void method_25353( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->isAvailable)());
  else   (((const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->isAvailable)();
}

static  void method_25354( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->isTransient)());
  else   (((const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->isTransient)();
}

static  void method_25355( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->refCore)();
  else   (((const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->refCore)();
}

static  void method_25356( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->Class_Version)());
  else   (((::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)o)->Class_Version)();
}

static void constructor_25357( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >(*(const ::edm::RefCore*)arg[0],
      *(const unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >(*(const ::edm::RefCore*)arg[0],
      *(const unsigned int*)arg[1]);
}

static void method_newdel_5019( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Ref<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >, reco::FFTAnyJet<reco::CaloJet> > > -------------------------------
void __edm__Ref_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s__db_datamem(Reflex::Class*);
void __edm__Ref_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Ref_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s__datamem_bld(&__edm__Ref_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Ref_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s__funcmem_bld(&__edm__Ref_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s__db_funcmem);
void __edm__Ref_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >"), typeid(::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >), sizeof(::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >::Class_Version())
  .AddTypedef(type_7851, Reflex::Literal("edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >::T"))
  .AddTypedef(type_20817, Reflex::Literal("edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >::F"))
  .AddTypedef(type_22253, Reflex::Literal("edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >::VF"))
  .AddTypedef(type_22252, Reflex::Literal("edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >::VBF"))
  .AddTypedef(type_2983, Reflex::Literal("edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >::product_type"))
  .AddTypedef(type_7851, Reflex::Literal("edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >::value_type"))
  .AddTypedef(type_7851c, Reflex::Literal("edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >::element_type"))
  .AddTypedef(type_20817, Reflex::Literal("edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >::finder_type"))
  .AddTypedef(type_366, Reflex::Literal("edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >::argument_type"))
  .AddTypedef(type_366, Reflex::Literal("edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >::key_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39928, type_38847), Reflex::Literal("operator="), operator_25328, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_38847), Reflex::Literal("Ref"), constructor_25329, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Ref"), constructor_25330, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39832, type_366, type_1566), Reflex::Literal("Ref"), constructor_25331, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39833, type_366, type_1566), Reflex::Literal("Ref"), constructor_25332, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39279, type_366, type_1566), Reflex::Literal("Ref"), constructor_25333, 0, "refvector;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39280, type_366, type_1566), Reflex::Literal("Ref"), constructor_25334, 0, "iProduct;iItemKey;iSetNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39834, type_366, type_1566), Reflex::Literal("Ref"), constructor_25335, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20599, type_366, type_20675), Reflex::Literal("Ref"), constructor_25336, 0, "productID;itemKey;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20599, type_13627, type_366, type_39280), Reflex::Literal("Ref"), constructor_25337, 0, "iProductID;;iItemKey;iProduct", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20599), Reflex::Literal("Ref"), constructor_25338, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39831, type_366), Reflex::Literal("Ref"), constructor_25339, 0, "refProd;itemKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Ref"), destructor_25340, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23940, type_10985), Reflex::Literal("Ref"), constructor_25357, 0, "iRefCore;iKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_5019, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Ref_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Ref_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s__funcmem_bld);
}

//------Delayed data member builder for class Ref<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >, reco::FFTAnyJet<reco::CaloJet> > > -------------------
void __edm__Ref_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4624, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__Ref_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_, product_), ::Reflex::PRIVATE | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class Ref<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >, reco::FFTAnyJet<reco::CaloJet> > > -------------------
void __edm__Ref_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13631), Reflex::Literal("operator*"), operator_25341, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13627), Reflex::Literal("operator->"), operator_25342, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13627), Reflex::Literal("get"), method_25343, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isNull"), method_25344, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isNonnull"), method_25345, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("operator!"), operator_25346, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4933), Reflex::Literal("id"), method_25347, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20675), Reflex::Literal("productGetter"), method_25348, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39280), Reflex::Literal("product"), method_25349, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_366), Reflex::Literal("key"), method_25350, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_366), Reflex::Literal("index"), method_25351, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("hasProductCache"), method_25352, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isAvailable"), method_25353, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isTransient"), method_25354, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23940), Reflex::Literal("refCore"), method_25355, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_237), Reflex::Literal("Class_Version"), method_25356, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class PtrVector<reco::FFTAnyJet<reco::CaloJet> > -------------------------------
static void constructor_22362( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::PtrVector<reco::FFTAnyJet<reco::CaloJet> >();
  else ::new(mem) ::edm::PtrVector<reco::FFTAnyJet<reco::CaloJet> >();
}

static void constructor_22363( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::PtrVector<reco::FFTAnyJet<reco::CaloJet> >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::PtrVector<reco::FFTAnyJet<reco::CaloJet> >(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_22364( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::PtrVector<reco::FFTAnyJet<reco::CaloJet> >(*(const ::edm::PtrVector<reco::FFTAnyJet<reco::CaloJet> >*)arg[0]);
  else ::new(mem) ::edm::PtrVector<reco::FFTAnyJet<reco::CaloJet> >(*(const ::edm::PtrVector<reco::FFTAnyJet<reco::CaloJet> >*)arg[0]);
}

static  void operator_22365( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::FFTAnyJet<reco::CaloJet> >)((((const ::edm::PtrVector<reco::FFTAnyJet<reco::CaloJet> >*)o)->operator[])(*(const unsigned long*)arg[0]));
  else   (((const ::edm::PtrVector<reco::FFTAnyJet<reco::CaloJet> >*)o)->operator[])(*(const unsigned long*)arg[0]);
}

static  void method_22366( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::PtrVectorItr<reco::FFTAnyJet<reco::CaloJet> >)((((const ::edm::PtrVector<reco::FFTAnyJet<reco::CaloJet> >*)o)->begin)());
  else   (((const ::edm::PtrVector<reco::FFTAnyJet<reco::CaloJet> >*)o)->begin)();
}

static  void method_22367( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::PtrVectorItr<reco::FFTAnyJet<reco::CaloJet> >)((((const ::edm::PtrVector<reco::FFTAnyJet<reco::CaloJet> >*)o)->end)());
  else   (((const ::edm::PtrVector<reco::FFTAnyJet<reco::CaloJet> >*)o)->end)();
}

static  void method_22368( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::PtrVector<reco::FFTAnyJet<reco::CaloJet> >*)o)->push_back)(*(const ::edm::Ptr<reco::FFTAnyJet<reco::CaloJet> >*)arg[0]);
}

static  void method_22369( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::PtrVector<reco::FFTAnyJet<reco::CaloJet> >*)o)->swap)(*(::edm::PtrVector<reco::FFTAnyJet<reco::CaloJet> >*)arg[0]);
}

static  void operator_22370( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::PtrVector<reco::FFTAnyJet<reco::CaloJet> >*)o)->operator=)(*(const ::edm::PtrVector<reco::FFTAnyJet<reco::CaloJet> >*)arg[0]);
  else   (((::edm::PtrVector<reco::FFTAnyJet<reco::CaloJet> >*)o)->operator=)(*(const ::edm::PtrVector<reco::FFTAnyJet<reco::CaloJet> >*)arg[0]);
}

static  void method_22371( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::PtrVector<reco::FFTAnyJet<reco::CaloJet> >*)o)->fillView)(*(::std::vector<const void*>*)arg[0]);
}

static  void method_22372( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::PtrVector<reco::FFTAnyJet<reco::CaloJet> >*)o)->Class_Version)());
  else   (((::edm::PtrVector<reco::FFTAnyJet<reco::CaloJet> >*)o)->Class_Version)();
}

static void destructor_22375(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::PtrVector<reco::FFTAnyJet<reco::CaloJet> >*)o)->::edm::PtrVector<reco::FFTAnyJet<reco::CaloJet> >::~PtrVector)();
}
static void method_newdel_4634( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::PtrVector<reco::FFTAnyJet<reco::CaloJet> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::PtrVector<reco::FFTAnyJet<reco::CaloJet> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::PtrVector<reco::FFTAnyJet<reco::CaloJet> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::PtrVector<reco::FFTAnyJet<reco::CaloJet> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::PtrVector<reco::FFTAnyJet<reco::CaloJet> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x133( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::PtrVectorBase")), ::Reflex::BaseOffset< ::edm::PtrVector<reco::FFTAnyJet<reco::CaloJet> >,::edm::PtrVectorBase >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PtrVector<reco::FFTAnyJet<reco::CaloJet> > -------------------------------
void __edm__PtrVector_reco__FFTAnyJet_reco__CaloJet_s__db_datamem(Reflex::Class*);
void __edm__PtrVector_reco__FFTAnyJet_reco__CaloJet_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__PtrVector_reco__FFTAnyJet_reco__CaloJet_s__datamem_bld(&__edm__PtrVector_reco__FFTAnyJet_reco__CaloJet_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__PtrVector_reco__FFTAnyJet_reco__CaloJet_s__funcmem_bld(&__edm__PtrVector_reco__FFTAnyJet_reco__CaloJet_s__db_funcmem);
void __edm__PtrVector_reco__FFTAnyJet_reco__CaloJet_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::PtrVector<reco::FFTAnyJet<reco::CaloJet> >"), typeid(::edm::PtrVector<reco::FFTAnyJet<reco::CaloJet> >), sizeof(::edm::PtrVector<reco::FFTAnyJet<reco::CaloJet> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::PtrVector<reco::FFTAnyJet<reco::CaloJet> >::Class_Version())
  .AddProperty(Reflex::Literal("o_name"), "edm::PtrVector<reco::FFTCaloJet>")
  .AddBase(type_4894, ::Reflex::BaseOffset< ::edm::PtrVector<reco::FFTAnyJet<reco::CaloJet> >, ::edm::PtrVectorBase >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_4796, Reflex::Literal("edm::PtrVector<reco::FFTAnyJet<reco::CaloJet> >::const_iterator"))
  .AddTypedef(type_4796, Reflex::Literal("edm::PtrVector<reco::FFTAnyJet<reco::CaloJet> >::iterator"))
  .AddTypedef(type_4986, Reflex::Literal("edm::PtrVector<reco::FFTAnyJet<reco::CaloJet> >::value_type"))
  .AddTypedef(type_694, Reflex::Literal("edm::PtrVector<reco::FFTAnyJet<reco::CaloJet> >::collection_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PtrVector"), constructor_22362, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20599), Reflex::Literal("PtrVector"), constructor_22363, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39228), Reflex::Literal("PtrVector"), constructor_22364, 0, "iOther", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PtrVector"), destructor_22375, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4634, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x133, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__edm__PtrVector_reco__FFTAnyJet_reco__CaloJet_s__funcmem_bld);
}

//------Delayed data member builder for class PtrVector<reco::FFTAnyJet<reco::CaloJet> > -------------------
void __edm__PtrVector_reco__FFTAnyJet_reco__CaloJet_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class PtrVector<reco::FFTAnyJet<reco::CaloJet> > -------------------
void __edm__PtrVector_reco__FFTAnyJet_reco__CaloJet_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4986, type_358c), Reflex::Literal("operator[]"), operator_22365, 0, "iIndex", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4796), Reflex::Literal("begin"), method_22366, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4796), Reflex::Literal("end"), method_22367, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_39229), Reflex::Literal("push_back"), method_22368, 0, "iPtr", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_39230), Reflex::Literal("swap"), method_22369, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39230, type_39228), Reflex::Literal("operator="), operator_22370, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20679), Reflex::Literal("fillView"), method_22371, 0, "pointers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_237), Reflex::Literal("Class_Version"), method_22372, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class PtrVector<reco::FFTAnyJet<reco::GenJet> > -------------------------------
static void constructor_22380( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::PtrVector<reco::FFTAnyJet<reco::GenJet> >();
  else ::new(mem) ::edm::PtrVector<reco::FFTAnyJet<reco::GenJet> >();
}

static void constructor_22381( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::PtrVector<reco::FFTAnyJet<reco::GenJet> >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::PtrVector<reco::FFTAnyJet<reco::GenJet> >(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_22382( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::PtrVector<reco::FFTAnyJet<reco::GenJet> >(*(const ::edm::PtrVector<reco::FFTAnyJet<reco::GenJet> >*)arg[0]);
  else ::new(mem) ::edm::PtrVector<reco::FFTAnyJet<reco::GenJet> >(*(const ::edm::PtrVector<reco::FFTAnyJet<reco::GenJet> >*)arg[0]);
}

static  void operator_22383( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::FFTAnyJet<reco::GenJet> >)((((const ::edm::PtrVector<reco::FFTAnyJet<reco::GenJet> >*)o)->operator[])(*(const unsigned long*)arg[0]));
  else   (((const ::edm::PtrVector<reco::FFTAnyJet<reco::GenJet> >*)o)->operator[])(*(const unsigned long*)arg[0]);
}

static  void method_22384( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::PtrVectorItr<reco::FFTAnyJet<reco::GenJet> >)((((const ::edm::PtrVector<reco::FFTAnyJet<reco::GenJet> >*)o)->begin)());
  else   (((const ::edm::PtrVector<reco::FFTAnyJet<reco::GenJet> >*)o)->begin)();
}

static  void method_22385( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::PtrVectorItr<reco::FFTAnyJet<reco::GenJet> >)((((const ::edm::PtrVector<reco::FFTAnyJet<reco::GenJet> >*)o)->end)());
  else   (((const ::edm::PtrVector<reco::FFTAnyJet<reco::GenJet> >*)o)->end)();
}

static  void method_22386( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::PtrVector<reco::FFTAnyJet<reco::GenJet> >*)o)->push_back)(*(const ::edm::Ptr<reco::FFTAnyJet<reco::GenJet> >*)arg[0]);
}

static  void method_22387( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::PtrVector<reco::FFTAnyJet<reco::GenJet> >*)o)->swap)(*(::edm::PtrVector<reco::FFTAnyJet<reco::GenJet> >*)arg[0]);
}

static  void operator_22388( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::PtrVector<reco::FFTAnyJet<reco::GenJet> >*)o)->operator=)(*(const ::edm::PtrVector<reco::FFTAnyJet<reco::GenJet> >*)arg[0]);
  else   (((::edm::PtrVector<reco::FFTAnyJet<reco::GenJet> >*)o)->operator=)(*(const ::edm::PtrVector<reco::FFTAnyJet<reco::GenJet> >*)arg[0]);
}

static  void method_22389( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::PtrVector<reco::FFTAnyJet<reco::GenJet> >*)o)->fillView)(*(::std::vector<const void*>*)arg[0]);
}

static  void method_22390( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::PtrVector<reco::FFTAnyJet<reco::GenJet> >*)o)->Class_Version)());
  else   (((::edm::PtrVector<reco::FFTAnyJet<reco::GenJet> >*)o)->Class_Version)();
}

static void destructor_22393(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::PtrVector<reco::FFTAnyJet<reco::GenJet> >*)o)->::edm::PtrVector<reco::FFTAnyJet<reco::GenJet> >::~PtrVector)();
}
static void method_newdel_4635( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::PtrVector<reco::FFTAnyJet<reco::GenJet> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::PtrVector<reco::FFTAnyJet<reco::GenJet> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::PtrVector<reco::FFTAnyJet<reco::GenJet> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::PtrVector<reco::FFTAnyJet<reco::GenJet> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::PtrVector<reco::FFTAnyJet<reco::GenJet> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x135( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::PtrVectorBase")), ::Reflex::BaseOffset< ::edm::PtrVector<reco::FFTAnyJet<reco::GenJet> >,::edm::PtrVectorBase >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PtrVector<reco::FFTAnyJet<reco::GenJet> > -------------------------------
void __edm__PtrVector_reco__FFTAnyJet_reco__GenJet_s__db_datamem(Reflex::Class*);
void __edm__PtrVector_reco__FFTAnyJet_reco__GenJet_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__PtrVector_reco__FFTAnyJet_reco__GenJet_s__datamem_bld(&__edm__PtrVector_reco__FFTAnyJet_reco__GenJet_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__PtrVector_reco__FFTAnyJet_reco__GenJet_s__funcmem_bld(&__edm__PtrVector_reco__FFTAnyJet_reco__GenJet_s__db_funcmem);
void __edm__PtrVector_reco__FFTAnyJet_reco__GenJet_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::PtrVector<reco::FFTAnyJet<reco::GenJet> >"), typeid(::edm::PtrVector<reco::FFTAnyJet<reco::GenJet> >), sizeof(::edm::PtrVector<reco::FFTAnyJet<reco::GenJet> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::PtrVector<reco::FFTAnyJet<reco::GenJet> >::Class_Version())
  .AddProperty(Reflex::Literal("o_name"), "edm::PtrVector<reco::FFTGenJet>")
  .AddBase(type_4894, ::Reflex::BaseOffset< ::edm::PtrVector<reco::FFTAnyJet<reco::GenJet> >, ::edm::PtrVectorBase >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_4797, Reflex::Literal("edm::PtrVector<reco::FFTAnyJet<reco::GenJet> >::const_iterator"))
  .AddTypedef(type_4797, Reflex::Literal("edm::PtrVector<reco::FFTAnyJet<reco::GenJet> >::iterator"))
  .AddTypedef(type_4987, Reflex::Literal("edm::PtrVector<reco::FFTAnyJet<reco::GenJet> >::value_type"))
  .AddTypedef(type_694, Reflex::Literal("edm::PtrVector<reco::FFTAnyJet<reco::GenJet> >::collection_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PtrVector"), constructor_22380, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20599), Reflex::Literal("PtrVector"), constructor_22381, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39231), Reflex::Literal("PtrVector"), constructor_22382, 0, "iOther", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PtrVector"), destructor_22393, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4635, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x135, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__edm__PtrVector_reco__FFTAnyJet_reco__GenJet_s__funcmem_bld);
}

//------Delayed data member builder for class PtrVector<reco::FFTAnyJet<reco::GenJet> > -------------------
void __edm__PtrVector_reco__FFTAnyJet_reco__GenJet_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class PtrVector<reco::FFTAnyJet<reco::GenJet> > -------------------
void __edm__PtrVector_reco__FFTAnyJet_reco__GenJet_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4987, type_358c), Reflex::Literal("operator[]"), operator_22383, 0, "iIndex", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4797), Reflex::Literal("begin"), method_22384, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4797), Reflex::Literal("end"), method_22385, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_39232), Reflex::Literal("push_back"), method_22386, 0, "iPtr", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_39233), Reflex::Literal("swap"), method_22387, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39233, type_39231), Reflex::Literal("operator="), operator_22388, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20679), Reflex::Literal("fillView"), method_22389, 0, "pointers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_237), Reflex::Literal("Class_Version"), method_22390, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Wrapper<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> > > -------------------------------
static void constructor_23115( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<reco::CATopJetTagInfo> >();
  else ::new(mem) ::edm::Wrapper<std::vector<reco::CATopJetTagInfo> >();
}

static void constructor_23116( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<reco::CATopJetTagInfo> >(*(::std::auto_ptr<std::vector<reco::CATopJetTagInfo> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<reco::CATopJetTagInfo> >(*(::std::auto_ptr<std::vector<reco::CATopJetTagInfo> >*)arg[0]);
}

static void destructor_23117(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<reco::CATopJetTagInfo> >*)o)->::edm::Wrapper<std::vector<reco::CATopJetTagInfo> >::~Wrapper)();
}
static  void method_23118( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<reco::CATopJetTagInfo> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<reco::CATopJetTagInfo> >*)o)->product)();
}

static  void operator_23119( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<reco::CATopJetTagInfo> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<reco::CATopJetTagInfo> >*)o)->operator->)();
}

static  void method_23120( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<reco::CATopJetTagInfo> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<reco::CATopJetTagInfo> >*)o)->productTypeInfo)();
}

static  void method_23121( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<reco::CATopJetTagInfo> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<reco::CATopJetTagInfo> >*)o)->typeInfo)();
}

static void constructor_23122( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<reco::CATopJetTagInfo> >((::std::vector<reco::CATopJetTagInfo>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<reco::CATopJetTagInfo> >((::std::vector<reco::CATopJetTagInfo>*)arg[0]);
}

static  void method_23123( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<reco::CATopJetTagInfo> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<reco::CATopJetTagInfo> >*)o)->getInterface)();
}

static  void method_23124( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<reco::CATopJetTagInfo> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_23125( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<reco::CATopJetTagInfo> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_23126( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<reco::CATopJetTagInfo> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_23127( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<reco::CATopJetTagInfo> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<reco::CATopJetTagInfo> >*)o)->dynamicTypeInfo)();
}

static  void method_23128( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<reco::CATopJetTagInfo> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<reco::CATopJetTagInfo> >*)o)->isPresent)();
}

static  void method_23129( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<reco::CATopJetTagInfo> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<reco::CATopJetTagInfo> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4739( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::CATopJetTagInfo> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::CATopJetTagInfo> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::CATopJetTagInfo> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::CATopJetTagInfo> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::CATopJetTagInfo> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> > > -------------------------------
void __edm__Wrapper_std__vector_reco__CATopJetTagInfo_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_reco__CATopJetTagInfo_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_reco__CATopJetTagInfo_s__datamem_bld(&__edm__Wrapper_std__vector_reco__CATopJetTagInfo_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_reco__CATopJetTagInfo_s__funcmem_bld(&__edm__Wrapper_std__vector_reco__CATopJetTagInfo_s__db_funcmem);
void __edm__Wrapper_std__vector_reco__CATopJetTagInfo_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<reco::CATopJetTagInfo> >"), typeid(::edm::Wrapper<std::vector<reco::CATopJetTagInfo> >), sizeof(::edm::Wrapper<std::vector<reco::CATopJetTagInfo> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<reco::CATopJetTagInfoCollection>")
  .AddTypedef(type_2973, Reflex::Literal("edm::Wrapper<std::vector<reco::CATopJetTagInfo> >::value_type"))
  .AddTypedef(type_2973, Reflex::Literal("edm::Wrapper<std::vector<reco::CATopJetTagInfo> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_23115, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2774), Reflex::Literal("Wrapper"), constructor_23116, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_23117, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39330), Reflex::Literal("Wrapper"), constructor_23122, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4739, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_reco__CATopJetTagInfo_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_reco__CATopJetTagInfo_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> > > -------------------
void __edm__Wrapper_std__vector_reco__CATopJetTagInfo_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1566, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_reco__CATopJetTagInfo_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2973, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_reco__CATopJetTagInfo_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> > > -------------------
void __edm__Wrapper_std__vector_reco__CATopJetTagInfo_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39273), Reflex::Literal("product"), method_23118, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39273), Reflex::Literal("operator->"), operator_23119, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("productTypeInfo"), method_23120, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("typeInfo"), method_23121, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39331), Reflex::Literal("getInterface"), method_23123, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20599, type_20679, type_38738), Reflex::Literal("fillView"), method_23124, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20732, type_358, type_11036), Reflex::Literal("setPtr"), method_23125, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20732, type_26144, type_20679), Reflex::Literal("fillPtrVector"), method_23126, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("dynamicTypeInfo"), method_23127, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isPresent"), method_23128, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("dynamicTypeInfo_"), method_23129, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Association<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > > > -------------------------------
static void destructor_25171(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->::edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > >::~Association)();
}
static void constructor_25172( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > >(*(const ::edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)arg[0]);
  else ::new(mem) ::edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > >(*(const ::edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)arg[0]);
}

static void constructor_25173( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > >();
  else ::new(mem) ::edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > >();
}

static  void method_25174( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >)((((const ::edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->get)(*(::size_t*)arg[0]));
  else   (((const ::edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->get)(*(::size_t*)arg[0]);
}

static  void method_25175( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >)((((const ::edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->get)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]));
  else   (((const ::edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->get)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]);
}

static  void operator_25176( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->operator+=)(*(const ::edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)arg[0]);
  else   (((::edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->operator+=)(*(const ::edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)arg[0]);
}

static  void method_25177( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->setRef)(*(const ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)arg[0]);
}

static  void method_25178( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->contains)(*(::edm::ProductID*)arg[0]));
  else   (((const ::edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->contains)(*(::edm::ProductID*)arg[0]);
}

static  void method_25179( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->size)());
  else   (((const ::edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->size)();
}

static  void method_25180( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->empty)());
  else   (((const ::edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->empty)();
}

static  void method_25181( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->clear)();
}

static  void method_25182( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefProd<std::vector<reco::FFTAnyJet<reco::CaloJet> > >)((((const ::edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->ref)());
  else   (((const ::edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->ref)();
}

static  void method_25183( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->swap)(*(::edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)arg[0]);
}

static  void operator_25184( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->operator=)(*(const ::edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)arg[0]);
  else   (((::edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->operator=)(*(const ::edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)arg[0]);
}

static  void method_25185( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->ids)();
  else   (((const ::edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->ids)();
}

static  void method_25186( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->Class_Version)());
  else   (((::edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->Class_Version)();
}

static void method_newdel_5012( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x138( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::ValueMap<int>")), ::Reflex::BaseOffset< ::edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > >,::edm::ValueMap<int> >::Get(),::Reflex::PRIVATE), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Association<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > > > -------------------------------
void __edm__Association_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s__db_datamem(Reflex::Class*);
void __edm__Association_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Association_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s__datamem_bld(&__edm__Association_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Association_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s__funcmem_bld(&__edm__Association_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s__db_funcmem);
void __edm__Association_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > >"), typeid(::edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > >), sizeof(::edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > >::Class_Version())
  .AddProperty(Reflex::Literal("o_name"), "edm::Association<reco::FFTCaloJetCollection>")
  .AddBase(type_5079, ::Reflex::BaseOffset< ::edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > >, ::edm::ValueMap<int> >::Get(), ::Reflex::PRIVATE)
  .AddTypedef(type_68, Reflex::Literal("edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > >::index"))
  .AddTypedef(type_5079, Reflex::Literal("edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > >::base"))
  .AddTypedef(type_366, Reflex::Literal("edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > >::offset"))
  .AddTypedef(type_4953, Reflex::Literal("edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > >::refprod_type"))
  .AddTypedef(type_5019, Reflex::Literal("edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > >::reference_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Association"), destructor_25171, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39918), Reflex::Literal("Association"), constructor_25172, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Association"), constructor_25173, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_5012, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x138, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Association_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Association_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s__funcmem_bld);
}

//------Delayed data member builder for class Association<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > > > -------------------
void __edm__Association_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4953, Reflex::Literal("ref_"), OffsetOf(__shadow__::__edm__Association_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s_, ref_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Association<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > > > -------------------
void __edm__Association_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5019, type_2121), Reflex::Literal("get"), method_25174, 0, "rawIdx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5019, type_4933, type_2121), Reflex::Literal("get"), method_25175, 0, "id;idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39919, type_39918), Reflex::Literal("operator+="), operator_25176, 0, "o", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_39831), Reflex::Literal("setRef"), method_25177, 0, "ref", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566, type_4933), Reflex::Literal("contains"), method_25178, 0, "id", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2121), Reflex::Literal("size"), method_25179, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("empty"), method_25180, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694), Reflex::Literal("clear"), method_25181, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4953), Reflex::Literal("ref"), method_25182, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_39919), Reflex::Literal("swap"), method_25183, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39919, type_39918), Reflex::Literal("operator="), operator_25184, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35947), Reflex::Literal("ids"), method_25185, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_237), Reflex::Literal("Class_Version"), method_25186, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > > > > -------------------------------
static void constructor_23136( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > > >();
  else ::new(mem) ::edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > > >();
}

static void constructor_23137( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > > >(*(::std::auto_ptr<edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > > >(*(::std::auto_ptr<edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > > >*)arg[0]);
}

static void destructor_23138(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > > >*)o)->::edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > > >::~Wrapper)();
}
static  void method_23139( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > > >*)o)->product)());
  else   (((const ::edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > > >*)o)->product)();
}

static  void operator_23140( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > > >*)o)->operator->)();
}

static  void method_23141( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > > >*)o)->productTypeInfo)();
}

static  void method_23142( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > > >*)o)->typeInfo)();
}

static void constructor_23143( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > > >((::edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > > >((::edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)arg[0]);
}

static  void method_23144( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > > >*)o)->getInterface)());
  else   (((::edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > > >*)o)->getInterface)();
}

static  void method_23145( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_23146( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_23147( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_23148( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > > >*)o)->dynamicTypeInfo)();
}

static  void method_23149( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > > >*)o)->isPresent)();
}

static  void method_23150( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4740( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > > > > -------------------------------
void __edm__Wrapper_edm__Association_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_edm__Association_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__Association_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s_s__datamem_bld(&__edm__Wrapper_edm__Association_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__Association_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s_s__funcmem_bld(&__edm__Wrapper_edm__Association_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s_s__db_funcmem);
void __edm__Wrapper_edm__Association_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > > >"), typeid(::edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > > >), sizeof(::edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<edm::Association<reco::FFTCaloJetCollection> >")
  .AddTypedef(type_5012, Reflex::Literal("edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > > >::value_type"))
  .AddTypedef(type_5012, Reflex::Literal("edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_23136, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2775), Reflex::Literal("Wrapper"), constructor_23137, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_23138, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39335), Reflex::Literal("Wrapper"), constructor_23143, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4740, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_edm__Association_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_edm__Association_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > > > > -------------------
void __edm__Wrapper_edm__Association_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1566, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_edm__Association_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_5012, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_edm__Association_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > > > > -------------------
void __edm__Wrapper_edm__Association_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39334), Reflex::Literal("product"), method_23139, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39334), Reflex::Literal("operator->"), operator_23140, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("productTypeInfo"), method_23141, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("typeInfo"), method_23142, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39336), Reflex::Literal("getInterface"), method_23144, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20599, type_20679, type_38738), Reflex::Literal("fillView"), method_23145, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20732, type_358, type_11036), Reflex::Literal("setPtr"), method_23146, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20732, type_26144, type_20679), Reflex::Literal("fillPtrVector"), method_23147, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("dynamicTypeInfo"), method_23148, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isPresent"), method_23149, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("dynamicTypeInfo_"), method_23150, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >, std::allocator<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > > > -------------------------------
static void constructor_23157( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > >();
  else ::new(mem) ::edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > >();
}

static void constructor_23158( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > >(*(::std::auto_ptr<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > >(*(::std::auto_ptr<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > >*)arg[0]);
}

static void destructor_23159(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > >*)o)->::edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > >::~Wrapper)();
}
static  void method_23160( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > >*)o)->product)();
}

static  void operator_23161( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > >*)o)->operator->)();
}

static  void method_23162( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > >*)o)->productTypeInfo)();
}

static  void method_23163( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > >*)o)->typeInfo)();
}

static void constructor_23164( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > >((::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > >((::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > >*)arg[0]);
}

static  void method_23165( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > >*)o)->getInterface)();
}

static  void method_23166( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_23167( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_23168( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_23169( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > >*)o)->dynamicTypeInfo)();
}

static  void method_23170( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > >*)o)->isPresent)();
}

static  void method_23171( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4741( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >, std::allocator<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > > > -------------------------------
void __edm__Wrapper_std__vector_edm__FwdPtr_reco__FFTAnyJet_reco__CaloJet_s_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_edm__FwdPtr_reco__FFTAnyJet_reco__CaloJet_s_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_edm__FwdPtr_reco__FFTAnyJet_reco__CaloJet_s_s_s__datamem_bld(&__edm__Wrapper_std__vector_edm__FwdPtr_reco__FFTAnyJet_reco__CaloJet_s_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_edm__FwdPtr_reco__FFTAnyJet_reco__CaloJet_s_s_s__funcmem_bld(&__edm__Wrapper_std__vector_edm__FwdPtr_reco__FFTAnyJet_reco__CaloJet_s_s_s__db_funcmem);
void __edm__Wrapper_std__vector_edm__FwdPtr_reco__FFTAnyJet_reco__CaloJet_s_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > >"), typeid(::edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > >), sizeof(::edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<reco::FFTCaloJetFwdPtrVector>")
  .AddTypedef(type_2981, Reflex::Literal("edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > >::value_type"))
  .AddTypedef(type_2981, Reflex::Literal("edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_23157, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2778), Reflex::Literal("Wrapper"), constructor_23158, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_23159, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39340), Reflex::Literal("Wrapper"), constructor_23164, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4741, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_edm__FwdPtr_reco__FFTAnyJet_reco__CaloJet_s_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_edm__FwdPtr_reco__FFTAnyJet_reco__CaloJet_s_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >, std::allocator<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > > > -------------------
void __edm__Wrapper_std__vector_edm__FwdPtr_reco__FFTAnyJet_reco__CaloJet_s_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1566, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_edm__FwdPtr_reco__FFTAnyJet_reco__CaloJet_s_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2981, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_edm__FwdPtr_reco__FFTAnyJet_reco__CaloJet_s_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> >, std::allocator<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > > > -------------------
void __edm__Wrapper_std__vector_edm__FwdPtr_reco__FFTAnyJet_reco__CaloJet_s_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39339), Reflex::Literal("product"), method_23160, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39339), Reflex::Literal("operator->"), operator_23161, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("productTypeInfo"), method_23162, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("typeInfo"), method_23163, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39341), Reflex::Literal("getInterface"), method_23165, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20599, type_20679, type_38738), Reflex::Literal("fillView"), method_23166, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20732, type_358, type_11036), Reflex::Literal("setPtr"), method_23167, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20732, type_26144, type_20679), Reflex::Literal("fillPtrVector"), method_23168, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("dynamicTypeInfo"), method_23169, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isPresent"), method_23170, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("dynamicTypeInfo_"), method_23171, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >, reco::FFTAnyJet<reco::CaloJet>, edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >, reco::FFTAnyJet<reco::CaloJet> > >, std::allocator<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >, reco::FFTAnyJet<reco::CaloJet>, edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >, reco::FFTAnyJet<reco::CaloJet> > > > > > -------------------------------
static void constructor_23178( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >();
  else ::new(mem) ::edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >();
}

static void constructor_23179( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >(*(::std::auto_ptr<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >(*(::std::auto_ptr<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >*)arg[0]);
}

static void destructor_23180(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >*)o)->::edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >::~Wrapper)();
}
static  void method_23181( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >*)o)->product)();
}

static  void operator_23182( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >*)o)->operator->)();
}

static  void method_23183( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >*)o)->productTypeInfo)();
}

static  void method_23184( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >*)o)->typeInfo)();
}

static void constructor_23185( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >((::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >((::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)arg[0]);
}

static  void method_23186( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >*)o)->getInterface)();
}

static  void method_23187( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_23188( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_23189( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_23190( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >*)o)->dynamicTypeInfo)();
}

static  void method_23191( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >*)o)->isPresent)();
}

static  void method_23192( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4742( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >, reco::FFTAnyJet<reco::CaloJet>, edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >, reco::FFTAnyJet<reco::CaloJet> > >, std::allocator<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >, reco::FFTAnyJet<reco::CaloJet>, edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >, reco::FFTAnyJet<reco::CaloJet> > > > > > -------------------------------
void __edm__Wrapper_std__vector_edm__FwdRef_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_edm__FwdRef_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_edm__FwdRef_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s_s__datamem_bld(&__edm__Wrapper_std__vector_edm__FwdRef_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_edm__FwdRef_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s_s__funcmem_bld(&__edm__Wrapper_std__vector_edm__FwdRef_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s_s__db_funcmem);
void __edm__Wrapper_std__vector_edm__FwdRef_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >"), typeid(::edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >), sizeof(::edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<reco::FFTCaloJetFwdRefVector>")
  .AddTypedef(type_2982, Reflex::Literal("edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >::value_type"))
  .AddTypedef(type_2982, Reflex::Literal("edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_23178, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2779), Reflex::Literal("Wrapper"), constructor_23179, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_23180, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39345), Reflex::Literal("Wrapper"), constructor_23185, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4742, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_edm__FwdRef_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_edm__FwdRef_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >, reco::FFTAnyJet<reco::CaloJet>, edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >, reco::FFTAnyJet<reco::CaloJet> > >, std::allocator<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >, reco::FFTAnyJet<reco::CaloJet>, edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >, reco::FFTAnyJet<reco::CaloJet> > > > > > -------------------
void __edm__Wrapper_std__vector_edm__FwdRef_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1566, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_edm__FwdRef_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2982, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_edm__FwdRef_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >, reco::FFTAnyJet<reco::CaloJet>, edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >, reco::FFTAnyJet<reco::CaloJet> > >, std::allocator<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >, reco::FFTAnyJet<reco::CaloJet>, edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >, reco::FFTAnyJet<reco::CaloJet> > > > > > -------------------
void __edm__Wrapper_std__vector_edm__FwdRef_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39344), Reflex::Literal("product"), method_23181, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39344), Reflex::Literal("operator->"), operator_23182, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("productTypeInfo"), method_23183, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("typeInfo"), method_23184, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39346), Reflex::Literal("getInterface"), method_23186, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20599, type_20679, type_38738), Reflex::Literal("fillView"), method_23187, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20732, type_358, type_11036), Reflex::Literal("setPtr"), method_23188, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20732, type_26144, type_20679), Reflex::Literal("fillPtrVector"), method_23189, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("dynamicTypeInfo"), method_23190, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isPresent"), method_23191, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("dynamicTypeInfo_"), method_23192, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >, reco::FFTAnyJet<reco::CaloJet>, edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >, reco::FFTAnyJet<reco::CaloJet> > > > -------------------------------
static void constructor_23199( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >();
  else ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >();
}

static void constructor_23200( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >(*(::std::auto_ptr<edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >(*(::std::auto_ptr<edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)arg[0]);
}

static void destructor_23201(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->::edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >::~Wrapper)();
}
static  void method_23202( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->product)());
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->product)();
}

static  void operator_23203( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->operator->)();
}

static  void method_23204( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->productTypeInfo)();
}

static  void method_23205( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->typeInfo)();
}

static void constructor_23206( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >((::edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >((::edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)arg[0]);
}

static  void method_23207( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->getInterface)());
  else   (((::edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->getInterface)();
}

static  void method_23208( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_23209( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_23210( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_23211( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->dynamicTypeInfo)();
}

static  void method_23212( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->isPresent)();
}

static  void method_23213( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4743( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >, reco::FFTAnyJet<reco::CaloJet>, edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >, reco::FFTAnyJet<reco::CaloJet> > > > -------------------------------
void __edm__Wrapper_edm__RefVector_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_edm__RefVector_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__RefVector_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s__datamem_bld(&__edm__Wrapper_edm__RefVector_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__RefVector_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s__funcmem_bld(&__edm__Wrapper_edm__RefVector_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s__db_funcmem);
void __edm__Wrapper_edm__RefVector_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >"), typeid(::edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >), sizeof(::edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<reco::FFTCaloJetRefVector>")
  .AddTypedef(type_4671, Reflex::Literal("edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >::value_type"))
  .AddTypedef(type_4671, Reflex::Literal("edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_23199, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2780), Reflex::Literal("Wrapper"), constructor_23200, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_23201, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39350), Reflex::Literal("Wrapper"), constructor_23206, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4743, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_edm__RefVector_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_edm__RefVector_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >, reco::FFTAnyJet<reco::CaloJet>, edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >, reco::FFTAnyJet<reco::CaloJet> > > > -------------------
void __edm__Wrapper_edm__RefVector_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1566, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_edm__RefVector_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_4671, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_edm__RefVector_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >, reco::FFTAnyJet<reco::CaloJet>, edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >, reco::FFTAnyJet<reco::CaloJet> > > > -------------------
void __edm__Wrapper_edm__RefVector_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39349), Reflex::Literal("product"), method_23202, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39349), Reflex::Literal("operator->"), operator_23203, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("productTypeInfo"), method_23204, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("typeInfo"), method_23205, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39351), Reflex::Literal("getInterface"), method_23207, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20599, type_20679, type_38738), Reflex::Literal("fillView"), method_23208, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20732, type_358, type_11036), Reflex::Literal("setPtr"), method_23209, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20732, type_26144, type_20679), Reflex::Literal("fillPtrVector"), method_23210, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("dynamicTypeInfo"), method_23211, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isPresent"), method_23212, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("dynamicTypeInfo_"), method_23213, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > > > -------------------------------
static void constructor_23220( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<reco::FFTAnyJet<reco::CaloJet> > >();
  else ::new(mem) ::edm::Wrapper<std::vector<reco::FFTAnyJet<reco::CaloJet> > >();
}

static void constructor_23221( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<reco::FFTAnyJet<reco::CaloJet> > >(*(::std::auto_ptr<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<reco::FFTAnyJet<reco::CaloJet> > >(*(::std::auto_ptr<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)arg[0]);
}

static void destructor_23222(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->::edm::Wrapper<std::vector<reco::FFTAnyJet<reco::CaloJet> > >::~Wrapper)();
}
static  void method_23223( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->product)();
}

static  void operator_23224( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->operator->)();
}

static  void method_23225( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->productTypeInfo)();
}

static  void method_23226( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->typeInfo)();
}

static void constructor_23227( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<reco::FFTAnyJet<reco::CaloJet> > >((::std::vector<reco::FFTAnyJet<reco::CaloJet> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<reco::FFTAnyJet<reco::CaloJet> > >((::std::vector<reco::FFTAnyJet<reco::CaloJet> >*)arg[0]);
}

static  void method_23228( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->getInterface)();
}

static  void method_23229( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_23230( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_23231( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_23232( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->dynamicTypeInfo)();
}

static  void method_23233( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->isPresent)();
}

static  void method_23234( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4744( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::FFTAnyJet<reco::CaloJet> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::FFTAnyJet<reco::CaloJet> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::FFTAnyJet<reco::CaloJet> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::FFTAnyJet<reco::CaloJet> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::FFTAnyJet<reco::CaloJet> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > > > -------------------------------
void __edm__Wrapper_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s__datamem_bld(&__edm__Wrapper_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s__funcmem_bld(&__edm__Wrapper_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s__db_funcmem);
void __edm__Wrapper_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<reco::FFTAnyJet<reco::CaloJet> > >"), typeid(::edm::Wrapper<std::vector<reco::FFTAnyJet<reco::CaloJet> > >), sizeof(::edm::Wrapper<std::vector<reco::FFTAnyJet<reco::CaloJet> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<reco::FFTCaloJetCollection>")
  .AddTypedef(type_2983, Reflex::Literal("edm::Wrapper<std::vector<reco::FFTAnyJet<reco::CaloJet> > >::value_type"))
  .AddTypedef(type_2983, Reflex::Literal("edm::Wrapper<std::vector<reco::FFTAnyJet<reco::CaloJet> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_23220, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2781), Reflex::Literal("Wrapper"), constructor_23221, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_23222, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39354), Reflex::Literal("Wrapper"), constructor_23227, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4744, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > > > -------------------
void __edm__Wrapper_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1566, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2983, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > > > -------------------
void __edm__Wrapper_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39280), Reflex::Literal("product"), method_23223, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39280), Reflex::Literal("operator->"), operator_23224, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("productTypeInfo"), method_23225, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("typeInfo"), method_23226, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39355), Reflex::Literal("getInterface"), method_23228, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20599, type_20679, type_38738), Reflex::Literal("fillView"), method_23229, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20732, type_358, type_11036), Reflex::Literal("setPtr"), method_23230, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20732, type_26144, type_20679), Reflex::Literal("fillPtrVector"), method_23231, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("dynamicTypeInfo"), method_23232, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isPresent"), method_23233, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("dynamicTypeInfo_"), method_23234, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Association<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > > > -------------------------------
static void destructor_25197(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->::edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > >::~Association)();
}
static void constructor_25198( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > >(*(const ::edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)arg[0]);
  else ::new(mem) ::edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > >(*(const ::edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)arg[0]);
}

static void constructor_25199( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > >();
  else ::new(mem) ::edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > >();
}

static  void method_25200( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >)((((const ::edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->get)(*(::size_t*)arg[0]));
  else   (((const ::edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->get)(*(::size_t*)arg[0]);
}

static  void method_25201( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >)((((const ::edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->get)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]));
  else   (((const ::edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->get)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]);
}

static  void operator_25202( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->operator+=)(*(const ::edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)arg[0]);
  else   (((::edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->operator+=)(*(const ::edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)arg[0]);
}

static  void method_25203( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->setRef)(*(const ::edm::RefProd<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)arg[0]);
}

static  void method_25204( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->contains)(*(::edm::ProductID*)arg[0]));
  else   (((const ::edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->contains)(*(::edm::ProductID*)arg[0]);
}

static  void method_25205( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->size)());
  else   (((const ::edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->size)();
}

static  void method_25206( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->empty)());
  else   (((const ::edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->empty)();
}

static  void method_25207( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->clear)();
}

static  void method_25208( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefProd<std::vector<reco::FFTAnyJet<reco::GenJet> > >)((((const ::edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->ref)());
  else   (((const ::edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->ref)();
}

static  void method_25209( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->swap)(*(::edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)arg[0]);
}

static  void operator_25210( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->operator=)(*(const ::edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)arg[0]);
  else   (((::edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->operator=)(*(const ::edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)arg[0]);
}

static  void method_25211( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->ids)();
  else   (((const ::edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->ids)();
}

static  void method_25212( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->Class_Version)());
  else   (((::edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->Class_Version)();
}

static void method_newdel_5013( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x145( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::ValueMap<int>")), ::Reflex::BaseOffset< ::edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > >,::edm::ValueMap<int> >::Get(),::Reflex::PRIVATE), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Association<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > > > -------------------------------
void __edm__Association_std__vector_reco__FFTAnyJet_reco__GenJet_s_s__db_datamem(Reflex::Class*);
void __edm__Association_std__vector_reco__FFTAnyJet_reco__GenJet_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Association_std__vector_reco__FFTAnyJet_reco__GenJet_s_s__datamem_bld(&__edm__Association_std__vector_reco__FFTAnyJet_reco__GenJet_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Association_std__vector_reco__FFTAnyJet_reco__GenJet_s_s__funcmem_bld(&__edm__Association_std__vector_reco__FFTAnyJet_reco__GenJet_s_s__db_funcmem);
void __edm__Association_std__vector_reco__FFTAnyJet_reco__GenJet_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > >"), typeid(::edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > >), sizeof(::edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > >::Class_Version())
  .AddProperty(Reflex::Literal("o_name"), "edm::Association<reco::FFTGenJetCollection>")
  .AddBase(type_5079, ::Reflex::BaseOffset< ::edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > >, ::edm::ValueMap<int> >::Get(), ::Reflex::PRIVATE)
  .AddTypedef(type_68, Reflex::Literal("edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > >::index"))
  .AddTypedef(type_5079, Reflex::Literal("edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > >::base"))
  .AddTypedef(type_366, Reflex::Literal("edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > >::offset"))
  .AddTypedef(type_4955, Reflex::Literal("edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > >::refprod_type"))
  .AddTypedef(type_5021, Reflex::Literal("edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > >::reference_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Association"), destructor_25197, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39920), Reflex::Literal("Association"), constructor_25198, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Association"), constructor_25199, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_5013, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x145, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Association_std__vector_reco__FFTAnyJet_reco__GenJet_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Association_std__vector_reco__FFTAnyJet_reco__GenJet_s_s__funcmem_bld);
}

//------Delayed data member builder for class Association<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > > > -------------------
void __edm__Association_std__vector_reco__FFTAnyJet_reco__GenJet_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4955, Reflex::Literal("ref_"), OffsetOf(__shadow__::__edm__Association_std__vector_reco__FFTAnyJet_reco__GenJet_s_s_, ref_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Association<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > > > -------------------
void __edm__Association_std__vector_reco__FFTAnyJet_reco__GenJet_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5021, type_2121), Reflex::Literal("get"), method_25200, 0, "rawIdx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5021, type_4933, type_2121), Reflex::Literal("get"), method_25201, 0, "id;idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39921, type_39920), Reflex::Literal("operator+="), operator_25202, 0, "o", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_39841), Reflex::Literal("setRef"), method_25203, 0, "ref", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566, type_4933), Reflex::Literal("contains"), method_25204, 0, "id", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2121), Reflex::Literal("size"), method_25205, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("empty"), method_25206, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694), Reflex::Literal("clear"), method_25207, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4955), Reflex::Literal("ref"), method_25208, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_39921), Reflex::Literal("swap"), method_25209, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39921, type_39920), Reflex::Literal("operator="), operator_25210, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35947), Reflex::Literal("ids"), method_25211, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_237), Reflex::Literal("Class_Version"), method_25212, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > > > > -------------------------------
static void constructor_23241( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > > >();
  else ::new(mem) ::edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > > >();
}

static void constructor_23242( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > > >(*(::std::auto_ptr<edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > > >(*(::std::auto_ptr<edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > > >*)arg[0]);
}

static void destructor_23243(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > > >*)o)->::edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > > >::~Wrapper)();
}
static  void method_23244( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > > >*)o)->product)());
  else   (((const ::edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > > >*)o)->product)();
}

static  void operator_23245( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > > >*)o)->operator->)();
}

static  void method_23246( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > > >*)o)->productTypeInfo)();
}

static  void method_23247( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > > >*)o)->typeInfo)();
}

static void constructor_23248( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > > >((::edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > > >((::edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)arg[0]);
}

static  void method_23249( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > > >*)o)->getInterface)());
  else   (((::edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > > >*)o)->getInterface)();
}

static  void method_23250( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_23251( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_23252( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_23253( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > > >*)o)->dynamicTypeInfo)();
}

static  void method_23254( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > > >*)o)->isPresent)();
}

static  void method_23255( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4745( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > > > > -------------------------------
void __edm__Wrapper_edm__Association_std__vector_reco__FFTAnyJet_reco__GenJet_s_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_edm__Association_std__vector_reco__FFTAnyJet_reco__GenJet_s_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__Association_std__vector_reco__FFTAnyJet_reco__GenJet_s_s_s__datamem_bld(&__edm__Wrapper_edm__Association_std__vector_reco__FFTAnyJet_reco__GenJet_s_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__Association_std__vector_reco__FFTAnyJet_reco__GenJet_s_s_s__funcmem_bld(&__edm__Wrapper_edm__Association_std__vector_reco__FFTAnyJet_reco__GenJet_s_s_s__db_funcmem);
void __edm__Wrapper_edm__Association_std__vector_reco__FFTAnyJet_reco__GenJet_s_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > > >"), typeid(::edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > > >), sizeof(::edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<edm::Association<reco::FFTGenJetCollection> >")
  .AddTypedef(type_5013, Reflex::Literal("edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > > >::value_type"))
  .AddTypedef(type_5013, Reflex::Literal("edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_23241, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2782), Reflex::Literal("Wrapper"), constructor_23242, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_23243, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39359), Reflex::Literal("Wrapper"), constructor_23248, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4745, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_edm__Association_std__vector_reco__FFTAnyJet_reco__GenJet_s_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_edm__Association_std__vector_reco__FFTAnyJet_reco__GenJet_s_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > > > > -------------------
void __edm__Wrapper_edm__Association_std__vector_reco__FFTAnyJet_reco__GenJet_s_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1566, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_edm__Association_std__vector_reco__FFTAnyJet_reco__GenJet_s_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_5013, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_edm__Association_std__vector_reco__FFTAnyJet_reco__GenJet_s_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > > > > -------------------
void __edm__Wrapper_edm__Association_std__vector_reco__FFTAnyJet_reco__GenJet_s_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39358), Reflex::Literal("product"), method_23244, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39358), Reflex::Literal("operator->"), operator_23245, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("productTypeInfo"), method_23246, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("typeInfo"), method_23247, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39360), Reflex::Literal("getInterface"), method_23249, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20599, type_20679, type_38738), Reflex::Literal("fillView"), method_23250, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20732, type_358, type_11036), Reflex::Literal("setPtr"), method_23251, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20732, type_26144, type_20679), Reflex::Literal("fillPtrVector"), method_23252, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("dynamicTypeInfo"), method_23253, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isPresent"), method_23254, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("dynamicTypeInfo_"), method_23255, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >, std::allocator<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > > > -------------------------------
static void constructor_23262( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > >();
  else ::new(mem) ::edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > >();
}

static void constructor_23263( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > >(*(::std::auto_ptr<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > >(*(::std::auto_ptr<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > >*)arg[0]);
}

static void destructor_23264(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > >*)o)->::edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > >::~Wrapper)();
}
static  void method_23265( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > >*)o)->product)();
}

static  void operator_23266( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > >*)o)->operator->)();
}

static  void method_23267( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > >*)o)->productTypeInfo)();
}

static  void method_23268( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > >*)o)->typeInfo)();
}

static void constructor_23269( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > >((::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > >((::std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > >*)arg[0]);
}

static  void method_23270( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > >*)o)->getInterface)();
}

static  void method_23271( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_23272( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_23273( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_23274( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > >*)o)->dynamicTypeInfo)();
}

static  void method_23275( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > >*)o)->isPresent)();
}

static  void method_23276( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4746( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >, std::allocator<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > > > -------------------------------
void __edm__Wrapper_std__vector_edm__FwdPtr_reco__FFTAnyJet_reco__GenJet_s_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_edm__FwdPtr_reco__FFTAnyJet_reco__GenJet_s_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_edm__FwdPtr_reco__FFTAnyJet_reco__GenJet_s_s_s__datamem_bld(&__edm__Wrapper_std__vector_edm__FwdPtr_reco__FFTAnyJet_reco__GenJet_s_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_edm__FwdPtr_reco__FFTAnyJet_reco__GenJet_s_s_s__funcmem_bld(&__edm__Wrapper_std__vector_edm__FwdPtr_reco__FFTAnyJet_reco__GenJet_s_s_s__db_funcmem);
void __edm__Wrapper_std__vector_edm__FwdPtr_reco__FFTAnyJet_reco__GenJet_s_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > >"), typeid(::edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > >), sizeof(::edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<reco::FFTGenJetFwdPtrVector>")
  .AddTypedef(type_2986, Reflex::Literal("edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > >::value_type"))
  .AddTypedef(type_2986, Reflex::Literal("edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_23262, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2783), Reflex::Literal("Wrapper"), constructor_23263, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_23264, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39364), Reflex::Literal("Wrapper"), constructor_23269, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4746, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_edm__FwdPtr_reco__FFTAnyJet_reco__GenJet_s_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_edm__FwdPtr_reco__FFTAnyJet_reco__GenJet_s_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >, std::allocator<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > > > -------------------
void __edm__Wrapper_std__vector_edm__FwdPtr_reco__FFTAnyJet_reco__GenJet_s_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1566, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_edm__FwdPtr_reco__FFTAnyJet_reco__GenJet_s_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2986, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_edm__FwdPtr_reco__FFTAnyJet_reco__GenJet_s_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> >, std::allocator<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > > > -------------------
void __edm__Wrapper_std__vector_edm__FwdPtr_reco__FFTAnyJet_reco__GenJet_s_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39363), Reflex::Literal("product"), method_23265, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39363), Reflex::Literal("operator->"), operator_23266, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("productTypeInfo"), method_23267, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("typeInfo"), method_23268, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39365), Reflex::Literal("getInterface"), method_23270, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20599, type_20679, type_38738), Reflex::Literal("fillView"), method_23271, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20732, type_358, type_11036), Reflex::Literal("setPtr"), method_23272, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20732, type_26144, type_20679), Reflex::Literal("fillPtrVector"), method_23273, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("dynamicTypeInfo"), method_23274, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isPresent"), method_23275, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("dynamicTypeInfo_"), method_23276, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >, reco::FFTAnyJet<reco::GenJet>, edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >, reco::FFTAnyJet<reco::GenJet> > >, std::allocator<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >, reco::FFTAnyJet<reco::GenJet>, edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >, reco::FFTAnyJet<reco::GenJet> > > > > > -------------------------------
static void constructor_23283( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >();
  else ::new(mem) ::edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >();
}

static void constructor_23284( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >(*(::std::auto_ptr<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >(*(::std::auto_ptr<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >*)arg[0]);
}

static void destructor_23285(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >*)o)->::edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >::~Wrapper)();
}
static  void method_23286( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >*)o)->product)();
}

static  void operator_23287( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >*)o)->operator->)();
}

static  void method_23288( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >*)o)->productTypeInfo)();
}

static  void method_23289( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >*)o)->typeInfo)();
}

static void constructor_23290( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >((::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >((::std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)arg[0]);
}

static  void method_23291( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >*)o)->getInterface)();
}

static  void method_23292( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_23293( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_23294( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_23295( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >*)o)->dynamicTypeInfo)();
}

static  void method_23296( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >*)o)->isPresent)();
}

static  void method_23297( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4747( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >, reco::FFTAnyJet<reco::GenJet>, edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >, reco::FFTAnyJet<reco::GenJet> > >, std::allocator<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >, reco::FFTAnyJet<reco::GenJet>, edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >, reco::FFTAnyJet<reco::GenJet> > > > > > -------------------------------
void __edm__Wrapper_std__vector_edm__FwdRef_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_edm__FwdRef_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_edm__FwdRef_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s_s__datamem_bld(&__edm__Wrapper_std__vector_edm__FwdRef_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_edm__FwdRef_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s_s__funcmem_bld(&__edm__Wrapper_std__vector_edm__FwdRef_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s_s__db_funcmem);
void __edm__Wrapper_std__vector_edm__FwdRef_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >"), typeid(::edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >), sizeof(::edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<reco::FFTGenJetFwdRefVector>")
  .AddTypedef(type_2987, Reflex::Literal("edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >::value_type"))
  .AddTypedef(type_2987, Reflex::Literal("edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_23283, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2784), Reflex::Literal("Wrapper"), constructor_23284, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_23285, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39369), Reflex::Literal("Wrapper"), constructor_23290, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4747, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_edm__FwdRef_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_edm__FwdRef_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >, reco::FFTAnyJet<reco::GenJet>, edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >, reco::FFTAnyJet<reco::GenJet> > >, std::allocator<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >, reco::FFTAnyJet<reco::GenJet>, edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >, reco::FFTAnyJet<reco::GenJet> > > > > > -------------------
void __edm__Wrapper_std__vector_edm__FwdRef_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1566, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_edm__FwdRef_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2987, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_edm__FwdRef_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >, reco::FFTAnyJet<reco::GenJet>, edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >, reco::FFTAnyJet<reco::GenJet> > >, std::allocator<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >, reco::FFTAnyJet<reco::GenJet>, edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >, reco::FFTAnyJet<reco::GenJet> > > > > > -------------------
void __edm__Wrapper_std__vector_edm__FwdRef_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39368), Reflex::Literal("product"), method_23286, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39368), Reflex::Literal("operator->"), operator_23287, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("productTypeInfo"), method_23288, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("typeInfo"), method_23289, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39370), Reflex::Literal("getInterface"), method_23291, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20599, type_20679, type_38738), Reflex::Literal("fillView"), method_23292, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20732, type_358, type_11036), Reflex::Literal("setPtr"), method_23293, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20732, type_26144, type_20679), Reflex::Literal("fillPtrVector"), method_23294, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("dynamicTypeInfo"), method_23295, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isPresent"), method_23296, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("dynamicTypeInfo_"), method_23297, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >, reco::FFTAnyJet<reco::GenJet>, edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >, reco::FFTAnyJet<reco::GenJet> > > > -------------------------------
static void constructor_23304( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >();
  else ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >();
}

static void constructor_23305( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >(*(::std::auto_ptr<edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >(*(::std::auto_ptr<edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)arg[0]);
}

static void destructor_23306(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->::edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >::~Wrapper)();
}
static  void method_23307( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->product)());
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->product)();
}

static  void operator_23308( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->operator->)();
}

static  void method_23309( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->productTypeInfo)();
}

static  void method_23310( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->typeInfo)();
}

static void constructor_23311( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >((::edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >((::edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)arg[0]);
}

static  void method_23312( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->getInterface)());
  else   (((::edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->getInterface)();
}

static  void method_23313( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_23314( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_23315( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_23316( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->dynamicTypeInfo)();
}

static  void method_23317( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->isPresent)();
}

static  void method_23318( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4748( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >, reco::FFTAnyJet<reco::GenJet>, edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >, reco::FFTAnyJet<reco::GenJet> > > > -------------------------------
void __edm__Wrapper_edm__RefVector_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_edm__RefVector_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__RefVector_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s__datamem_bld(&__edm__Wrapper_edm__RefVector_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__RefVector_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s__funcmem_bld(&__edm__Wrapper_edm__RefVector_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s__db_funcmem);
void __edm__Wrapper_edm__RefVector_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >"), typeid(::edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >), sizeof(::edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<reco::FFTGenJetRefVector>")
  .AddTypedef(type_4676, Reflex::Literal("edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >::value_type"))
  .AddTypedef(type_4676, Reflex::Literal("edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_23304, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2785), Reflex::Literal("Wrapper"), constructor_23305, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_23306, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39374), Reflex::Literal("Wrapper"), constructor_23311, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4748, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_edm__RefVector_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_edm__RefVector_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >, reco::FFTAnyJet<reco::GenJet>, edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >, reco::FFTAnyJet<reco::GenJet> > > > -------------------
void __edm__Wrapper_edm__RefVector_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1566, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_edm__RefVector_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_4676, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_edm__RefVector_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >, reco::FFTAnyJet<reco::GenJet>, edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >, reco::FFTAnyJet<reco::GenJet> > > > -------------------
void __edm__Wrapper_edm__RefVector_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39373), Reflex::Literal("product"), method_23307, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39373), Reflex::Literal("operator->"), operator_23308, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("productTypeInfo"), method_23309, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("typeInfo"), method_23310, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39375), Reflex::Literal("getInterface"), method_23312, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20599, type_20679, type_38738), Reflex::Literal("fillView"), method_23313, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20732, type_358, type_11036), Reflex::Literal("setPtr"), method_23314, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20732, type_26144, type_20679), Reflex::Literal("fillPtrVector"), method_23315, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("dynamicTypeInfo"), method_23316, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isPresent"), method_23317, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("dynamicTypeInfo_"), method_23318, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > > > -------------------------------
static void constructor_23325( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<reco::FFTAnyJet<reco::GenJet> > >();
  else ::new(mem) ::edm::Wrapper<std::vector<reco::FFTAnyJet<reco::GenJet> > >();
}

static void constructor_23326( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<reco::FFTAnyJet<reco::GenJet> > >(*(::std::auto_ptr<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<reco::FFTAnyJet<reco::GenJet> > >(*(::std::auto_ptr<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)arg[0]);
}

static void destructor_23327(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->::edm::Wrapper<std::vector<reco::FFTAnyJet<reco::GenJet> > >::~Wrapper)();
}
static  void method_23328( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->product)();
}

static  void operator_23329( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->operator->)();
}

static  void method_23330( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->productTypeInfo)();
}

static  void method_23331( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->typeInfo)();
}

static void constructor_23332( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<reco::FFTAnyJet<reco::GenJet> > >((::std::vector<reco::FFTAnyJet<reco::GenJet> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<reco::FFTAnyJet<reco::GenJet> > >((::std::vector<reco::FFTAnyJet<reco::GenJet> >*)arg[0]);
}

static  void method_23333( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->getInterface)();
}

static  void method_23334( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_23335( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_23336( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_23337( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->dynamicTypeInfo)();
}

static  void method_23338( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->isPresent)();
}

static  void method_23339( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4749( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::FFTAnyJet<reco::GenJet> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::FFTAnyJet<reco::GenJet> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::FFTAnyJet<reco::GenJet> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::FFTAnyJet<reco::GenJet> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::FFTAnyJet<reco::GenJet> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > > > -------------------------------
void __edm__Wrapper_std__vector_reco__FFTAnyJet_reco__GenJet_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_reco__FFTAnyJet_reco__GenJet_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_reco__FFTAnyJet_reco__GenJet_s_s__datamem_bld(&__edm__Wrapper_std__vector_reco__FFTAnyJet_reco__GenJet_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_reco__FFTAnyJet_reco__GenJet_s_s__funcmem_bld(&__edm__Wrapper_std__vector_reco__FFTAnyJet_reco__GenJet_s_s__db_funcmem);
void __edm__Wrapper_std__vector_reco__FFTAnyJet_reco__GenJet_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<reco::FFTAnyJet<reco::GenJet> > >"), typeid(::edm::Wrapper<std::vector<reco::FFTAnyJet<reco::GenJet> > >), sizeof(::edm::Wrapper<std::vector<reco::FFTAnyJet<reco::GenJet> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<reco::FFTGenJetCollection>")
  .AddTypedef(type_2988, Reflex::Literal("edm::Wrapper<std::vector<reco::FFTAnyJet<reco::GenJet> > >::value_type"))
  .AddTypedef(type_2988, Reflex::Literal("edm::Wrapper<std::vector<reco::FFTAnyJet<reco::GenJet> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_23325, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2786), Reflex::Literal("Wrapper"), constructor_23326, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_23327, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39378), Reflex::Literal("Wrapper"), constructor_23332, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4749, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_reco__FFTAnyJet_reco__GenJet_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_reco__FFTAnyJet_reco__GenJet_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > > > -------------------
void __edm__Wrapper_std__vector_reco__FFTAnyJet_reco__GenJet_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1566, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_reco__FFTAnyJet_reco__GenJet_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2988, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_reco__FFTAnyJet_reco__GenJet_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > > > -------------------
void __edm__Wrapper_std__vector_reco__FFTAnyJet_reco__GenJet_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39285), Reflex::Literal("product"), method_23328, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39285), Reflex::Literal("operator->"), operator_23329, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("productTypeInfo"), method_23330, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("typeInfo"), method_23331, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39379), Reflex::Literal("getInterface"), method_23333, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20599, type_20679, type_38738), Reflex::Literal("fillView"), method_23334, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20732, type_358, type_11036), Reflex::Literal("setPtr"), method_23335, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20732, type_26144, type_20679), Reflex::Literal("fillPtrVector"), method_23336, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("dynamicTypeInfo"), method_23337, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isPresent"), method_23338, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("dynamicTypeInfo_"), method_23339, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Association<std::vector<reco::PFJet, std::allocator<reco::PFJet> > > -------------------------------
static void destructor_25223(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Association<std::vector<reco::PFJet> >*)o)->::edm::Association<std::vector<reco::PFJet> >::~Association)();
}
static void constructor_25224( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Association<std::vector<reco::PFJet> >(*(const ::edm::Association<std::vector<reco::PFJet> >*)arg[0]);
  else ::new(mem) ::edm::Association<std::vector<reco::PFJet> >(*(const ::edm::Association<std::vector<reco::PFJet> >*)arg[0]);
}

static void constructor_25225( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Association<std::vector<reco::PFJet> >();
  else ::new(mem) ::edm::Association<std::vector<reco::PFJet> >();
}

static  void method_25226( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<reco::PFJet>,reco::PFJet,edm::refhelper::FindUsingAdvance<std::vector<reco::PFJet>,reco::PFJet> >)((((const ::edm::Association<std::vector<reco::PFJet> >*)o)->get)(*(::size_t*)arg[0]));
  else   (((const ::edm::Association<std::vector<reco::PFJet> >*)o)->get)(*(::size_t*)arg[0]);
}

static  void method_25227( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<reco::PFJet>,reco::PFJet,edm::refhelper::FindUsingAdvance<std::vector<reco::PFJet>,reco::PFJet> >)((((const ::edm::Association<std::vector<reco::PFJet> >*)o)->get)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]));
  else   (((const ::edm::Association<std::vector<reco::PFJet> >*)o)->get)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]);
}

static  void operator_25228( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Association<std::vector<reco::PFJet> >*)o)->operator+=)(*(const ::edm::Association<std::vector<reco::PFJet> >*)arg[0]);
  else   (((::edm::Association<std::vector<reco::PFJet> >*)o)->operator+=)(*(const ::edm::Association<std::vector<reco::PFJet> >*)arg[0]);
}

static  void method_25229( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::Association<std::vector<reco::PFJet> >*)o)->setRef)(*(const ::edm::RefProd<std::vector<reco::PFJet> >*)arg[0]);
}

static  void method_25230( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Association<std::vector<reco::PFJet> >*)o)->contains)(*(::edm::ProductID*)arg[0]));
  else   (((const ::edm::Association<std::vector<reco::PFJet> >*)o)->contains)(*(::edm::ProductID*)arg[0]);
}

static  void method_25231( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::Association<std::vector<reco::PFJet> >*)o)->size)());
  else   (((const ::edm::Association<std::vector<reco::PFJet> >*)o)->size)();
}

static  void method_25232( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Association<std::vector<reco::PFJet> >*)o)->empty)());
  else   (((const ::edm::Association<std::vector<reco::PFJet> >*)o)->empty)();
}

static  void method_25233( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::Association<std::vector<reco::PFJet> >*)o)->clear)();
}

static  void method_25234( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefProd<std::vector<reco::PFJet> >)((((const ::edm::Association<std::vector<reco::PFJet> >*)o)->ref)());
  else   (((const ::edm::Association<std::vector<reco::PFJet> >*)o)->ref)();
}

static  void method_25235( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::Association<std::vector<reco::PFJet> >*)o)->swap)(*(::edm::Association<std::vector<reco::PFJet> >*)arg[0]);
}

static  void operator_25236( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Association<std::vector<reco::PFJet> >*)o)->operator=)(*(const ::edm::Association<std::vector<reco::PFJet> >*)arg[0]);
  else   (((::edm::Association<std::vector<reco::PFJet> >*)o)->operator=)(*(const ::edm::Association<std::vector<reco::PFJet> >*)arg[0]);
}

static  void method_25237( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Association<std::vector<reco::PFJet> >*)o)->ids)();
  else   (((const ::edm::Association<std::vector<reco::PFJet> >*)o)->ids)();
}

static  void method_25238( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::Association<std::vector<reco::PFJet> >*)o)->Class_Version)());
  else   (((::edm::Association<std::vector<reco::PFJet> >*)o)->Class_Version)();
}

static void method_newdel_5014( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Association<std::vector<reco::PFJet> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Association<std::vector<reco::PFJet> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Association<std::vector<reco::PFJet> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Association<std::vector<reco::PFJet> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Association<std::vector<reco::PFJet> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x152( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::ValueMap<int>")), ::Reflex::BaseOffset< ::edm::Association<std::vector<reco::PFJet> >,::edm::ValueMap<int> >::Get(),::Reflex::PRIVATE), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Association<std::vector<reco::PFJet, std::allocator<reco::PFJet> > > -------------------------------
void __edm__Association_std__vector_reco__PFJet_s__db_datamem(Reflex::Class*);
void __edm__Association_std__vector_reco__PFJet_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Association_std__vector_reco__PFJet_s__datamem_bld(&__edm__Association_std__vector_reco__PFJet_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Association_std__vector_reco__PFJet_s__funcmem_bld(&__edm__Association_std__vector_reco__PFJet_s__db_funcmem);
void __edm__Association_std__vector_reco__PFJet_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Association<std::vector<reco::PFJet> >"), typeid(::edm::Association<std::vector<reco::PFJet> >), sizeof(::edm::Association<std::vector<reco::PFJet> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::Association<std::vector<reco::PFJet> >::Class_Version())
  .AddProperty(Reflex::Literal("o_name"), "edm::Association<reco::PFJetCollection>")
  .AddBase(type_5079, ::Reflex::BaseOffset< ::edm::Association<std::vector<reco::PFJet> >, ::edm::ValueMap<int> >::Get(), ::Reflex::PRIVATE)
  .AddTypedef(type_68, Reflex::Literal("edm::Association<std::vector<reco::PFJet> >::index"))
  .AddTypedef(type_5079, Reflex::Literal("edm::Association<std::vector<reco::PFJet> >::base"))
  .AddTypedef(type_366, Reflex::Literal("edm::Association<std::vector<reco::PFJet> >::offset"))
  .AddTypedef(type_4957, Reflex::Literal("edm::Association<std::vector<reco::PFJet> >::refprod_type"))
  .AddTypedef(type_5023, Reflex::Literal("edm::Association<std::vector<reco::PFJet> >::reference_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Association"), destructor_25223, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39922), Reflex::Literal("Association"), constructor_25224, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Association"), constructor_25225, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_5014, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x152, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Association_std__vector_reco__PFJet_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Association_std__vector_reco__PFJet_s__funcmem_bld);
}

//------Delayed data member builder for class Association<std::vector<reco::PFJet, std::allocator<reco::PFJet> > > -------------------
void __edm__Association_std__vector_reco__PFJet_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4957, Reflex::Literal("ref_"), OffsetOf(__shadow__::__edm__Association_std__vector_reco__PFJet_s_, ref_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Association<std::vector<reco::PFJet, std::allocator<reco::PFJet> > > -------------------
void __edm__Association_std__vector_reco__PFJet_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5023, type_2121), Reflex::Literal("get"), method_25226, 0, "rawIdx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5023, type_4933, type_2121), Reflex::Literal("get"), method_25227, 0, "id;idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39923, type_39922), Reflex::Literal("operator+="), operator_25228, 0, "o", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_39851), Reflex::Literal("setRef"), method_25229, 0, "ref", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566, type_4933), Reflex::Literal("contains"), method_25230, 0, "id", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2121), Reflex::Literal("size"), method_25231, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("empty"), method_25232, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694), Reflex::Literal("clear"), method_25233, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4957), Reflex::Literal("ref"), method_25234, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_39923), Reflex::Literal("swap"), method_25235, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39923, type_39922), Reflex::Literal("operator="), operator_25236, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35947), Reflex::Literal("ids"), method_25237, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_237), Reflex::Literal("Class_Version"), method_25238, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Wrapper<edm::Association<std::vector<reco::PFJet, std::allocator<reco::PFJet> > > > -------------------------------
static void constructor_23514( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::Association<std::vector<reco::PFJet> > >();
  else ::new(mem) ::edm::Wrapper<edm::Association<std::vector<reco::PFJet> > >();
}

static void constructor_23515( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::Association<std::vector<reco::PFJet> > >(*(::std::auto_ptr<edm::Association<std::vector<reco::PFJet> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::Association<std::vector<reco::PFJet> > >(*(::std::auto_ptr<edm::Association<std::vector<reco::PFJet> > >*)arg[0]);
}

static void destructor_23516(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<edm::Association<std::vector<reco::PFJet> > >*)o)->::edm::Wrapper<edm::Association<std::vector<reco::PFJet> > >::~Wrapper)();
}
static  void method_23517( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::Association<std::vector<reco::PFJet> > >*)o)->product)());
  else   (((const ::edm::Wrapper<edm::Association<std::vector<reco::PFJet> > >*)o)->product)();
}

static  void operator_23518( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::Association<std::vector<reco::PFJet> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<edm::Association<std::vector<reco::PFJet> > >*)o)->operator->)();
}

static  void method_23519( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::Association<std::vector<reco::PFJet> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<edm::Association<std::vector<reco::PFJet> > >*)o)->productTypeInfo)();
}

static  void method_23520( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::Association<std::vector<reco::PFJet> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<edm::Association<std::vector<reco::PFJet> > >*)o)->typeInfo)();
}

static void constructor_23521( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::Association<std::vector<reco::PFJet> > >((::edm::Association<std::vector<reco::PFJet> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::Association<std::vector<reco::PFJet> > >((::edm::Association<std::vector<reco::PFJet> >*)arg[0]);
}

static  void method_23522( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<edm::Association<std::vector<reco::PFJet> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<edm::Association<std::vector<reco::PFJet> > >*)o)->getInterface)();
}

static  void method_23523( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::Association<std::vector<reco::PFJet> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_23524( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::Association<std::vector<reco::PFJet> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_23525( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::Association<std::vector<reco::PFJet> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_23526( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::Association<std::vector<reco::PFJet> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<edm::Association<std::vector<reco::PFJet> > >*)o)->dynamicTypeInfo)();
}

static  void method_23527( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<edm::Association<std::vector<reco::PFJet> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<edm::Association<std::vector<reco::PFJet> > >*)o)->isPresent)();
}

static  void method_23528( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::Association<std::vector<reco::PFJet> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<edm::Association<std::vector<reco::PFJet> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4758( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::Association<std::vector<reco::PFJet> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::Association<std::vector<reco::PFJet> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::Association<std::vector<reco::PFJet> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::Association<std::vector<reco::PFJet> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::Association<std::vector<reco::PFJet> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<edm::Association<std::vector<reco::PFJet, std::allocator<reco::PFJet> > > > -------------------------------
void __edm__Wrapper_edm__Association_std__vector_reco__PFJet_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_edm__Association_std__vector_reco__PFJet_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__Association_std__vector_reco__PFJet_s_s__datamem_bld(&__edm__Wrapper_edm__Association_std__vector_reco__PFJet_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__Association_std__vector_reco__PFJet_s_s__funcmem_bld(&__edm__Wrapper_edm__Association_std__vector_reco__PFJet_s_s__db_funcmem);
void __edm__Wrapper_edm__Association_std__vector_reco__PFJet_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<edm::Association<std::vector<reco::PFJet> > >"), typeid(::edm::Wrapper<edm::Association<std::vector<reco::PFJet> > >), sizeof(::edm::Wrapper<edm::Association<std::vector<reco::PFJet> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<edm::Association<reco::PFJetCollection> >")
  .AddTypedef(type_5014, Reflex::Literal("edm::Wrapper<edm::Association<std::vector<reco::PFJet> > >::value_type"))
  .AddTypedef(type_5014, Reflex::Literal("edm::Wrapper<edm::Association<std::vector<reco::PFJet> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_23514, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2795), Reflex::Literal("Wrapper"), constructor_23515, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_23516, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39420), Reflex::Literal("Wrapper"), constructor_23521, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4758, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_edm__Association_std__vector_reco__PFJet_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_edm__Association_std__vector_reco__PFJet_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<edm::Association<std::vector<reco::PFJet, std::allocator<reco::PFJet> > > > -------------------
void __edm__Wrapper_edm__Association_std__vector_reco__PFJet_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1566, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_edm__Association_std__vector_reco__PFJet_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_5014, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_edm__Association_std__vector_reco__PFJet_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<edm::Association<std::vector<reco::PFJet, std::allocator<reco::PFJet> > > > -------------------
void __edm__Wrapper_edm__Association_std__vector_reco__PFJet_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39419), Reflex::Literal("product"), method_23517, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39419), Reflex::Literal("operator->"), operator_23518, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("productTypeInfo"), method_23519, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("typeInfo"), method_23520, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39421), Reflex::Literal("getInterface"), method_23522, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20599, type_20679, type_38738), Reflex::Literal("fillView"), method_23523, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20732, type_358, type_11036), Reflex::Literal("setPtr"), method_23524, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20732, type_26144, type_20679), Reflex::Literal("fillPtrVector"), method_23525, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("dynamicTypeInfo"), method_23526, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isPresent"), method_23527, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("dynamicTypeInfo_"), method_23528, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Association<std::vector<reco::GenJet, std::allocator<reco::GenJet> > > -------------------------------
static void destructor_25249(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Association<std::vector<reco::GenJet> >*)o)->::edm::Association<std::vector<reco::GenJet> >::~Association)();
}
static void constructor_25250( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Association<std::vector<reco::GenJet> >(*(const ::edm::Association<std::vector<reco::GenJet> >*)arg[0]);
  else ::new(mem) ::edm::Association<std::vector<reco::GenJet> >(*(const ::edm::Association<std::vector<reco::GenJet> >*)arg[0]);
}

static void constructor_25251( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Association<std::vector<reco::GenJet> >();
  else ::new(mem) ::edm::Association<std::vector<reco::GenJet> >();
}

static  void method_25252( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<reco::GenJet>,reco::GenJet,edm::refhelper::FindUsingAdvance<std::vector<reco::GenJet>,reco::GenJet> >)((((const ::edm::Association<std::vector<reco::GenJet> >*)o)->get)(*(::size_t*)arg[0]));
  else   (((const ::edm::Association<std::vector<reco::GenJet> >*)o)->get)(*(::size_t*)arg[0]);
}

static  void method_25253( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<reco::GenJet>,reco::GenJet,edm::refhelper::FindUsingAdvance<std::vector<reco::GenJet>,reco::GenJet> >)((((const ::edm::Association<std::vector<reco::GenJet> >*)o)->get)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]));
  else   (((const ::edm::Association<std::vector<reco::GenJet> >*)o)->get)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]);
}

static  void operator_25254( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Association<std::vector<reco::GenJet> >*)o)->operator+=)(*(const ::edm::Association<std::vector<reco::GenJet> >*)arg[0]);
  else   (((::edm::Association<std::vector<reco::GenJet> >*)o)->operator+=)(*(const ::edm::Association<std::vector<reco::GenJet> >*)arg[0]);
}

static  void method_25255( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::Association<std::vector<reco::GenJet> >*)o)->setRef)(*(const ::edm::RefProd<std::vector<reco::GenJet> >*)arg[0]);
}

static  void method_25256( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Association<std::vector<reco::GenJet> >*)o)->contains)(*(::edm::ProductID*)arg[0]));
  else   (((const ::edm::Association<std::vector<reco::GenJet> >*)o)->contains)(*(::edm::ProductID*)arg[0]);
}

static  void method_25257( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::Association<std::vector<reco::GenJet> >*)o)->size)());
  else   (((const ::edm::Association<std::vector<reco::GenJet> >*)o)->size)();
}

static  void method_25258( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Association<std::vector<reco::GenJet> >*)o)->empty)());
  else   (((const ::edm::Association<std::vector<reco::GenJet> >*)o)->empty)();
}

static  void method_25259( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::Association<std::vector<reco::GenJet> >*)o)->clear)();
}

static  void method_25260( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefProd<std::vector<reco::GenJet> >)((((const ::edm::Association<std::vector<reco::GenJet> >*)o)->ref)());
  else   (((const ::edm::Association<std::vector<reco::GenJet> >*)o)->ref)();
}

static  void method_25261( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::Association<std::vector<reco::GenJet> >*)o)->swap)(*(::edm::Association<std::vector<reco::GenJet> >*)arg[0]);
}

static  void operator_25262( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Association<std::vector<reco::GenJet> >*)o)->operator=)(*(const ::edm::Association<std::vector<reco::GenJet> >*)arg[0]);
  else   (((::edm::Association<std::vector<reco::GenJet> >*)o)->operator=)(*(const ::edm::Association<std::vector<reco::GenJet> >*)arg[0]);
}

static  void method_25263( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Association<std::vector<reco::GenJet> >*)o)->ids)();
  else   (((const ::edm::Association<std::vector<reco::GenJet> >*)o)->ids)();
}

static  void method_25264( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::Association<std::vector<reco::GenJet> >*)o)->Class_Version)());
  else   (((::edm::Association<std::vector<reco::GenJet> >*)o)->Class_Version)();
}

static void method_newdel_5015( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Association<std::vector<reco::GenJet> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Association<std::vector<reco::GenJet> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Association<std::vector<reco::GenJet> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Association<std::vector<reco::GenJet> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Association<std::vector<reco::GenJet> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x155( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::ValueMap<int>")), ::Reflex::BaseOffset< ::edm::Association<std::vector<reco::GenJet> >,::edm::ValueMap<int> >::Get(),::Reflex::PRIVATE), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Association<std::vector<reco::GenJet, std::allocator<reco::GenJet> > > -------------------------------
void __edm__Association_std__vector_reco__GenJet_s__db_datamem(Reflex::Class*);
void __edm__Association_std__vector_reco__GenJet_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Association_std__vector_reco__GenJet_s__datamem_bld(&__edm__Association_std__vector_reco__GenJet_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Association_std__vector_reco__GenJet_s__funcmem_bld(&__edm__Association_std__vector_reco__GenJet_s__db_funcmem);
void __edm__Association_std__vector_reco__GenJet_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Association<std::vector<reco::GenJet> >"), typeid(::edm::Association<std::vector<reco::GenJet> >), sizeof(::edm::Association<std::vector<reco::GenJet> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::Association<std::vector<reco::GenJet> >::Class_Version())
  .AddProperty(Reflex::Literal("o_name"), "edm::Association<reco::GenJetCollection>")
  .AddBase(type_5079, ::Reflex::BaseOffset< ::edm::Association<std::vector<reco::GenJet> >, ::edm::ValueMap<int> >::Get(), ::Reflex::PRIVATE)
  .AddTypedef(type_68, Reflex::Literal("edm::Association<std::vector<reco::GenJet> >::index"))
  .AddTypedef(type_5079, Reflex::Literal("edm::Association<std::vector<reco::GenJet> >::base"))
  .AddTypedef(type_366, Reflex::Literal("edm::Association<std::vector<reco::GenJet> >::offset"))
  .AddTypedef(type_4958, Reflex::Literal("edm::Association<std::vector<reco::GenJet> >::refprod_type"))
  .AddTypedef(type_5024, Reflex::Literal("edm::Association<std::vector<reco::GenJet> >::reference_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Association"), destructor_25249, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39924), Reflex::Literal("Association"), constructor_25250, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Association"), constructor_25251, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_5015, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x155, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Association_std__vector_reco__GenJet_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Association_std__vector_reco__GenJet_s__funcmem_bld);
}

//------Delayed data member builder for class Association<std::vector<reco::GenJet, std::allocator<reco::GenJet> > > -------------------
void __edm__Association_std__vector_reco__GenJet_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4958, Reflex::Literal("ref_"), OffsetOf(__shadow__::__edm__Association_std__vector_reco__GenJet_s_, ref_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Association<std::vector<reco::GenJet, std::allocator<reco::GenJet> > > -------------------
void __edm__Association_std__vector_reco__GenJet_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5024, type_2121), Reflex::Literal("get"), method_25252, 0, "rawIdx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5024, type_4933, type_2121), Reflex::Literal("get"), method_25253, 0, "id;idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39925, type_39924), Reflex::Literal("operator+="), operator_25254, 0, "o", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_39857), Reflex::Literal("setRef"), method_25255, 0, "ref", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566, type_4933), Reflex::Literal("contains"), method_25256, 0, "id", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2121), Reflex::Literal("size"), method_25257, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("empty"), method_25258, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694), Reflex::Literal("clear"), method_25259, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4958), Reflex::Literal("ref"), method_25260, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_39925), Reflex::Literal("swap"), method_25261, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39925, type_39924), Reflex::Literal("operator="), operator_25262, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35947), Reflex::Literal("ids"), method_25263, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_237), Reflex::Literal("Class_Version"), method_25264, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Wrapper<edm::Association<std::vector<reco::GenJet, std::allocator<reco::GenJet> > > > -------------------------------
static void constructor_23535( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::Association<std::vector<reco::GenJet> > >();
  else ::new(mem) ::edm::Wrapper<edm::Association<std::vector<reco::GenJet> > >();
}

static void constructor_23536( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::Association<std::vector<reco::GenJet> > >(*(::std::auto_ptr<edm::Association<std::vector<reco::GenJet> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::Association<std::vector<reco::GenJet> > >(*(::std::auto_ptr<edm::Association<std::vector<reco::GenJet> > >*)arg[0]);
}

static void destructor_23537(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<edm::Association<std::vector<reco::GenJet> > >*)o)->::edm::Wrapper<edm::Association<std::vector<reco::GenJet> > >::~Wrapper)();
}
static  void method_23538( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::Association<std::vector<reco::GenJet> > >*)o)->product)());
  else   (((const ::edm::Wrapper<edm::Association<std::vector<reco::GenJet> > >*)o)->product)();
}

static  void operator_23539( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::Association<std::vector<reco::GenJet> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<edm::Association<std::vector<reco::GenJet> > >*)o)->operator->)();
}

static  void method_23540( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::Association<std::vector<reco::GenJet> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<edm::Association<std::vector<reco::GenJet> > >*)o)->productTypeInfo)();
}

static  void method_23541( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::Association<std::vector<reco::GenJet> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<edm::Association<std::vector<reco::GenJet> > >*)o)->typeInfo)();
}

static void constructor_23542( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::Association<std::vector<reco::GenJet> > >((::edm::Association<std::vector<reco::GenJet> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::Association<std::vector<reco::GenJet> > >((::edm::Association<std::vector<reco::GenJet> >*)arg[0]);
}

static  void method_23543( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<edm::Association<std::vector<reco::GenJet> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<edm::Association<std::vector<reco::GenJet> > >*)o)->getInterface)();
}

static  void method_23544( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::Association<std::vector<reco::GenJet> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_23545( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::Association<std::vector<reco::GenJet> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_23546( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::Association<std::vector<reco::GenJet> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_23547( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::Association<std::vector<reco::GenJet> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<edm::Association<std::vector<reco::GenJet> > >*)o)->dynamicTypeInfo)();
}

static  void method_23548( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<edm::Association<std::vector<reco::GenJet> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<edm::Association<std::vector<reco::GenJet> > >*)o)->isPresent)();
}

static  void method_23549( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::Association<std::vector<reco::GenJet> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<edm::Association<std::vector<reco::GenJet> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4759( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::Association<std::vector<reco::GenJet> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::Association<std::vector<reco::GenJet> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::Association<std::vector<reco::GenJet> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::Association<std::vector<reco::GenJet> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::Association<std::vector<reco::GenJet> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<edm::Association<std::vector<reco::GenJet, std::allocator<reco::GenJet> > > > -------------------------------
void __edm__Wrapper_edm__Association_std__vector_reco__GenJet_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_edm__Association_std__vector_reco__GenJet_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__Association_std__vector_reco__GenJet_s_s__datamem_bld(&__edm__Wrapper_edm__Association_std__vector_reco__GenJet_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__Association_std__vector_reco__GenJet_s_s__funcmem_bld(&__edm__Wrapper_edm__Association_std__vector_reco__GenJet_s_s__db_funcmem);
void __edm__Wrapper_edm__Association_std__vector_reco__GenJet_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<edm::Association<std::vector<reco::GenJet> > >"), typeid(::edm::Wrapper<edm::Association<std::vector<reco::GenJet> > >), sizeof(::edm::Wrapper<edm::Association<std::vector<reco::GenJet> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<edm::Association<reco::GenJetCollection> >")
  .AddTypedef(type_5015, Reflex::Literal("edm::Wrapper<edm::Association<std::vector<reco::GenJet> > >::value_type"))
  .AddTypedef(type_5015, Reflex::Literal("edm::Wrapper<edm::Association<std::vector<reco::GenJet> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_23535, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2796), Reflex::Literal("Wrapper"), constructor_23536, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_23537, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39425), Reflex::Literal("Wrapper"), constructor_23542, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4759, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_edm__Association_std__vector_reco__GenJet_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_edm__Association_std__vector_reco__GenJet_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<edm::Association<std::vector<reco::GenJet, std::allocator<reco::GenJet> > > > -------------------
void __edm__Wrapper_edm__Association_std__vector_reco__GenJet_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1566, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_edm__Association_std__vector_reco__GenJet_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_5015, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_edm__Association_std__vector_reco__GenJet_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<edm::Association<std::vector<reco::GenJet, std::allocator<reco::GenJet> > > > -------------------
void __edm__Wrapper_edm__Association_std__vector_reco__GenJet_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39424), Reflex::Literal("product"), method_23538, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39424), Reflex::Literal("operator->"), operator_23539, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("productTypeInfo"), method_23540, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("typeInfo"), method_23541, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39426), Reflex::Literal("getInterface"), method_23543, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20599, type_20679, type_38738), Reflex::Literal("fillView"), method_23544, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20732, type_358, type_11036), Reflex::Literal("setPtr"), method_23545, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_20732, type_26144, type_20679), Reflex::Literal("fillPtrVector"), method_23546, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("dynamicTypeInfo"), method_23547, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isPresent"), method_23548, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20732), Reflex::Literal("dynamicTypeInfo_"), method_23549, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Ptr<reco::FFTAnyJet<reco::CaloJet> > -------------------------------
static  void operator_24715( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Ptr<reco::FFTAnyJet<reco::CaloJet> >*)o)->operator=)(*(const ::edm::Ptr<reco::FFTAnyJet<reco::CaloJet> >*)arg[0]);
  else   (((::edm::Ptr<reco::FFTAnyJet<reco::CaloJet> >*)o)->operator=)(*(const ::edm::Ptr<reco::FFTAnyJet<reco::CaloJet> >*)arg[0]);
}

static void constructor_24716( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<reco::FFTAnyJet<reco::CaloJet> >(*(const ::edm::Ptr<reco::FFTAnyJet<reco::CaloJet> >*)arg[0]);
  else ::new(mem) ::edm::Ptr<reco::FFTAnyJet<reco::CaloJet> >(*(const ::edm::Ptr<reco::FFTAnyJet<reco::CaloJet> >*)arg[0]);
}

static void constructor_24717( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<reco::FFTAnyJet<reco::CaloJet> >(*(const ::edm::ProductID*)arg[0],
      *(unsigned long*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
  else ::new(mem) ::edm::Ptr<reco::FFTAnyJet<reco::CaloJet> >(*(const ::edm::ProductID*)arg[0],
      *(unsigned long*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
}

static void constructor_24718( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<reco::FFTAnyJet<reco::CaloJet> >(*(const ::edm::ProductID*)arg[0],
      (const ::reco::FFTAnyJet<reco::CaloJet>*)arg[1],
      *(unsigned long*)arg[2]);
  else ::new(mem) ::edm::Ptr<reco::FFTAnyJet<reco::CaloJet> >(*(const ::edm::ProductID*)arg[0],
      (const ::reco::FFTAnyJet<reco::CaloJet>*)arg[1],
      *(unsigned long*)arg[2]);
}

static void constructor_24719( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<reco::FFTAnyJet<reco::CaloJet> >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::Ptr<reco::FFTAnyJet<reco::CaloJet> >(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_24720( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<reco::FFTAnyJet<reco::CaloJet> >();
  else ::new(mem) ::edm::Ptr<reco::FFTAnyJet<reco::CaloJet> >();
}

static void destructor_24721(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Ptr<reco::FFTAnyJet<reco::CaloJet> >*)o)->::edm::Ptr<reco::FFTAnyJet<reco::CaloJet> >::~Ptr)();
}
static  void operator_24722( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ptr<reco::FFTAnyJet<reco::CaloJet> >*)o)->operator*)();
  else   (((const ::edm::Ptr<reco::FFTAnyJet<reco::CaloJet> >*)o)->operator*)();
}

static  void operator_24723( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<reco::FFTAnyJet<reco::CaloJet> >*)o)->operator->)());
  else   (((const ::edm::Ptr<reco::FFTAnyJet<reco::CaloJet> >*)o)->operator->)();
}

static  void method_24724( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<reco::FFTAnyJet<reco::CaloJet> >*)o)->get)());
  else   (((const ::edm::Ptr<reco::FFTAnyJet<reco::CaloJet> >*)o)->get)();
}

static  void method_24725( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::FFTAnyJet<reco::CaloJet> >*)o)->isNull)());
  else   (((const ::edm::Ptr<reco::FFTAnyJet<reco::CaloJet> >*)o)->isNull)();
}

static  void method_24726( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::FFTAnyJet<reco::CaloJet> >*)o)->isNonnull)());
  else   (((const ::edm::Ptr<reco::FFTAnyJet<reco::CaloJet> >*)o)->isNonnull)();
}

static  void operator_24727( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::FFTAnyJet<reco::CaloJet> >*)o)->operator!)());
  else   (((const ::edm::Ptr<reco::FFTAnyJet<reco::CaloJet> >*)o)->operator!)();
}

static  void method_24728( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::FFTAnyJet<reco::CaloJet> >*)o)->isAvailable)());
  else   (((const ::edm::Ptr<reco::FFTAnyJet<reco::CaloJet> >*)o)->isAvailable)();
}

static  void method_24729( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::FFTAnyJet<reco::CaloJet> >*)o)->isTransient)());
  else   (((const ::edm::Ptr<reco::FFTAnyJet<reco::CaloJet> >*)o)->isTransient)();
}

static  void method_24730( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::Ptr<reco::FFTAnyJet<reco::CaloJet> >*)o)->id)());
  else   (((const ::edm::Ptr<reco::FFTAnyJet<reco::CaloJet> >*)o)->id)();
}

static  void method_24731( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<reco::FFTAnyJet<reco::CaloJet> >*)o)->productGetter)());
  else   (((const ::edm::Ptr<reco::FFTAnyJet<reco::CaloJet> >*)o)->productGetter)();
}

static  void method_24732( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long)((((const ::edm::Ptr<reco::FFTAnyJet<reco::CaloJet> >*)o)->key)());
  else   (((const ::edm::Ptr<reco::FFTAnyJet<reco::CaloJet> >*)o)->key)();
}

static  void method_24733( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::FFTAnyJet<reco::CaloJet> >*)o)->hasProductCache)());
  else   (((const ::edm::Ptr<reco::FFTAnyJet<reco::CaloJet> >*)o)->hasProductCache)();
}

static  void method_24734( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ptr<reco::FFTAnyJet<reco::CaloJet> >*)o)->refCore)();
  else   (((const ::edm::Ptr<reco::FFTAnyJet<reco::CaloJet> >*)o)->refCore)();
}

static  void method_24735( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<reco::FFTAnyJet<reco::CaloJet> >*)o)->product)());
  else   (((const ::edm::Ptr<reco::FFTAnyJet<reco::CaloJet> >*)o)->product)();
}

static  void method_24736( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::Ptr<reco::FFTAnyJet<reco::CaloJet> >*)o)->Class_Version)());
  else   (((::edm::Ptr<reco::FFTAnyJet<reco::CaloJet> >*)o)->Class_Version)();
}

static void method_newdel_4986( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Ptr<reco::FFTAnyJet<reco::CaloJet> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Ptr<reco::FFTAnyJet<reco::CaloJet> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Ptr<reco::FFTAnyJet<reco::CaloJet> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Ptr<reco::FFTAnyJet<reco::CaloJet> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Ptr<reco::FFTAnyJet<reco::CaloJet> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Ptr<reco::FFTAnyJet<reco::CaloJet> > -------------------------------
void __edm__Ptr_reco__FFTAnyJet_reco__CaloJet_s__db_datamem(Reflex::Class*);
void __edm__Ptr_reco__FFTAnyJet_reco__CaloJet_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Ptr_reco__FFTAnyJet_reco__CaloJet_s__datamem_bld(&__edm__Ptr_reco__FFTAnyJet_reco__CaloJet_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Ptr_reco__FFTAnyJet_reco__CaloJet_s__funcmem_bld(&__edm__Ptr_reco__FFTAnyJet_reco__CaloJet_s__db_funcmem);
void __edm__Ptr_reco__FFTAnyJet_reco__CaloJet_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Ptr<reco::FFTAnyJet<reco::CaloJet> >"), typeid(::edm::Ptr<reco::FFTAnyJet<reco::CaloJet> >), sizeof(::edm::Ptr<reco::FFTAnyJet<reco::CaloJet> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::Ptr<reco::FFTAnyJet<reco::CaloJet> >::Class_Version())
  .AddProperty(Reflex::Literal("o_name"), "edm::Ptr<reco::FFTCaloJet>")
  .AddTypedef(type_358, Reflex::Literal("edm::Ptr<reco::FFTAnyJet<reco::CaloJet> >::key_type"))
  .AddTypedef(type_7851, Reflex::Literal("edm::Ptr<reco::FFTAnyJet<reco::CaloJet> >::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39898, type_39229), Reflex::Literal("operator="), operator_24715, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39229), Reflex::Literal("Ptr"), constructor_24716, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20599, type_358, type_20675), Reflex::Literal("Ptr"), constructor_24717, 0, "productID;itemKey;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20599, type_13627, type_358), Reflex::Literal("Ptr"), constructor_24718, 0, "productID;item;item_key", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20599), Reflex::Literal("Ptr"), constructor_24719, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Ptr"), constructor_24720, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Ptr"), destructor_24721, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4986, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Ptr_reco__FFTAnyJet_reco__CaloJet_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Ptr_reco__FFTAnyJet_reco__CaloJet_s__funcmem_bld);
}

//------Delayed data member builder for class Ptr<reco::FFTAnyJet<reco::CaloJet> > -------------------
void __edm__Ptr_reco__FFTAnyJet_reco__CaloJet_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4935, Reflex::Literal("core_"), OffsetOf(__shadow__::__edm__Ptr_reco__FFTAnyJet_reco__CaloJet_s_, core_), ::Reflex::PRIVATE)
  .AddDataMember(type_358, Reflex::Literal("key_"), OffsetOf(__shadow__::__edm__Ptr_reco__FFTAnyJet_reco__CaloJet_s_, key_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Ptr<reco::FFTAnyJet<reco::CaloJet> > -------------------
void __edm__Ptr_reco__FFTAnyJet_reco__CaloJet_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13631), Reflex::Literal("operator*"), operator_24722, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13627), Reflex::Literal("operator->"), operator_24723, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13627), Reflex::Literal("get"), method_24724, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isNull"), method_24725, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isNonnull"), method_24726, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("operator!"), operator_24727, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isAvailable"), method_24728, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isTransient"), method_24729, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4933), Reflex::Literal("id"), method_24730, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20675), Reflex::Literal("productGetter"), method_24731, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_358), Reflex::Literal("key"), method_24732, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("hasProductCache"), method_24733, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23940), Reflex::Literal("refCore"), method_24734, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4071), Reflex::Literal("product"), method_24735, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_237), Reflex::Literal("Class_Version"), method_24736, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Ptr<reco::FFTAnyJet<reco::GenJet> > -------------------------------
static  void operator_24743( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Ptr<reco::FFTAnyJet<reco::GenJet> >*)o)->operator=)(*(const ::edm::Ptr<reco::FFTAnyJet<reco::GenJet> >*)arg[0]);
  else   (((::edm::Ptr<reco::FFTAnyJet<reco::GenJet> >*)o)->operator=)(*(const ::edm::Ptr<reco::FFTAnyJet<reco::GenJet> >*)arg[0]);
}

static void constructor_24744( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<reco::FFTAnyJet<reco::GenJet> >(*(const ::edm::Ptr<reco::FFTAnyJet<reco::GenJet> >*)arg[0]);
  else ::new(mem) ::edm::Ptr<reco::FFTAnyJet<reco::GenJet> >(*(const ::edm::Ptr<reco::FFTAnyJet<reco::GenJet> >*)arg[0]);
}

static void constructor_24745( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<reco::FFTAnyJet<reco::GenJet> >(*(const ::edm::ProductID*)arg[0],
      *(unsigned long*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
  else ::new(mem) ::edm::Ptr<reco::FFTAnyJet<reco::GenJet> >(*(const ::edm::ProductID*)arg[0],
      *(unsigned long*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
}

static void constructor_24746( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<reco::FFTAnyJet<reco::GenJet> >(*(const ::edm::ProductID*)arg[0],
      (const ::reco::FFTAnyJet<reco::GenJet>*)arg[1],
      *(unsigned long*)arg[2]);
  else ::new(mem) ::edm::Ptr<reco::FFTAnyJet<reco::GenJet> >(*(const ::edm::ProductID*)arg[0],
      (const ::reco::FFTAnyJet<reco::GenJet>*)arg[1],
      *(unsigned long*)arg[2]);
}

static void constructor_24747( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<reco::FFTAnyJet<reco::GenJet> >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::Ptr<reco::FFTAnyJet<reco::GenJet> >(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_24748( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<reco::FFTAnyJet<reco::GenJet> >();
  else ::new(mem) ::edm::Ptr<reco::FFTAnyJet<reco::GenJet> >();
}

static void destructor_24749(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Ptr<reco::FFTAnyJet<reco::GenJet> >*)o)->::edm::Ptr<reco::FFTAnyJet<reco::GenJet> >::~Ptr)();
}
static  void operator_24750( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ptr<reco::FFTAnyJet<reco::GenJet> >*)o)->operator*)();
  else   (((const ::edm::Ptr<reco::FFTAnyJet<reco::GenJet> >*)o)->operator*)();
}

static  void operator_24751( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<reco::FFTAnyJet<reco::GenJet> >*)o)->operator->)());
  else   (((const ::edm::Ptr<reco::FFTAnyJet<reco::GenJet> >*)o)->operator->)();
}

static  void method_24752( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<reco::FFTAnyJet<reco::GenJet> >*)o)->get)());
  else   (((const ::edm::Ptr<reco::FFTAnyJet<reco::GenJet> >*)o)->get)();
}

static  void method_24753( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::FFTAnyJet<reco::GenJet> >*)o)->isNull)());
  else   (((const ::edm::Ptr<reco::FFTAnyJet<reco::GenJet> >*)o)->isNull)();
}

static  void method_24754( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::FFTAnyJet<reco::GenJet> >*)o)->isNonnull)());
  else   (((const ::edm::Ptr<reco::FFTAnyJet<reco::GenJet> >*)o)->isNonnull)();
}

static  void operator_24755( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::FFTAnyJet<reco::GenJet> >*)o)->operator!)());
  else   (((const ::edm::Ptr<reco::FFTAnyJet<reco::GenJet> >*)o)->operator!)();
}

static  void method_24756( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::FFTAnyJet<reco::GenJet> >*)o)->isAvailable)());
  else   (((const ::edm::Ptr<reco::FFTAnyJet<reco::GenJet> >*)o)->isAvailable)();
}

static  void method_24757( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::FFTAnyJet<reco::GenJet> >*)o)->isTransient)());
  else   (((const ::edm::Ptr<reco::FFTAnyJet<reco::GenJet> >*)o)->isTransient)();
}

static  void method_24758( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::Ptr<reco::FFTAnyJet<reco::GenJet> >*)o)->id)());
  else   (((const ::edm::Ptr<reco::FFTAnyJet<reco::GenJet> >*)o)->id)();
}

static  void method_24759( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<reco::FFTAnyJet<reco::GenJet> >*)o)->productGetter)());
  else   (((const ::edm::Ptr<reco::FFTAnyJet<reco::GenJet> >*)o)->productGetter)();
}

static  void method_24760( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long)((((const ::edm::Ptr<reco::FFTAnyJet<reco::GenJet> >*)o)->key)());
  else   (((const ::edm::Ptr<reco::FFTAnyJet<reco::GenJet> >*)o)->key)();
}

static  void method_24761( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::FFTAnyJet<reco::GenJet> >*)o)->hasProductCache)());
  else   (((const ::edm::Ptr<reco::FFTAnyJet<reco::GenJet> >*)o)->hasProductCache)();
}

static  void method_24762( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ptr<reco::FFTAnyJet<reco::GenJet> >*)o)->refCore)();
  else   (((const ::edm::Ptr<reco::FFTAnyJet<reco::GenJet> >*)o)->refCore)();
}

static  void method_24763( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<reco::FFTAnyJet<reco::GenJet> >*)o)->product)());
  else   (((const ::edm::Ptr<reco::FFTAnyJet<reco::GenJet> >*)o)->product)();
}

static  void method_24764( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::Ptr<reco::FFTAnyJet<reco::GenJet> >*)o)->Class_Version)());
  else   (((::edm::Ptr<reco::FFTAnyJet<reco::GenJet> >*)o)->Class_Version)();
}

static void method_newdel_4987( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Ptr<reco::FFTAnyJet<reco::GenJet> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Ptr<reco::FFTAnyJet<reco::GenJet> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Ptr<reco::FFTAnyJet<reco::GenJet> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Ptr<reco::FFTAnyJet<reco::GenJet> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Ptr<reco::FFTAnyJet<reco::GenJet> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Ptr<reco::FFTAnyJet<reco::GenJet> > -------------------------------
void __edm__Ptr_reco__FFTAnyJet_reco__GenJet_s__db_datamem(Reflex::Class*);
void __edm__Ptr_reco__FFTAnyJet_reco__GenJet_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Ptr_reco__FFTAnyJet_reco__GenJet_s__datamem_bld(&__edm__Ptr_reco__FFTAnyJet_reco__GenJet_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Ptr_reco__FFTAnyJet_reco__GenJet_s__funcmem_bld(&__edm__Ptr_reco__FFTAnyJet_reco__GenJet_s__db_funcmem);
void __edm__Ptr_reco__FFTAnyJet_reco__GenJet_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Ptr<reco::FFTAnyJet<reco::GenJet> >"), typeid(::edm::Ptr<reco::FFTAnyJet<reco::GenJet> >), sizeof(::edm::Ptr<reco::FFTAnyJet<reco::GenJet> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::Ptr<reco::FFTAnyJet<reco::GenJet> >::Class_Version())
  .AddProperty(Reflex::Literal("o_name"), "edm::Ptr<reco::FFTGenJet>")
  .AddTypedef(type_358, Reflex::Literal("edm::Ptr<reco::FFTAnyJet<reco::GenJet> >::key_type"))
  .AddTypedef(type_7811, Reflex::Literal("edm::Ptr<reco::FFTAnyJet<reco::GenJet> >::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39899, type_39232), Reflex::Literal("operator="), operator_24743, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39232), Reflex::Literal("Ptr"), constructor_24744, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20599, type_358, type_20675), Reflex::Literal("Ptr"), constructor_24745, 0, "productID;itemKey;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20599, type_13822, type_358), Reflex::Literal("Ptr"), constructor_24746, 0, "productID;item;item_key", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20599), Reflex::Literal("Ptr"), constructor_24747, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Ptr"), constructor_24748, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Ptr"), destructor_24749, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4987, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Ptr_reco__FFTAnyJet_reco__GenJet_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Ptr_reco__FFTAnyJet_reco__GenJet_s__funcmem_bld);
}

//------Delayed data member builder for class Ptr<reco::FFTAnyJet<reco::GenJet> > -------------------
void __edm__Ptr_reco__FFTAnyJet_reco__GenJet_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4935, Reflex::Literal("core_"), OffsetOf(__shadow__::__edm__Ptr_reco__FFTAnyJet_reco__GenJet_s_, core_), ::Reflex::PRIVATE)
  .AddDataMember(type_358, Reflex::Literal("key_"), OffsetOf(__shadow__::__edm__Ptr_reco__FFTAnyJet_reco__GenJet_s_, key_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Ptr<reco::FFTAnyJet<reco::GenJet> > -------------------
void __edm__Ptr_reco__FFTAnyJet_reco__GenJet_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13826), Reflex::Literal("operator*"), operator_24750, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13822), Reflex::Literal("operator->"), operator_24751, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13822), Reflex::Literal("get"), method_24752, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isNull"), method_24753, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isNonnull"), method_24754, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("operator!"), operator_24755, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isAvailable"), method_24756, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isTransient"), method_24757, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4933), Reflex::Literal("id"), method_24758, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20675), Reflex::Literal("productGetter"), method_24759, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_358), Reflex::Literal("key"), method_24760, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("hasProductCache"), method_24761, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23940), Reflex::Literal("refCore"), method_24762, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4071), Reflex::Literal("product"), method_24763, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_237), Reflex::Literal("Class_Version"), method_24764, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class JetTrackMatch<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > > > -------------------------------
static  void operator_28326( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::reco::JetTrackMatch<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->operator=)(*(const ::reco::JetTrackMatch<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)arg[0]);
  else   (((::reco::JetTrackMatch<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->operator=)(*(const ::reco::JetTrackMatch<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)arg[0]);
}

static void constructor_28327( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::JetTrackMatch<std::vector<reco::FFTAnyJet<reco::CaloJet> > >(*(const ::reco::JetTrackMatch<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)arg[0]);
  else ::new(mem) ::reco::JetTrackMatch<std::vector<reco::FFTAnyJet<reco::CaloJet> > >(*(const ::reco::JetTrackMatch<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)arg[0]);
}

static void constructor_28328( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::JetTrackMatch<std::vector<reco::FFTAnyJet<reco::CaloJet> > >();
  else ::new(mem) ::reco::JetTrackMatch<std::vector<reco::FFTAnyJet<reco::CaloJet> > >();
}

static void destructor_28329(void*, void * o, const std::vector<void*>&, void *) {
(((::reco::JetTrackMatch<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->::reco::JetTrackMatch<std::vector<reco::FFTAnyJet<reco::CaloJet> > >::~JetTrackMatch)();
}
static  void method_28330( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::reco::JetTrackMatch<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->insert)(*(const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)arg[0]);
}

static  void method_28331( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::reco::JetTrackMatch<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->insert)(*(const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)arg[0],
    *(const ::edm::Ref<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> >*)arg[1]);
}

static  void method_28332( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >)((((const ::reco::JetTrackMatch<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->allJets)());
  else   (((const ::reco::JetTrackMatch<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->allJets)();
}

static  void method_28333( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<edm::Ref<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> > >)((((const ::reco::JetTrackMatch<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->getTracks)(*(const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)arg[0]));
  else   (((const ::reco::JetTrackMatch<std::vector<reco::FFTAnyJet<reco::CaloJet> > >*)o)->getTracks)(*(const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)arg[0]);
}

static void method_newdel_7875( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::reco::JetTrackMatch<std::vector<reco::FFTAnyJet<reco::CaloJet> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::reco::JetTrackMatch<std::vector<reco::FFTAnyJet<reco::CaloJet> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::reco::JetTrackMatch<std::vector<reco::FFTAnyJet<reco::CaloJet> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::reco::JetTrackMatch<std::vector<reco::FFTAnyJet<reco::CaloJet> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::reco::JetTrackMatch<std::vector<reco::FFTAnyJet<reco::CaloJet> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class JetTrackMatch<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > > > -------------------------------
void __reco__JetTrackMatch_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s__db_datamem(Reflex::Class*);
void __reco__JetTrackMatch_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __reco__JetTrackMatch_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s__datamem_bld(&__reco__JetTrackMatch_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __reco__JetTrackMatch_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s__funcmem_bld(&__reco__JetTrackMatch_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s__db_funcmem);
void __reco__JetTrackMatch_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("reco::JetTrackMatch<std::vector<reco::FFTAnyJet<reco::CaloJet> > >"), typeid(::reco::JetTrackMatch<std::vector<reco::FFTAnyJet<reco::CaloJet> > >), sizeof(::reco::JetTrackMatch<std::vector<reco::FFTAnyJet<reco::CaloJet> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "reco::JetTrackMatch<reco::FFTCaloJetCollection>")
  .AddTypedef(type_5019, Reflex::Literal("reco::JetTrackMatch<std::vector<reco::FFTAnyJet<reco::CaloJet> > >::JetRef"))
  .AddTypedef(type_5020, Reflex::Literal("reco::JetTrackMatch<std::vector<reco::FFTAnyJet<reco::CaloJet> > >::TrackRef"))
  .AddTypedef(type_4770, Reflex::Literal("reco::JetTrackMatch<std::vector<reco::FFTAnyJet<reco::CaloJet> > >::Map"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_40886, type_40887), Reflex::Literal("operator="), operator_28326, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_40887), Reflex::Literal("JetTrackMatch"), constructor_28327, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("JetTrackMatch"), constructor_28328, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~JetTrackMatch"), destructor_28329, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_7875, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__reco__JetTrackMatch_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__reco__JetTrackMatch_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s__funcmem_bld);
}

//------Delayed data member builder for class JetTrackMatch<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > > > -------------------
void __reco__JetTrackMatch_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4770, Reflex::Literal("mMap"), OffsetOf(__shadow__::__reco__JetTrackMatch_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s_, mMap), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class JetTrackMatch<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > > > -------------------
void __reco__JetTrackMatch_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_38847), Reflex::Literal("insert"), method_28330, 0, "fJet", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_38847, type_13371), Reflex::Literal("insert"), method_28331, 0, "fJet;fTrack", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2977), Reflex::Literal("allJets"), method_28332, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2975, type_38847), Reflex::Literal("getTracks"), method_28333, 0, "mJet", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class JetTrackMatch<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > > > -------------------------------
static  void operator_28338( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::reco::JetTrackMatch<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->operator=)(*(const ::reco::JetTrackMatch<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)arg[0]);
  else   (((::reco::JetTrackMatch<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->operator=)(*(const ::reco::JetTrackMatch<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)arg[0]);
}

static void constructor_28339( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::JetTrackMatch<std::vector<reco::FFTAnyJet<reco::GenJet> > >(*(const ::reco::JetTrackMatch<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)arg[0]);
  else ::new(mem) ::reco::JetTrackMatch<std::vector<reco::FFTAnyJet<reco::GenJet> > >(*(const ::reco::JetTrackMatch<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)arg[0]);
}

static void constructor_28340( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::JetTrackMatch<std::vector<reco::FFTAnyJet<reco::GenJet> > >();
  else ::new(mem) ::reco::JetTrackMatch<std::vector<reco::FFTAnyJet<reco::GenJet> > >();
}

static void destructor_28341(void*, void * o, const std::vector<void*>&, void *) {
(((::reco::JetTrackMatch<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->::reco::JetTrackMatch<std::vector<reco::FFTAnyJet<reco::GenJet> > >::~JetTrackMatch)();
}
static  void method_28342( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::reco::JetTrackMatch<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->insert)(*(const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)arg[0]);
}

static  void method_28343( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::reco::JetTrackMatch<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->insert)(*(const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)arg[0],
    *(const ::edm::Ref<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> >*)arg[1]);
}

static  void method_28344( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >)((((const ::reco::JetTrackMatch<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->allJets)());
  else   (((const ::reco::JetTrackMatch<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->allJets)();
}

static  void method_28345( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<edm::Ref<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> > >)((((const ::reco::JetTrackMatch<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->getTracks)(*(const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)arg[0]));
  else   (((const ::reco::JetTrackMatch<std::vector<reco::FFTAnyJet<reco::GenJet> > >*)o)->getTracks)(*(const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)arg[0]);
}

static void method_newdel_7876( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::reco::JetTrackMatch<std::vector<reco::FFTAnyJet<reco::GenJet> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::reco::JetTrackMatch<std::vector<reco::FFTAnyJet<reco::GenJet> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::reco::JetTrackMatch<std::vector<reco::FFTAnyJet<reco::GenJet> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::reco::JetTrackMatch<std::vector<reco::FFTAnyJet<reco::GenJet> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::reco::JetTrackMatch<std::vector<reco::FFTAnyJet<reco::GenJet> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class JetTrackMatch<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > > > -------------------------------
void __reco__JetTrackMatch_std__vector_reco__FFTAnyJet_reco__GenJet_s_s__db_datamem(Reflex::Class*);
void __reco__JetTrackMatch_std__vector_reco__FFTAnyJet_reco__GenJet_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __reco__JetTrackMatch_std__vector_reco__FFTAnyJet_reco__GenJet_s_s__datamem_bld(&__reco__JetTrackMatch_std__vector_reco__FFTAnyJet_reco__GenJet_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __reco__JetTrackMatch_std__vector_reco__FFTAnyJet_reco__GenJet_s_s__funcmem_bld(&__reco__JetTrackMatch_std__vector_reco__FFTAnyJet_reco__GenJet_s_s__db_funcmem);
void __reco__JetTrackMatch_std__vector_reco__FFTAnyJet_reco__GenJet_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("reco::JetTrackMatch<std::vector<reco::FFTAnyJet<reco::GenJet> > >"), typeid(::reco::JetTrackMatch<std::vector<reco::FFTAnyJet<reco::GenJet> > >), sizeof(::reco::JetTrackMatch<std::vector<reco::FFTAnyJet<reco::GenJet> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "reco::JetTrackMatch<reco::FFTGenJetCollection>")
  .AddTypedef(type_5021, Reflex::Literal("reco::JetTrackMatch<std::vector<reco::FFTAnyJet<reco::GenJet> > >::JetRef"))
  .AddTypedef(type_5020, Reflex::Literal("reco::JetTrackMatch<std::vector<reco::FFTAnyJet<reco::GenJet> > >::TrackRef"))
  .AddTypedef(type_4771, Reflex::Literal("reco::JetTrackMatch<std::vector<reco::FFTAnyJet<reco::GenJet> > >::Map"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_40888, type_40889), Reflex::Literal("operator="), operator_28338, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_40889), Reflex::Literal("JetTrackMatch"), constructor_28339, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("JetTrackMatch"), constructor_28340, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~JetTrackMatch"), destructor_28341, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_7876, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__reco__JetTrackMatch_std__vector_reco__FFTAnyJet_reco__GenJet_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__reco__JetTrackMatch_std__vector_reco__FFTAnyJet_reco__GenJet_s_s__funcmem_bld);
}

//------Delayed data member builder for class JetTrackMatch<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > > > -------------------
void __reco__JetTrackMatch_std__vector_reco__FFTAnyJet_reco__GenJet_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4771, Reflex::Literal("mMap"), OffsetOf(__shadow__::__reco__JetTrackMatch_std__vector_reco__FFTAnyJet_reco__GenJet_s_s_, mMap), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class JetTrackMatch<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > > > -------------------
void __reco__JetTrackMatch_std__vector_reco__FFTAnyJet_reco__GenJet_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_38861), Reflex::Literal("insert"), method_28342, 0, "fJet", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_38861, type_13371), Reflex::Literal("insert"), method_28343, 0, "fJet;fTrack", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2984), Reflex::Literal("allJets"), method_28344, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2975, type_38861), Reflex::Literal("getTracks"), method_28345, 0, "mJet", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> >, reco::CATopJetTagInfo, edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> >, reco::CATopJetTagInfo> > > -------------------------------
static  void operator_39529( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->operator=)(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)arg[0]);
  else   (((::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->operator=)(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)arg[0]);
}

static void constructor_39530( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)arg[0]);
  else ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)arg[0]);
}

static void constructor_39531( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >();
  else ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >();
}

static void constructor_39532( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >(*(const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)arg[0]);
  else ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >(*(const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)arg[0]);
}

static  void method_39533( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->swap)(*(::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)arg[0]);
}

static void destructor_39534(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >::~RefHolder)();
}
static  void method_39535( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->clone)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->clone)();
}

static  void method_39536( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->id)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->id)();
}

static  void method_39537( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->key)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->key)();
}

static  void method_39538( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->isEqualTo)(*(const ::edm::reftobase::RefHolderBase*)arg[0]));
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->isEqualTo)(*(const ::edm::reftobase::RefHolderBase*)arg[0]);
}

static  void method_39539( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]));
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]);
}

static  void method_39540( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->getRef)();
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->getRef)();
}

static  void method_39541( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->setRef)(*(const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)arg[0]);
}

static  void method_39542( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefVectorHolderBase>)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->makeVectorHolder)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->makeVectorHolder)();
}

static  void method_39543( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->productGetter)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->productGetter)();
}

static  void method_39544( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->hasProductCache)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->hasProductCache)();
}

static  void method_39545( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->product)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->product)();
}

static  void method_39546( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->isAvailable)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->isAvailable)();
}

static  void method_39547( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->Class_Version)());
  else   (((::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->Class_Version)();
}

static void method_newdel_23851( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x162( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::RefHolderBase")), ::Reflex::BaseOffset< ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >,::edm::reftobase::RefHolderBase >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> >, reco::CATopJetTagInfo, edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> >, reco::CATopJetTagInfo> > > -------------------------------
void __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_s__db_datamem(Reflex::Class*);
void __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_s__datamem_bld(&__edm__reftobase__RefHolder_edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_s__funcmem_bld(&__edm__reftobase__RefHolder_edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_s__db_funcmem);
void __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >"), typeid(::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >), sizeof(::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >::Class_Version())
  .AddProperty(Reflex::Literal("o_name"), "edm::reftobase::RefHolder<reco::CATopJetTagInfoRef>")
  .AddBase(type_12435, ::Reflex::BaseOffset< ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >, ::edm::reftobase::RefHolderBase >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_44560, type_44561), Reflex::Literal("operator="), operator_39529, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_44561), Reflex::Literal("RefHolder"), constructor_39530, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefHolder"), constructor_39531, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39272), Reflex::Literal("RefHolder"), constructor_39532, 0, "ref", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefHolder"), destructor_39534, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_23851, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x162, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__reftobase__RefHolder_edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__reftobase__RefHolder_edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_s__funcmem_bld);
}

//------Delayed data member builder for class RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> >, reco::CATopJetTagInfo, edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> >, reco::CATopJetTagInfo> > > -------------------
void __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_5018, Reflex::Literal("ref_"), OffsetOf(__shadow__::__edm__reftobase__RefHolder_edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_s_, ref_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> >, reco::CATopJetTagInfo, edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> >, reco::CATopJetTagInfo> > > -------------------
void __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_44560), Reflex::Literal("swap"), method_39533, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21903), Reflex::Literal("clone"), method_39535, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4933), Reflex::Literal("id"), method_39536, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2121), Reflex::Literal("key"), method_39537, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566, type_42120), Reflex::Literal("isEqualTo"), method_39538, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566, type_21905, type_11079), Reflex::Literal("fillRefIfMyTypeMatches"), method_39539, 0, "fillme;msg", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39272), Reflex::Literal("getRef"), method_39540, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_39272), Reflex::Literal("setRef"), method_39541, 0, "r", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2771), Reflex::Literal("makeVectorHolder"), method_39542, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20675), Reflex::Literal("productGetter"), method_39543, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("hasProductCache"), method_39544, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4071), Reflex::Literal("product"), method_39545, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isAvailable"), method_39546, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_237), Reflex::Literal("Class_Version"), method_39547, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >, reco::FFTAnyJet<reco::CaloJet>, edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >, reco::FFTAnyJet<reco::CaloJet> > > > -------------------------------
static  void operator_39550( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->operator=)(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)arg[0]);
  else   (((::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->operator=)(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)arg[0]);
}

static void constructor_39551( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)arg[0]);
  else ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)arg[0]);
}

static void constructor_39552( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >();
  else ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >();
}

static void constructor_39553( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >(*(const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)arg[0]);
  else ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >(*(const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)arg[0]);
}

static  void method_39554( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->swap)(*(::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)arg[0]);
}

static void destructor_39555(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >::~RefHolder)();
}
static  void method_39556( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->clone)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->clone)();
}

static  void method_39557( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->id)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->id)();
}

static  void method_39558( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->key)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->key)();
}

static  void method_39559( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->isEqualTo)(*(const ::edm::reftobase::RefHolderBase*)arg[0]));
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->isEqualTo)(*(const ::edm::reftobase::RefHolderBase*)arg[0]);
}

static  void method_39560( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]));
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]);
}

static  void method_39561( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->getRef)();
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->getRef)();
}

static  void method_39562( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->setRef)(*(const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)arg[0]);
}

static  void method_39563( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefVectorHolderBase>)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->makeVectorHolder)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->makeVectorHolder)();
}

static  void method_39564( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->productGetter)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->productGetter)();
}

static  void method_39565( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->hasProductCache)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->hasProductCache)();
}

static  void method_39566( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->product)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->product)();
}

static  void method_39567( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->isAvailable)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->isAvailable)();
}

static  void method_39568( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->Class_Version)());
  else   (((::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->Class_Version)();
}

static void method_newdel_23852( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x164( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::RefHolderBase")), ::Reflex::BaseOffset< ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >,::edm::reftobase::RefHolderBase >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >, reco::FFTAnyJet<reco::CaloJet>, edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >, reco::FFTAnyJet<reco::CaloJet> > > > -------------------------------
void __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s__db_datamem(Reflex::Class*);
void __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s__datamem_bld(&__edm__reftobase__RefHolder_edm__Ref_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s__funcmem_bld(&__edm__reftobase__RefHolder_edm__Ref_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s__db_funcmem);
void __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >"), typeid(::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >), sizeof(::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >::Class_Version())
  .AddProperty(Reflex::Literal("o_name"), "edm::reftobase::RefHolder<reco::FFTCaloJetRef>")
  .AddBase(type_12435, ::Reflex::BaseOffset< ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >, ::edm::reftobase::RefHolderBase >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_44562, type_44563), Reflex::Literal("operator="), operator_39550, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_44563), Reflex::Literal("RefHolder"), constructor_39551, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefHolder"), constructor_39552, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_38847), Reflex::Literal("RefHolder"), constructor_39553, 0, "ref", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefHolder"), destructor_39555, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_23852, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x164, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__reftobase__RefHolder_edm__Ref_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__reftobase__RefHolder_edm__Ref_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s__funcmem_bld);
}

//------Delayed data member builder for class RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >, reco::FFTAnyJet<reco::CaloJet>, edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >, reco::FFTAnyJet<reco::CaloJet> > > > -------------------
void __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_5019, Reflex::Literal("ref_"), OffsetOf(__shadow__::__edm__reftobase__RefHolder_edm__Ref_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s_, ref_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >, reco::FFTAnyJet<reco::CaloJet>, edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >, reco::FFTAnyJet<reco::CaloJet> > > > -------------------
void __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_44562), Reflex::Literal("swap"), method_39554, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21903), Reflex::Literal("clone"), method_39556, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4933), Reflex::Literal("id"), method_39557, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2121), Reflex::Literal("key"), method_39558, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566, type_42120), Reflex::Literal("isEqualTo"), method_39559, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566, type_21905, type_11079), Reflex::Literal("fillRefIfMyTypeMatches"), method_39560, 0, "fillme;msg", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_38847), Reflex::Literal("getRef"), method_39561, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_38847), Reflex::Literal("setRef"), method_39562, 0, "r", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2771), Reflex::Literal("makeVectorHolder"), method_39563, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20675), Reflex::Literal("productGetter"), method_39564, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("hasProductCache"), method_39565, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4071), Reflex::Literal("product"), method_39566, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isAvailable"), method_39567, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_237), Reflex::Literal("Class_Version"), method_39568, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >, reco::FFTAnyJet<reco::GenJet>, edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >, reco::FFTAnyJet<reco::GenJet> > > > -------------------------------
static  void operator_39571( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->operator=)(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)arg[0]);
  else   (((::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->operator=)(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)arg[0]);
}

static void constructor_39572( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)arg[0]);
  else ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)arg[0]);
}

static void constructor_39573( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >();
  else ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >();
}

static void constructor_39574( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >(*(const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)arg[0]);
  else ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >(*(const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)arg[0]);
}

static  void method_39575( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->swap)(*(::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)arg[0]);
}

static void destructor_39576(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >::~RefHolder)();
}
static  void method_39577( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->clone)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->clone)();
}

static  void method_39578( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->id)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->id)();
}

static  void method_39579( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->key)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->key)();
}

static  void method_39580( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->isEqualTo)(*(const ::edm::reftobase::RefHolderBase*)arg[0]));
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->isEqualTo)(*(const ::edm::reftobase::RefHolderBase*)arg[0]);
}

static  void method_39581( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]));
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]);
}

static  void method_39582( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->getRef)();
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->getRef)();
}

static  void method_39583( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->setRef)(*(const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)arg[0]);
}

static  void method_39584( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefVectorHolderBase>)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->makeVectorHolder)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->makeVectorHolder)();
}

static  void method_39585( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->productGetter)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->productGetter)();
}

static  void method_39586( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->hasProductCache)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->hasProductCache)();
}

static  void method_39587( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->product)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->product)();
}

static  void method_39588( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->isAvailable)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->isAvailable)();
}

static  void method_39589( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->Class_Version)());
  else   (((::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->Class_Version)();
}

static void method_newdel_23853( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x166( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::RefHolderBase")), ::Reflex::BaseOffset< ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >,::edm::reftobase::RefHolderBase >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >, reco::FFTAnyJet<reco::GenJet>, edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >, reco::FFTAnyJet<reco::GenJet> > > > -------------------------------
void __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s__db_datamem(Reflex::Class*);
void __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s__datamem_bld(&__edm__reftobase__RefHolder_edm__Ref_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s__funcmem_bld(&__edm__reftobase__RefHolder_edm__Ref_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s__db_funcmem);
void __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >"), typeid(::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >), sizeof(::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >::Class_Version())
  .AddProperty(Reflex::Literal("o_name"), "edm::reftobase::RefHolder<reco::FFTGenJetRef>")
  .AddBase(type_12435, ::Reflex::BaseOffset< ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >, ::edm::reftobase::RefHolderBase >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_44564, type_44565), Reflex::Literal("operator="), operator_39571, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_44565), Reflex::Literal("RefHolder"), constructor_39572, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefHolder"), constructor_39573, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_38861), Reflex::Literal("RefHolder"), constructor_39574, 0, "ref", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefHolder"), destructor_39576, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_23853, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x166, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__reftobase__RefHolder_edm__Ref_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__reftobase__RefHolder_edm__Ref_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s__funcmem_bld);
}

//------Delayed data member builder for class RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >, reco::FFTAnyJet<reco::GenJet>, edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >, reco::FFTAnyJet<reco::GenJet> > > > -------------------
void __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_5021, Reflex::Literal("ref_"), OffsetOf(__shadow__::__edm__reftobase__RefHolder_edm__Ref_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s_, ref_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >, reco::FFTAnyJet<reco::GenJet>, edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >, reco::FFTAnyJet<reco::GenJet> > > > -------------------
void __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_44564), Reflex::Literal("swap"), method_39575, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21903), Reflex::Literal("clone"), method_39577, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4933), Reflex::Literal("id"), method_39578, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2121), Reflex::Literal("key"), method_39579, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566, type_42120), Reflex::Literal("isEqualTo"), method_39580, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566, type_21905, type_11079), Reflex::Literal("fillRefIfMyTypeMatches"), method_39581, 0, "fillme;msg", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_38861), Reflex::Literal("getRef"), method_39582, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_38861), Reflex::Literal("setRef"), method_39583, 0, "r", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2771), Reflex::Literal("makeVectorHolder"), method_39584, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20675), Reflex::Literal("productGetter"), method_39585, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("hasProductCache"), method_39586, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4071), Reflex::Literal("product"), method_39587, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isAvailable"), method_39588, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_237), Reflex::Literal("Class_Version"), method_39589, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> >, reco::CATopJetTagInfo, edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> >, reco::CATopJetTagInfo> > > -------------------------------
static void constructor_39626( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >();
  else ::new(mem) ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >();
}

static void constructor_39627( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >(*(const ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)arg[0]);
  else ::new(mem) ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >(*(const ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)arg[0]);
}

static void constructor_39628( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >(*(const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)arg[0]);
  else ::new(mem) ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >(*(const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)arg[0]);
}

static  void operator_39629( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->operator=)(*(const ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)arg[0]);
  else   (((::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->operator=)(*(const ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)arg[0]);
}

static  void method_39630( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->swap)(*(::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)arg[0]);
}

static void destructor_39631(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >::~Holder)();
}
static  void method_39632( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->clone)());
  else   (((const ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->clone)();
}

static  void method_39633( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->getPtr)());
  else   (((const ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->getPtr)();
}

static  void method_39634( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->id)());
  else   (((const ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->id)();
}

static  void method_39635( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->key)());
  else   (((const ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->key)();
}

static  void method_39636( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->isEqualTo)(*(const ::edm::reftobase::BaseHolder<reco::BaseTagInfo>*)arg[0]));
  else   (((const ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->isEqualTo)(*(const ::edm::reftobase::BaseHolder<reco::BaseTagInfo>*)arg[0]);
}

static  void method_39637( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->getRef)();
  else   (((const ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->getRef)();
}

static  void method_39638( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]));
  else   (((const ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]);
}

static  void method_39639( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefHolderBase>)((((const ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->holder)());
  else   (((const ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->holder)();
}

static  void method_39640( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::BaseVectorHolder<reco::BaseTagInfo> >)((((const ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->makeVectorHolder)());
  else   (((const ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->makeVectorHolder)();
}

static  void method_39641( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefVectorHolderBase>)((((const ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->makeVectorBaseHolder)());
  else   (((const ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->makeVectorBaseHolder)();
}

static  void method_39642( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->productGetter)());
  else   (((const ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->productGetter)();
}

static  void method_39643( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->hasProductCache)());
  else   (((const ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->hasProductCache)();
}

static  void method_39644( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->product)());
  else   (((const ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->product)();
}

static  void method_39645( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->isAvailable)());
  else   (((const ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->isAvailable)();
}

static  void method_39646( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->Class_Version)());
  else   (((::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->Class_Version)();
}

static void method_newdel_23860( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x168( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::BaseHolder<reco::BaseTagInfo>")), ::Reflex::BaseOffset< ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >,::edm::reftobase::BaseHolder<reco::BaseTagInfo> >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> >, reco::CATopJetTagInfo, edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> >, reco::CATopJetTagInfo> > > -------------------------------
void __edm__reftobase__Holder_reco__BaseTagInfo_edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_s__db_datamem(Reflex::Class*);
void __edm__reftobase__Holder_reco__BaseTagInfo_edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__reftobase__Holder_reco__BaseTagInfo_edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_s__datamem_bld(&__edm__reftobase__Holder_reco__BaseTagInfo_edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__reftobase__Holder_reco__BaseTagInfo_edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_s__funcmem_bld(&__edm__reftobase__Holder_reco__BaseTagInfo_edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_s__db_funcmem);
void __edm__reftobase__Holder_reco__BaseTagInfo_edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >"), typeid(::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >), sizeof(::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >::Class_Version())
  .AddProperty(Reflex::Literal("o_name"), "edm::reftobase::Holder<reco::BaseTagInfo, reco::CATopJetTagInfoRef>")
  .AddBase(type_23846, ::Reflex::BaseOffset< ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >, ::edm::reftobase::BaseHolder<reco::BaseTagInfo> >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Holder"), constructor_39626, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_44573), Reflex::Literal("Holder"), constructor_39627, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39272), Reflex::Literal("Holder"), constructor_39628, 0, "r", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Holder"), destructor_39631, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_23860, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x168, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__reftobase__Holder_reco__BaseTagInfo_edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__reftobase__Holder_reco__BaseTagInfo_edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_s__funcmem_bld);
}

//------Delayed data member builder for class Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> >, reco::CATopJetTagInfo, edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> >, reco::CATopJetTagInfo> > > -------------------
void __edm__reftobase__Holder_reco__BaseTagInfo_edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_5018, Reflex::Literal("ref_"), OffsetOf(__shadow__::__edm__reftobase__Holder_reco__BaseTagInfo_edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_s_, ref_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> >, reco::CATopJetTagInfo, edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> >, reco::CATopJetTagInfo> > > -------------------
void __edm__reftobase__Holder_reco__BaseTagInfo_edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_44574, type_44573), Reflex::Literal("operator="), operator_39629, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_44574), Reflex::Literal("swap"), method_39630, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_44553), Reflex::Literal("clone"), method_39632, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14733), Reflex::Literal("getPtr"), method_39633, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4933), Reflex::Literal("id"), method_39634, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2121), Reflex::Literal("key"), method_39635, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566, type_44555), Reflex::Literal("isEqualTo"), method_39636, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39272), Reflex::Literal("getRef"), method_39637, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566, type_21905, type_11079), Reflex::Literal("fillRefIfMyTypeMatches"), method_39638, 0, "fillme;msg", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2773), Reflex::Literal("holder"), method_39639, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2772), Reflex::Literal("makeVectorHolder"), method_39640, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2771), Reflex::Literal("makeVectorBaseHolder"), method_39641, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20675), Reflex::Literal("productGetter"), method_39642, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("hasProductCache"), method_39643, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4071), Reflex::Literal("product"), method_39644, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isAvailable"), method_39645, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_237), Reflex::Literal("Class_Version"), method_39646, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >, reco::FFTAnyJet<reco::CaloJet>, edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >, reco::FFTAnyJet<reco::CaloJet> > > > -------------------------------
static void constructor_39648( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >();
  else ::new(mem) ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >();
}

static void constructor_39649( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >(*(const ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)arg[0]);
  else ::new(mem) ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >(*(const ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)arg[0]);
}

static void constructor_39650( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >(*(const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)arg[0]);
  else ::new(mem) ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >(*(const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)arg[0]);
}

static  void operator_39651( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->operator=)(*(const ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)arg[0]);
  else   (((::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->operator=)(*(const ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)arg[0]);
}

static  void method_39652( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->swap)(*(::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)arg[0]);
}

static void destructor_39653(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >::~Holder)();
}
static  void method_39654( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->clone)());
  else   (((const ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->clone)();
}

static  void method_39655( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->getPtr)());
  else   (((const ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->getPtr)();
}

static  void method_39656( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->id)());
  else   (((const ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->id)();
}

static  void method_39657( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->key)());
  else   (((const ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->key)();
}

static  void method_39658( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->isEqualTo)(*(const ::edm::reftobase::BaseHolder<reco::Jet>*)arg[0]));
  else   (((const ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->isEqualTo)(*(const ::edm::reftobase::BaseHolder<reco::Jet>*)arg[0]);
}

static  void method_39659( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->getRef)();
  else   (((const ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->getRef)();
}

static  void method_39660( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]));
  else   (((const ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]);
}

static  void method_39661( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefHolderBase>)((((const ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->holder)());
  else   (((const ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->holder)();
}

static  void method_39662( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::BaseVectorHolder<reco::Jet> >)((((const ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->makeVectorHolder)());
  else   (((const ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->makeVectorHolder)();
}

static  void method_39663( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefVectorHolderBase>)((((const ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->makeVectorBaseHolder)());
  else   (((const ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->makeVectorBaseHolder)();
}

static  void method_39664( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->productGetter)());
  else   (((const ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->productGetter)();
}

static  void method_39665( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->hasProductCache)());
  else   (((const ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->hasProductCache)();
}

static  void method_39666( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->product)());
  else   (((const ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->product)();
}

static  void method_39667( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->isAvailable)());
  else   (((const ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->isAvailable)();
}

static  void method_39668( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->Class_Version)());
  else   (((::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->Class_Version)();
}

static void method_newdel_23861( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x170( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::BaseHolder<reco::Jet>")), ::Reflex::BaseOffset< ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >,::edm::reftobase::BaseHolder<reco::Jet> >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >, reco::FFTAnyJet<reco::CaloJet>, edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >, reco::FFTAnyJet<reco::CaloJet> > > > -------------------------------
void __edm__reftobase__Holder_reco__Jet_edm__Ref_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s__db_datamem(Reflex::Class*);
void __edm__reftobase__Holder_reco__Jet_edm__Ref_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__reftobase__Holder_reco__Jet_edm__Ref_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s__datamem_bld(&__edm__reftobase__Holder_reco__Jet_edm__Ref_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__reftobase__Holder_reco__Jet_edm__Ref_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s__funcmem_bld(&__edm__reftobase__Holder_reco__Jet_edm__Ref_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s__db_funcmem);
void __edm__reftobase__Holder_reco__Jet_edm__Ref_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >"), typeid(::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >), sizeof(::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >::Class_Version())
  .AddProperty(Reflex::Literal("o_name"), "edm::reftobase::Holder<reco::Jet, reco::FFTCaloJetRef>")
  .AddBase(type_23847, ::Reflex::BaseOffset< ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >, ::edm::reftobase::BaseHolder<reco::Jet> >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Holder"), constructor_39648, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_44575), Reflex::Literal("Holder"), constructor_39649, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_38847), Reflex::Literal("Holder"), constructor_39650, 0, "r", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Holder"), destructor_39653, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_23861, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x170, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__reftobase__Holder_reco__Jet_edm__Ref_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__reftobase__Holder_reco__Jet_edm__Ref_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s__funcmem_bld);
}

//------Delayed data member builder for class Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >, reco::FFTAnyJet<reco::CaloJet>, edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >, reco::FFTAnyJet<reco::CaloJet> > > > -------------------
void __edm__reftobase__Holder_reco__Jet_edm__Ref_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_5019, Reflex::Literal("ref_"), OffsetOf(__shadow__::__edm__reftobase__Holder_reco__Jet_edm__Ref_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s_, ref_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >, reco::FFTAnyJet<reco::CaloJet>, edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >, reco::FFTAnyJet<reco::CaloJet> > > > -------------------
void __edm__reftobase__Holder_reco__Jet_edm__Ref_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_44576, type_44575), Reflex::Literal("operator="), operator_39651, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_44576), Reflex::Literal("swap"), method_39652, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39872), Reflex::Literal("clone"), method_39654, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14466), Reflex::Literal("getPtr"), method_39655, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4933), Reflex::Literal("id"), method_39656, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2121), Reflex::Literal("key"), method_39657, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566, type_44557), Reflex::Literal("isEqualTo"), method_39658, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_38847), Reflex::Literal("getRef"), method_39659, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566, type_21905, type_11079), Reflex::Literal("fillRefIfMyTypeMatches"), method_39660, 0, "fillme;msg", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2773), Reflex::Literal("holder"), method_39661, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776), Reflex::Literal("makeVectorHolder"), method_39662, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2771), Reflex::Literal("makeVectorBaseHolder"), method_39663, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20675), Reflex::Literal("productGetter"), method_39664, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("hasProductCache"), method_39665, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4071), Reflex::Literal("product"), method_39666, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isAvailable"), method_39667, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_237), Reflex::Literal("Class_Version"), method_39668, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >, reco::FFTAnyJet<reco::CaloJet>, edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >, reco::FFTAnyJet<reco::CaloJet> > > > -------------------------------
static void constructor_39670( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >();
  else ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >();
}

static void constructor_39671( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >(*(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)arg[0]);
  else ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >(*(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)arg[0]);
}

static void constructor_39672( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >(*(const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)arg[0]);
  else ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >(*(const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > >*)arg[0]);
}

static  void operator_39673( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->operator=)(*(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)arg[0]);
  else   (((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->operator=)(*(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)arg[0]);
}

static  void method_39674( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->swap)(*(::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)arg[0]);
}

static void destructor_39675(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >::~Holder)();
}
static  void method_39676( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->clone)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->clone)();
}

static  void method_39677( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->getPtr)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->getPtr)();
}

static  void method_39678( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->id)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->id)();
}

static  void method_39679( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->key)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->key)();
}

static  void method_39680( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->isEqualTo)(*(const ::edm::reftobase::BaseHolder<reco::Candidate>*)arg[0]));
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->isEqualTo)(*(const ::edm::reftobase::BaseHolder<reco::Candidate>*)arg[0]);
}

static  void method_39681( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->getRef)();
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->getRef)();
}

static  void method_39682( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]));
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]);
}

static  void method_39683( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefHolderBase>)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->holder)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->holder)();
}

static  void method_39684( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::BaseVectorHolder<reco::Candidate> >)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->makeVectorHolder)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->makeVectorHolder)();
}

static  void method_39685( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefVectorHolderBase>)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->makeVectorBaseHolder)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->makeVectorBaseHolder)();
}

static  void method_39686( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->productGetter)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->productGetter)();
}

static  void method_39687( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->hasProductCache)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->hasProductCache)();
}

static  void method_39688( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->product)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->product)();
}

static  void method_39689( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->isAvailable)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->isAvailable)();
}

static  void method_39690( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->Class_Version)());
  else   (((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >*)o)->Class_Version)();
}

static void method_newdel_23862( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x172( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::BaseHolder<reco::Candidate>")), ::Reflex::BaseOffset< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >,::edm::reftobase::BaseHolder<reco::Candidate> >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >, reco::FFTAnyJet<reco::CaloJet>, edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >, reco::FFTAnyJet<reco::CaloJet> > > > -------------------------------
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s__db_datamem(Reflex::Class*);
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s__datamem_bld(&__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s__funcmem_bld(&__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s__db_funcmem);
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >"), typeid(::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >), sizeof(::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >::Class_Version())
  .AddProperty(Reflex::Literal("o_name"), "edm::reftobase::Holder<reco::Candidate, reco::FFTCaloJetRef>")
  .AddBase(type_23848, ::Reflex::BaseOffset< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > >, ::edm::reftobase::BaseHolder<reco::Candidate> >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Holder"), constructor_39670, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_44577), Reflex::Literal("Holder"), constructor_39671, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_38847), Reflex::Literal("Holder"), constructor_39672, 0, "r", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Holder"), destructor_39675, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_23862, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x172, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s__funcmem_bld);
}

//------Delayed data member builder for class Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >, reco::FFTAnyJet<reco::CaloJet>, edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >, reco::FFTAnyJet<reco::CaloJet> > > > -------------------
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_5019, Reflex::Literal("ref_"), OffsetOf(__shadow__::__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s_, ref_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >, reco::FFTAnyJet<reco::CaloJet>, edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet>, std::allocator<reco::FFTAnyJet<reco::CaloJet> > >, reco::FFTAnyJet<reco::CaloJet> > > > -------------------
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_44578, type_44577), Reflex::Literal("operator="), operator_39673, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_44578), Reflex::Literal("swap"), method_39674, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39874), Reflex::Literal("clone"), method_39676, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39879), Reflex::Literal("getPtr"), method_39677, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4933), Reflex::Literal("id"), method_39678, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2121), Reflex::Literal("key"), method_39679, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566, type_44559), Reflex::Literal("isEqualTo"), method_39680, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_38847), Reflex::Literal("getRef"), method_39681, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566, type_21905, type_11079), Reflex::Literal("fillRefIfMyTypeMatches"), method_39682, 0, "fillme;msg", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2773), Reflex::Literal("holder"), method_39683, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2777), Reflex::Literal("makeVectorHolder"), method_39684, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2771), Reflex::Literal("makeVectorBaseHolder"), method_39685, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20675), Reflex::Literal("productGetter"), method_39686, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("hasProductCache"), method_39687, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4071), Reflex::Literal("product"), method_39688, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isAvailable"), method_39689, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_237), Reflex::Literal("Class_Version"), method_39690, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >, reco::FFTAnyJet<reco::GenJet>, edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >, reco::FFTAnyJet<reco::GenJet> > > > -------------------------------
static void constructor_39692( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >();
  else ::new(mem) ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >();
}

static void constructor_39693( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >(*(const ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)arg[0]);
  else ::new(mem) ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >(*(const ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)arg[0]);
}

static void constructor_39694( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >(*(const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)arg[0]);
  else ::new(mem) ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >(*(const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)arg[0]);
}

static  void operator_39695( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->operator=)(*(const ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)arg[0]);
  else   (((::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->operator=)(*(const ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)arg[0]);
}

static  void method_39696( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->swap)(*(::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)arg[0]);
}

static void destructor_39697(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >::~Holder)();
}
static  void method_39698( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->clone)());
  else   (((const ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->clone)();
}

static  void method_39699( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->getPtr)());
  else   (((const ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->getPtr)();
}

static  void method_39700( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->id)());
  else   (((const ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->id)();
}

static  void method_39701( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->key)());
  else   (((const ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->key)();
}

static  void method_39702( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->isEqualTo)(*(const ::edm::reftobase::BaseHolder<reco::Jet>*)arg[0]));
  else   (((const ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->isEqualTo)(*(const ::edm::reftobase::BaseHolder<reco::Jet>*)arg[0]);
}

static  void method_39703( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->getRef)();
  else   (((const ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->getRef)();
}

static  void method_39704( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]));
  else   (((const ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]);
}

static  void method_39705( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefHolderBase>)((((const ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->holder)());
  else   (((const ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->holder)();
}

static  void method_39706( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::BaseVectorHolder<reco::Jet> >)((((const ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->makeVectorHolder)());
  else   (((const ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->makeVectorHolder)();
}

static  void method_39707( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefVectorHolderBase>)((((const ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->makeVectorBaseHolder)());
  else   (((const ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->makeVectorBaseHolder)();
}

static  void method_39708( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->productGetter)());
  else   (((const ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->productGetter)();
}

static  void method_39709( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->hasProductCache)());
  else   (((const ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->hasProductCache)();
}

static  void method_39710( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->product)());
  else   (((const ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->product)();
}

static  void method_39711( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->isAvailable)());
  else   (((const ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->isAvailable)();
}

static  void method_39712( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->Class_Version)());
  else   (((::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->Class_Version)();
}

static void method_newdel_23863( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x174( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::BaseHolder<reco::Jet>")), ::Reflex::BaseOffset< ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >,::edm::reftobase::BaseHolder<reco::Jet> >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >, reco::FFTAnyJet<reco::GenJet>, edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >, reco::FFTAnyJet<reco::GenJet> > > > -------------------------------
void __edm__reftobase__Holder_reco__Jet_edm__Ref_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s__db_datamem(Reflex::Class*);
void __edm__reftobase__Holder_reco__Jet_edm__Ref_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__reftobase__Holder_reco__Jet_edm__Ref_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s__datamem_bld(&__edm__reftobase__Holder_reco__Jet_edm__Ref_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__reftobase__Holder_reco__Jet_edm__Ref_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s__funcmem_bld(&__edm__reftobase__Holder_reco__Jet_edm__Ref_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s__db_funcmem);
void __edm__reftobase__Holder_reco__Jet_edm__Ref_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >"), typeid(::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >), sizeof(::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >::Class_Version())
  .AddProperty(Reflex::Literal("o_name"), "edm::reftobase::Holder<reco::Jet, reco::FFTGenJetRef>")
  .AddBase(type_23847, ::Reflex::BaseOffset< ::edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >, ::edm::reftobase::BaseHolder<reco::Jet> >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Holder"), constructor_39692, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_44579), Reflex::Literal("Holder"), constructor_39693, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_38861), Reflex::Literal("Holder"), constructor_39694, 0, "r", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Holder"), destructor_39697, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_23863, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x174, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__reftobase__Holder_reco__Jet_edm__Ref_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__reftobase__Holder_reco__Jet_edm__Ref_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s__funcmem_bld);
}

//------Delayed data member builder for class Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >, reco::FFTAnyJet<reco::GenJet>, edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >, reco::FFTAnyJet<reco::GenJet> > > > -------------------
void __edm__reftobase__Holder_reco__Jet_edm__Ref_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_5021, Reflex::Literal("ref_"), OffsetOf(__shadow__::__edm__reftobase__Holder_reco__Jet_edm__Ref_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s_, ref_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >, reco::FFTAnyJet<reco::GenJet>, edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >, reco::FFTAnyJet<reco::GenJet> > > > -------------------
void __edm__reftobase__Holder_reco__Jet_edm__Ref_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_44580, type_44579), Reflex::Literal("operator="), operator_39695, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_44580), Reflex::Literal("swap"), method_39696, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39872), Reflex::Literal("clone"), method_39698, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14466), Reflex::Literal("getPtr"), method_39699, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4933), Reflex::Literal("id"), method_39700, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2121), Reflex::Literal("key"), method_39701, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566, type_44557), Reflex::Literal("isEqualTo"), method_39702, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_38861), Reflex::Literal("getRef"), method_39703, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566, type_21905, type_11079), Reflex::Literal("fillRefIfMyTypeMatches"), method_39704, 0, "fillme;msg", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2773), Reflex::Literal("holder"), method_39705, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776), Reflex::Literal("makeVectorHolder"), method_39706, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2771), Reflex::Literal("makeVectorBaseHolder"), method_39707, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20675), Reflex::Literal("productGetter"), method_39708, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("hasProductCache"), method_39709, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4071), Reflex::Literal("product"), method_39710, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isAvailable"), method_39711, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_237), Reflex::Literal("Class_Version"), method_39712, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >, reco::FFTAnyJet<reco::GenJet>, edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >, reco::FFTAnyJet<reco::GenJet> > > > -------------------------------
static void constructor_39714( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >();
  else ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >();
}

static void constructor_39715( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >(*(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)arg[0]);
  else ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >(*(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)arg[0]);
}

static void constructor_39716( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >(*(const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)arg[0]);
  else ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >(*(const ::edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > >*)arg[0]);
}

static  void operator_39717( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->operator=)(*(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)arg[0]);
  else   (((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->operator=)(*(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)arg[0]);
}

static  void method_39718( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->swap)(*(::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)arg[0]);
}

static void destructor_39719(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >::~Holder)();
}
static  void method_39720( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->clone)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->clone)();
}

static  void method_39721( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->getPtr)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->getPtr)();
}

static  void method_39722( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->id)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->id)();
}

static  void method_39723( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->key)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->key)();
}

static  void method_39724( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->isEqualTo)(*(const ::edm::reftobase::BaseHolder<reco::Candidate>*)arg[0]));
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->isEqualTo)(*(const ::edm::reftobase::BaseHolder<reco::Candidate>*)arg[0]);
}

static  void method_39725( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->getRef)();
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->getRef)();
}

static  void method_39726( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]));
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]);
}

static  void method_39727( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefHolderBase>)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->holder)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->holder)();
}

static  void method_39728( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::BaseVectorHolder<reco::Candidate> >)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->makeVectorHolder)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->makeVectorHolder)();
}

static  void method_39729( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefVectorHolderBase>)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->makeVectorBaseHolder)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->makeVectorBaseHolder)();
}

static  void method_39730( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->productGetter)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->productGetter)();
}

static  void method_39731( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->hasProductCache)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->hasProductCache)();
}

static  void method_39732( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->product)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->product)();
}

static  void method_39733( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->isAvailable)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->isAvailable)();
}

static  void method_39734( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->Class_Version)());
  else   (((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >*)o)->Class_Version)();
}

static void method_newdel_23864( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x176( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::BaseHolder<reco::Candidate>")), ::Reflex::BaseOffset< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >,::edm::reftobase::BaseHolder<reco::Candidate> >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >, reco::FFTAnyJet<reco::GenJet>, edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >, reco::FFTAnyJet<reco::GenJet> > > > -------------------------------
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s__db_datamem(Reflex::Class*);
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s__datamem_bld(&__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s__funcmem_bld(&__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s__db_funcmem);
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >"), typeid(::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >), sizeof(::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >::Class_Version())
  .AddProperty(Reflex::Literal("o_name"), "edm::reftobase::Holder<reco::Candidate, reco::FFTGenJetRef>")
  .AddBase(type_23848, ::Reflex::BaseOffset< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > >, ::edm::reftobase::BaseHolder<reco::Candidate> >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Holder"), constructor_39714, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_44581), Reflex::Literal("Holder"), constructor_39715, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_38861), Reflex::Literal("Holder"), constructor_39716, 0, "r", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Holder"), destructor_39719, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_23864, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x176, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s__funcmem_bld);
}

//------Delayed data member builder for class Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >, reco::FFTAnyJet<reco::GenJet>, edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >, reco::FFTAnyJet<reco::GenJet> > > > -------------------
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_5021, Reflex::Literal("ref_"), OffsetOf(__shadow__::__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s_, ref_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >, reco::FFTAnyJet<reco::GenJet>, edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet>, std::allocator<reco::FFTAnyJet<reco::GenJet> > >, reco::FFTAnyJet<reco::GenJet> > > > -------------------
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_44582, type_44581), Reflex::Literal("operator="), operator_39717, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_44582), Reflex::Literal("swap"), method_39718, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39874), Reflex::Literal("clone"), method_39720, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39879), Reflex::Literal("getPtr"), method_39721, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4933), Reflex::Literal("id"), method_39722, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2121), Reflex::Literal("key"), method_39723, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566, type_44559), Reflex::Literal("isEqualTo"), method_39724, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_38861), Reflex::Literal("getRef"), method_39725, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566, type_21905, type_11079), Reflex::Literal("fillRefIfMyTypeMatches"), method_39726, 0, "fillme;msg", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2773), Reflex::Literal("holder"), method_39727, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2777), Reflex::Literal("makeVectorHolder"), method_39728, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2771), Reflex::Literal("makeVectorBaseHolder"), method_39729, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20675), Reflex::Literal("productGetter"), method_39730, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("hasProductCache"), method_39731, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4071), Reflex::Literal("product"), method_39732, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1566), Reflex::Literal("isAvailable"), method_39733, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_237), Reflex::Literal("Class_Version"), method_39734, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
namespace {
  struct Dictionaries {
    Dictionaries() {
      Reflex::Instance initialize_reflex;
      __std__pair_edm__RefToBase_reco__Jet__reco__CATopJetProperties__dict(); 
      __reco__PattRecoPeak_double__dict(); 
      __reco__PattRecoNode_reco__PattRecoPeak_double_s__dict(); 
      __std__vector_reco__PattRecoNode_reco__PattRecoPeak_double_s_s__dict(); 
      __reco__PattRecoPeak_float__dict(); 
      __reco__PattRecoNode_reco__PattRecoPeak_float_s__dict(); 
      __std__vector_reco__PattRecoNode_reco__PattRecoPeak_float_s_s__dict(); 
      __reco__TrackExtrapolation_dict(); 
      __std__vector_reco__TrackExtrapolation__dict(); 
      __std__vector_reco__PFJet__Specific__dict(); 
      __std__vector_reco__JPTJet__Specific__dict(); 
      __std__vector_reco__CaloJet__Specific__dict(); 
      __edm__Ptr_reco__PFCluster__dict(); 
      __std__vector_edm__Ptr_reco__PFCluster_s__dict(); 
      __reco__CastorJetID_dict(); 
      __std__vector_reco__CastorJetID__dict(); 
      __reco__JetID_dict(); 
      __std__vector_reco__JetID__dict(); 
      __edm__PtrVector_reco__CastorJetID__dict(); 
      __edm__PtrVector_reco__JetID__dict(); 
      __edm__PtrVector_reco__PFClusterJet__dict(); 
      __edm__PtrVector_reco__TrackJet__dict(); 
      __edm__PtrVector_reco__GenJet__dict(); 
      __edm__PtrVector_reco__BasicJet__dict(); 
      __edm__PtrVector_reco__PFJet__dict(); 
      __edm__PtrVector_reco__CaloJet__dict(); 
      __edm__PtrVector_reco__Jet__dict(); 
      __edm__RefVector_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_edm__refhelper__FindUsingAdvance_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_s__dict(); 
      __edm__RefVector_std__vector_reco__CastorJetID__reco__CastorJetID_edm__refhelper__FindUsingAdvance_std__vector_reco__CastorJetID__reco__CastorJetID_s__dict(); 
      __edm__RefVector_std__vector_reco__JetID__reco__JetID_edm__refhelper__FindUsingAdvance_std__vector_reco__JetID__reco__JetID_s__dict(); 
      __reco__FFTJetProducerSummary_dict(); 
      __edm__Wrapper_reco__FFTJetProducerSummary__dict(); 
      __reco__PattRecoTree_double_reco__PattRecoPeak_double_s__dict(); 
      __edm__Wrapper_reco__PattRecoTree_double_reco__PattRecoPeak_double_s_s__dict(); 
      __reco__PattRecoTree_float_reco__PattRecoPeak_float_s__dict(); 
      __edm__Wrapper_reco__PattRecoTree_float_reco__PattRecoPeak_float_s_s__dict(); 
      __edm__RefProd_std__vector_reco__TrackExtrapolation_s__dict(); 
      __edm__Wrapper_edm__RefProd_std__vector_reco__TrackExtrapolation_s_s__dict(); 
      __edm__Wrapper_edm__RefVector_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_edm__refhelper__FindUsingAdvance_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_s_s__dict(); 
      __edm__Ref_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_edm__refhelper__FindUsingAdvance_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_s__dict(); 
      __edm__Wrapper_edm__Ref_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_edm__refhelper__FindUsingAdvance_std__vector_reco__TrackExtrapolation__reco__TrackExtrapolation_s_s__dict(); 
      __edm__Wrapper_std__vector_reco__TrackExtrapolation_s__dict(); 
      __edm__Wrapper_reco__TrackExtrapolation__dict(); 
      __edm__ValueMap_reco__CastorJetID__dict(); 
      __edm__Wrapper_edm__ValueMap_reco__CastorJetID_s__dict(); 
      __edm__Wrapper_std__vector_reco__CastorJetID_s__dict(); 
      __edm__ValueMap_reco__JetID__dict(); 
      __edm__Wrapper_edm__ValueMap_reco__JetID_s__dict(); 
      __edm__Wrapper_std__vector_reco__JetID_s__dict(); 
      __edm__RefProd_std__vector_reco__CastorJetID_s__dict(); 
      __edm__RefProd_std__vector_reco__JetID_s__dict(); 
      __edm__Ptr_reco__CastorJetID__dict(); 
      __edm__Ptr_reco__JetID__dict(); 
      __edm__Ptr_reco__PFClusterJet__dict(); 
      __edm__Ptr_reco__TrackJet__dict(); 
      __edm__Ptr_reco__GenJet__dict(); 
      __edm__Ptr_reco__BasicJet__dict(); 
      __edm__Ptr_reco__PFJet__dict(); 
      __edm__Ptr_reco__CaloJet__dict(); 
      __edm__Ptr_reco__Jet__dict(); 
      __edm__Ref_std__vector_reco__CastorJetID__reco__CastorJetID_edm__refhelper__FindUsingAdvance_std__vector_reco__CastorJetID__reco__CastorJetID_s__dict(); 
      __edm__Ref_std__vector_reco__JetID__reco__JetID_edm__refhelper__FindUsingAdvance_std__vector_reco__JetID__reco__JetID_s__dict(); 
      __reco__CATopJetTagInfo_dict(); 
      __reco__CATopJetProperties_dict(); 
      __reco__FFTJet_float__dict(); 
      __reco__FFTJet_double__dict(); 
      __reco__FFTAnyJet_reco__GenJet__dict(); 
      __edm__FwdRef_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s__dict(); 
      __edm__RefVector_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s__dict(); 
      __reco__FFTAnyJet_reco__CaloJet__dict(); 
      __edm__FwdRef_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s__dict(); 
      __edm__RefVector_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s__dict(); 
      __edm__FwdPtr_reco__FFTAnyJet_reco__CaloJet_s__dict(); 
      __std__vector_edm__FwdPtr_reco__FFTAnyJet_reco__CaloJet_s_s__dict(); 
      __std__vector_reco__FFTAnyJet_reco__CaloJet_s__dict(); 
      __edm__FwdPtr_reco__FFTAnyJet_reco__GenJet_s__dict(); 
      __std__vector_edm__FwdPtr_reco__FFTAnyJet_reco__GenJet_s_s__dict(); 
      __edm__Ref_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s__dict(); 
      __std__vector_edm__FwdRef_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s__dict(); 
      __std__vector_reco__FFTAnyJet_reco__GenJet_s__dict(); 
      __edm__RefProd_std__vector_reco__FFTAnyJet_reco__GenJet_s_s__dict(); 
      __std__vector_reco__CATopJetTagInfo__dict(); 
      __edm__RefProd_std__vector_reco__CATopJetTagInfo_s__dict(); 
      __edm__RefProd_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s__dict(); 
      __edm__RefVector_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s__dict(); 
      __std__vector_edm__FwdRef_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s__dict(); 
      __edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s__dict(); 
      __edm__Ref_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s__dict(); 
      __edm__PtrVector_reco__FFTAnyJet_reco__CaloJet_s__dict(); 
      __edm__PtrVector_reco__FFTAnyJet_reco__GenJet_s__dict(); 
      __edm__Wrapper_std__vector_reco__CATopJetTagInfo_s__dict(); 
      __edm__Association_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s__dict(); 
      __edm__Wrapper_edm__Association_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s_s__dict(); 
      __edm__Wrapper_std__vector_edm__FwdPtr_reco__FFTAnyJet_reco__CaloJet_s_s_s__dict(); 
      __edm__Wrapper_std__vector_edm__FwdRef_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s_s__dict(); 
      __edm__Wrapper_edm__RefVector_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s__dict(); 
      __edm__Wrapper_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s__dict(); 
      __edm__Association_std__vector_reco__FFTAnyJet_reco__GenJet_s_s__dict(); 
      __edm__Wrapper_edm__Association_std__vector_reco__FFTAnyJet_reco__GenJet_s_s_s__dict(); 
      __edm__Wrapper_std__vector_edm__FwdPtr_reco__FFTAnyJet_reco__GenJet_s_s_s__dict(); 
      __edm__Wrapper_std__vector_edm__FwdRef_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s_s__dict(); 
      __edm__Wrapper_edm__RefVector_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s__dict(); 
      __edm__Wrapper_std__vector_reco__FFTAnyJet_reco__GenJet_s_s__dict(); 
      __edm__Association_std__vector_reco__PFJet_s__dict(); 
      __edm__Wrapper_edm__Association_std__vector_reco__PFJet_s_s__dict(); 
      __edm__Association_std__vector_reco__GenJet_s__dict(); 
      __edm__Wrapper_edm__Association_std__vector_reco__GenJet_s_s__dict(); 
      __edm__Ptr_reco__FFTAnyJet_reco__CaloJet_s__dict(); 
      __edm__Ptr_reco__FFTAnyJet_reco__GenJet_s__dict(); 
      __reco__JetTrackMatch_std__vector_reco__FFTAnyJet_reco__CaloJet_s_s__dict(); 
      __reco__JetTrackMatch_std__vector_reco__FFTAnyJet_reco__GenJet_s_s__dict(); 
      __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_s__dict(); 
      __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s__dict(); 
      __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s__dict(); 
      __edm__reftobase__Holder_reco__BaseTagInfo_edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_s__dict(); 
      __edm__reftobase__Holder_reco__Jet_edm__Ref_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s__dict(); 
      __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__CaloJet_s__reco__FFTAnyJet_reco__CaloJet_s_s_s__dict(); 
      __edm__reftobase__Holder_reco__Jet_edm__Ref_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s__dict(); 
      __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet__edm__refhelper__FindUsingAdvance_std__vector_reco__FFTAnyJet_reco__GenJet_s__reco__FFTAnyJet_reco__GenJet_s_s_s__dict(); 
    }
    ~Dictionaries() {
      type_2924.Unload(); // class std::pair<edm::RefToBase<reco::Jet>,reco::CATopJetProperties> 
      type_7809.Unload(); // class reco::PattRecoPeak<double> 
      type_7891.Unload(); // class reco::PattRecoNode<reco::PattRecoPeak<double> > 
      type_2990.Unload(); // class std::vector<reco::PattRecoNode<reco::PattRecoPeak<double> > > 
      type_7810.Unload(); // class reco::PattRecoPeak<float> 
      type_7892.Unload(); // class reco::PattRecoNode<reco::PattRecoPeak<float> > 
      type_2992.Unload(); // class std::vector<reco::PattRecoNode<reco::PattRecoPeak<float> > > 
      type_7787.Unload(); // class reco::TrackExtrapolation 
      type_2993.Unload(); // class std::vector<reco::TrackExtrapolation> 
      type_2994.Unload(); // class std::vector<reco::PFJet::Specific> 
      type_2995.Unload(); // class std::vector<reco::JPTJet::Specific> 
      type_2996.Unload(); // class std::vector<reco::CaloJet::Specific> 
      type_4990.Unload(); // class edm::Ptr<reco::PFCluster> 
      type_2997.Unload(); // class std::vector<edm::Ptr<reco::PFCluster> > 
      type_7846.Unload(); // class reco::CastorJetID 
      type_2999.Unload(); // class std::vector<reco::CastorJetID> 
      type_7841.Unload(); // class reco::JetID 
      type_3000.Unload(); // class std::vector<reco::JetID> 
      type_4636.Unload(); // class edm::PtrVector<reco::CastorJetID> 
      type_4637.Unload(); // class edm::PtrVector<reco::JetID> 
      type_4638.Unload(); // class edm::PtrVector<reco::PFClusterJet> 
      type_4639.Unload(); // class edm::PtrVector<reco::TrackJet> 
      type_4640.Unload(); // class edm::PtrVector<reco::GenJet> 
      type_4641.Unload(); // class edm::PtrVector<reco::BasicJet> 
      type_4642.Unload(); // class edm::PtrVector<reco::PFJet> 
      type_4644.Unload(); // class edm::PtrVector<reco::CaloJet> 
      type_4645.Unload(); // class edm::PtrVector<reco::Jet> 
      type_4681.Unload(); // class edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > 
      type_4686.Unload(); // class edm::RefVector<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> > 
      type_4691.Unload(); // class edm::RefVector<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> > 
      type_7921.Unload(); // class reco::FFTJetProducerSummary 
      type_4750.Unload(); // class edm::Wrapper<reco::FFTJetProducerSummary> 
      type_7832.Unload(); // class reco::PattRecoTree<double,reco::PattRecoPeak<double> > 
      type_4751.Unload(); // class edm::Wrapper<reco::PattRecoTree<double,reco::PattRecoPeak<double> > > 
      type_7833.Unload(); // class reco::PattRecoTree<float,reco::PattRecoPeak<float> > 
      type_4752.Unload(); // class edm::Wrapper<reco::PattRecoTree<float,reco::PattRecoPeak<float> > > 
      type_4956.Unload(); // class edm::RefProd<std::vector<reco::TrackExtrapolation> > 
      type_4753.Unload(); // class edm::Wrapper<edm::RefProd<std::vector<reco::TrackExtrapolation> > > 
      type_4754.Unload(); // class edm::Wrapper<edm::RefVector<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > > 
      type_5022.Unload(); // class edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > 
      type_4755.Unload(); // class edm::Wrapper<edm::Ref<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation,edm::refhelper::FindUsingAdvance<std::vector<reco::TrackExtrapolation>,reco::TrackExtrapolation> > > 
      type_4756.Unload(); // class edm::Wrapper<std::vector<reco::TrackExtrapolation> > 
      type_4757.Unload(); // class edm::Wrapper<reco::TrackExtrapolation> 
      type_5080.Unload(); // class edm::ValueMap<reco::CastorJetID> 
      type_4760.Unload(); // class edm::Wrapper<edm::ValueMap<reco::CastorJetID> > 
      type_4762.Unload(); // class edm::Wrapper<std::vector<reco::CastorJetID> > 
      type_5081.Unload(); // class edm::ValueMap<reco::JetID> 
      type_4763.Unload(); // class edm::Wrapper<edm::ValueMap<reco::JetID> > 
      type_4765.Unload(); // class edm::Wrapper<std::vector<reco::JetID> > 
      type_4959.Unload(); // class edm::RefProd<std::vector<reco::CastorJetID> > 
      type_4960.Unload(); // class edm::RefProd<std::vector<reco::JetID> > 
      type_4988.Unload(); // class edm::Ptr<reco::CastorJetID> 
      type_4989.Unload(); // class edm::Ptr<reco::JetID> 
      type_4991.Unload(); // class edm::Ptr<reco::PFClusterJet> 
      type_4992.Unload(); // class edm::Ptr<reco::TrackJet> 
      type_4993.Unload(); // class edm::Ptr<reco::GenJet> 
      type_4994.Unload(); // class edm::Ptr<reco::BasicJet> 
      type_4995.Unload(); // class edm::Ptr<reco::PFJet> 
      type_4997.Unload(); // class edm::Ptr<reco::CaloJet> 
      type_4998.Unload(); // class edm::Ptr<reco::Jet> 
      type_5025.Unload(); // class edm::Ref<std::vector<reco::CastorJetID>,reco::CastorJetID,edm::refhelper::FindUsingAdvance<std::vector<reco::CastorJetID>,reco::CastorJetID> > 
      type_5026.Unload(); // class edm::Ref<std::vector<reco::JetID>,reco::JetID,edm::refhelper::FindUsingAdvance<std::vector<reco::JetID>,reco::JetID> > 
      type_7813.Unload(); // class reco::CATopJetTagInfo 
      type_7826.Unload(); // class reco::CATopJetProperties 
      type_7938.Unload(); // class reco::FFTJet<float> 
      type_7939.Unload(); // class reco::FFTJet<double> 
      type_7811.Unload(); // class reco::FFTAnyJet<reco::GenJet> 
      type_4775.Unload(); // class edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > 
      type_4676.Unload(); // class edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > 
      type_7851.Unload(); // class reco::FFTAnyJet<reco::CaloJet> 
      type_4774.Unload(); // class edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > 
      type_4665.Unload(); // class edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > 
      type_4655.Unload(); // class edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > 
      type_2981.Unload(); // class std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > 
      type_2983.Unload(); // class std::vector<reco::FFTAnyJet<reco::CaloJet> > 
      type_4656.Unload(); // class edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > 
      type_2986.Unload(); // class std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > 
      type_5021.Unload(); // class edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > 
      type_2982.Unload(); // class std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > 
      type_2988.Unload(); // class std::vector<reco::FFTAnyJet<reco::GenJet> > 
      type_4955.Unload(); // class edm::RefProd<std::vector<reco::FFTAnyJet<reco::GenJet> > > 
      type_2973.Unload(); // class std::vector<reco::CATopJetTagInfo> 
      type_4952.Unload(); // class edm::RefProd<std::vector<reco::CATopJetTagInfo> > 
      type_4953.Unload(); // class edm::RefProd<std::vector<reco::FFTAnyJet<reco::CaloJet> > > 
      type_4671.Unload(); // class edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > 
      type_2987.Unload(); // class std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > 
      type_5018.Unload(); // class edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > 
      type_5019.Unload(); // class edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > 
      type_4634.Unload(); // class edm::PtrVector<reco::FFTAnyJet<reco::CaloJet> > 
      type_4635.Unload(); // class edm::PtrVector<reco::FFTAnyJet<reco::GenJet> > 
      type_4739.Unload(); // class edm::Wrapper<std::vector<reco::CATopJetTagInfo> > 
      type_5012.Unload(); // class edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > > 
      type_4740.Unload(); // class edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::CaloJet> > > > 
      type_4741.Unload(); // class edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::CaloJet> > > > 
      type_4742.Unload(); // class edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > > 
      type_4743.Unload(); // class edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > 
      type_4744.Unload(); // class edm::Wrapper<std::vector<reco::FFTAnyJet<reco::CaloJet> > > 
      type_5013.Unload(); // class edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > > 
      type_4745.Unload(); // class edm::Wrapper<edm::Association<std::vector<reco::FFTAnyJet<reco::GenJet> > > > 
      type_4746.Unload(); // class edm::Wrapper<std::vector<edm::FwdPtr<reco::FFTAnyJet<reco::GenJet> > > > 
      type_4747.Unload(); // class edm::Wrapper<std::vector<edm::FwdRef<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > > 
      type_4748.Unload(); // class edm::Wrapper<edm::RefVector<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > 
      type_4749.Unload(); // class edm::Wrapper<std::vector<reco::FFTAnyJet<reco::GenJet> > > 
      type_5014.Unload(); // class edm::Association<std::vector<reco::PFJet> > 
      type_4758.Unload(); // class edm::Wrapper<edm::Association<std::vector<reco::PFJet> > > 
      type_5015.Unload(); // class edm::Association<std::vector<reco::GenJet> > 
      type_4759.Unload(); // class edm::Wrapper<edm::Association<std::vector<reco::GenJet> > > 
      type_4986.Unload(); // class edm::Ptr<reco::FFTAnyJet<reco::CaloJet> > 
      type_4987.Unload(); // class edm::Ptr<reco::FFTAnyJet<reco::GenJet> > 
      type_7875.Unload(); // class reco::JetTrackMatch<std::vector<reco::FFTAnyJet<reco::CaloJet> > > 
      type_7876.Unload(); // class reco::JetTrackMatch<std::vector<reco::FFTAnyJet<reco::GenJet> > > 
      type_23851.Unload(); // class edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > > 
      type_23852.Unload(); // class edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > 
      type_23853.Unload(); // class edm::reftobase::RefHolder<edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > 
      type_23860.Unload(); // class edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > > 
      type_23861.Unload(); // class edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > 
      type_23862.Unload(); // class edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::CaloJet> >,reco::FFTAnyJet<reco::CaloJet> > > > 
      type_23863.Unload(); // class edm::reftobase::Holder<reco::Jet,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > 
      type_23864.Unload(); // class edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet>,edm::refhelper::FindUsingAdvance<std::vector<reco::FFTAnyJet<reco::GenJet> >,reco::FFTAnyJet<reco::GenJet> > > > 
    }
  };
  static Dictionaries instance;
}
} // unnamed namespace
